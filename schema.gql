"""A charge to the customer."""
type Charge implements TransactionType {
  id: ID
  postedDate: Date

  """The date time when the transaction is created."""
  createdAt: DateTime

  """Unique identifier of the account the transaction belongs to."""
  accountNumber: String

  """
  Gross amount including tax (when payable). Refer to the `amounts` field for a breakdown of this information.
  """
  amount: Int @deprecated(reason: "The 'amount' field is deprecated.\n\nUse `amounts` instead for a breakdown of the relevant net, tax, and gross amounts.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-06-01.")

  """
  The net, tax and gross amounts for the transaction. Note: for payments and repayments, only the net amount is returned.
  """
  amounts: TransactionAmountType

  """
  The customer's resulting balance after this transaction has been applied, in the smallest unit of currency.
  """
  balanceCarriedForward: Int

  """Deprecated."""
  isCredit: Boolean @deprecated(reason: "The 'isCredit' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """Deprecated."""
  isAccountCharge: Boolean @deprecated(reason: "The 'isAccountCharge' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """Deprecated."""
  isAccountPayment: Boolean @deprecated(reason: "The 'isAccountPayment' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.  Returns False if a statement is not linked with the transaction.
  """
  isHeld: Boolean

  """
  Whether this transaction has been issued on any billing document.Note: Look for the most recently issued transaction instead of looking through all transactions as some accounts may have initial transactions that were not issued.This will return False if the transaction is not associated with any billing documents.
  """
  isIssued: Boolean
  title: String

  """
  The unique identifier for the most recent billing document linked with the transaction.Note: a transaction may be linked with multiple documents, but this field will only return the identifier for the most recent billing document.
  """
  billingDocumentIdentifier: ID

  """Returns None if a statement is not linked with the transaction."""
  statementId: ID @deprecated(reason: "The 'statementId' field is deprecated.\n\nUse `billingDocumentIdentifier` instead.\n\n- Marked as deprecated on 2023-11-30.\n- Will be removed on 2024-06-01.")
  isReversed: Boolean!

  """Returns True if the transaction is linked with a statement."""
  hasStatement: Boolean

  """
  Returns the note field value for the transaction, which contains additional info.
  """
  note: String

  """
  If this charge is for consumption of a good or service, this field will contain details of how much was consumed. Omitted in cases where the charge is not for consumption, or where consumption information is not available (e.g. for some older records).
  """
  consumption: Consumption
}

type StatementType implements BillInterface {
  id: ID
  billType: BillTypeEnum
  fromDate: Date
  toDate: Date

  "Requesting this field generates a temporary URL at which bill is available.\n        This URL will expire after approximately an hour.  It is intended for redirection purposes,\n        NOT persistence in any form (e.g. inclusion in emails or the body of a web page).\n        This field can raise an error with errorClass NOT_FOUND if the bill document has not\n        been created/issued yet.\n\n\n        "
  temporaryUrl: String

  """The date the bill was sent to the customer."""
  issuedDate: Date

  """This field returns the closing balance of an issued statement."""
  closingBalance: Int

  """This field returns the opening balance of a statement."""
  openingBalance: Int

  """Whether the bill originated in Kraken or externally."""
  isExternalBill: Boolean

  """Transactions on the bill."""
  transactions(before: String, after: String, first: Int, last: Int): TransactionConnectionTypeConnection

  """Email recipient user ID."""
  userId: Int

  """Email recipient address."""
  toAddress: String

  """The date the bill is due to be paid."""
  paymentDueDate: Date

  """The first day of consumption that this statement includes."""
  consumptionStartDate: Date

  """The last day of consumption that this statement includes."""
  consumptionEndDate: Date

  """How many charges have been reversed after the close date."""
  reversalsAfterClose: StatementReversalsAfterClose!

  """Current status of the associated statement."""
  status: AccountStatementStatus

  """Retrieve the held status of a account statement."""
  heldStatus: HeldStatus

  """The total amounts for all charges on the statement."""
  totalCharges: StatementTotalType

  """The total amounts for all credits on the statement."""
  totalCredits: StatementTotalType
}

"""An enumeration."""
enum StatementReversalsAfterClose {
  """All charges have been reversed after the statement was closed."""
  ALL

  """Some charges have been reversed after the statement was closed."""
  SOME

  """No reversals after the statement was closed."""
  NONE

  """The statement has not been closed yet."""
  NOT_CLOSED
}

"""An enumeration."""
enum AccountStatementStatus {
  OPEN
  CLOSED
}

type HeldStatus {
  """Whether a statement is currently held."""
  isHeld: Boolean

  """Reason for statement being held."""
  reason: String
}

type StatementTotalType {
  """The net total amount for the statement (in minor currency units)."""
  netTotal: Int

  """The total amount of tax on the statement (in minor currency units)."""
  taxTotal: Int

  """The gross total amount for the statement (in minor currency units)."""
  grossTotal: Int
}

type PreKrakenBillType implements BillInterface {
  id: ID
  billType: BillTypeEnum
  fromDate: Date
  toDate: Date

  "Requesting this field generates a temporary URL at which bill is available.\n        This URL will expire after approximately an hour.  It is intended for redirection purposes,\n        NOT persistence in any form (e.g. inclusion in emails or the body of a web page).\n        This field can raise an error with errorClass NOT_FOUND if the bill document has not\n        been created/issued yet.\n\n\n        "
  temporaryUrl: String

  """The date the bill was sent to the customer."""
  issuedDate: Date

  """The params associated with the historical bill."""
  params: JSONString
}

type PeriodBasedDocumentType implements BillInterface {
  id: ID
  billType: BillTypeEnum
  fromDate: Date
  toDate: Date

  "Requesting this field generates a temporary URL at which bill is available.\n        This URL will expire after approximately an hour.  It is intended for redirection purposes,\n        NOT persistence in any form (e.g. inclusion in emails or the body of a web page).\n        This field can raise an error with errorClass NOT_FOUND if the bill document has not\n        been created/issued yet.\n\n\n        "
  temporaryUrl: String

  """The date the bill was sent to the customer."""
  issuedDate: Date

  "\nThe unique identifier for the billing document. Note: a pending billing document will not have an identifier yet;\nand not all finalized billing documents will have an identifier assigned to them, in which case this will be null.\n"
  identifier: ID

  """The total amounts for all charges on the billing document."""
  totalCharges: StatementTotalType

  """The total amounts for all credits on the statement."""
  totalCredits: StatementTotalType
}

type InvoiceType implements BillInterface {
  id: ID
  billType: BillTypeEnum
  fromDate: Date
  toDate: Date

  "Requesting this field generates a temporary URL at which bill is available.\n        This URL will expire after approximately an hour.  It is intended for redirection purposes,\n        NOT persistence in any form (e.g. inclusion in emails or the body of a web page).\n        This field can raise an error with errorClass NOT_FOUND if the bill document has not\n        been created/issued yet.\n\n\n        "
  temporaryUrl: String

  """The date the bill was sent to the customer."""
  issuedDate: Date
}

"""A payment from the customer to the energy supplier."""
type Payment implements TransactionType {
  id: ID
  postedDate: Date

  """The date time when the transaction is created."""
  createdAt: DateTime

  """Unique identifier of the account the transaction belongs to."""
  accountNumber: String

  """
  Gross amount including tax (when payable). Refer to the `amounts` field for a breakdown of this information.
  """
  amount: Int @deprecated(reason: "The 'amount' field is deprecated.\n\nUse `amounts` instead for a breakdown of the relevant net, tax, and gross amounts.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-06-01.")

  """
  The net, tax and gross amounts for the transaction. Note: for payments and repayments, only the net amount is returned.
  """
  amounts: TransactionAmountType

  """
  The customer's resulting balance after this transaction has been applied, in the smallest unit of currency.
  """
  balanceCarriedForward: Int

  """Deprecated."""
  isCredit: Boolean @deprecated(reason: "The 'isCredit' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """Deprecated."""
  isAccountCharge: Boolean @deprecated(reason: "The 'isAccountCharge' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """Deprecated."""
  isAccountPayment: Boolean @deprecated(reason: "The 'isAccountPayment' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.  Returns False if a statement is not linked with the transaction.
  """
  isHeld: Boolean

  """
  Whether this transaction has been issued on any billing document.Note: Look for the most recently issued transaction instead of looking through all transactions as some accounts may have initial transactions that were not issued.This will return False if the transaction is not associated with any billing documents.
  """
  isIssued: Boolean
  title: String

  """
  The unique identifier for the most recent billing document linked with the transaction.Note: a transaction may be linked with multiple documents, but this field will only return the identifier for the most recent billing document.
  """
  billingDocumentIdentifier: ID

  """Returns None if a statement is not linked with the transaction."""
  statementId: ID @deprecated(reason: "The 'statementId' field is deprecated.\n\nUse `billingDocumentIdentifier` instead.\n\n- Marked as deprecated on 2023-11-30.\n- Will be removed on 2024-06-01.")
  isReversed: Boolean!

  """Returns True if the transaction is linked with a statement."""
  hasStatement: Boolean

  """
  Returns the note field value for the transaction, which contains additional info.
  """
  note: String
}

"""A refund to the customer from the energy supplier."""
type Refund implements TransactionType {
  id: ID
  postedDate: Date

  """The date time when the transaction is created."""
  createdAt: DateTime

  """Unique identifier of the account the transaction belongs to."""
  accountNumber: String

  """
  Gross amount including tax (when payable). Refer to the `amounts` field for a breakdown of this information.
  """
  amount: Int @deprecated(reason: "The 'amount' field is deprecated.\n\nUse `amounts` instead for a breakdown of the relevant net, tax, and gross amounts.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-06-01.")

  """
  The net, tax and gross amounts for the transaction. Note: for payments and repayments, only the net amount is returned.
  """
  amounts: TransactionAmountType

  """
  The customer's resulting balance after this transaction has been applied, in the smallest unit of currency.
  """
  balanceCarriedForward: Int

  """Deprecated."""
  isCredit: Boolean @deprecated(reason: "The 'isCredit' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """Deprecated."""
  isAccountCharge: Boolean @deprecated(reason: "The 'isAccountCharge' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """Deprecated."""
  isAccountPayment: Boolean @deprecated(reason: "The 'isAccountPayment' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.  Returns False if a statement is not linked with the transaction.
  """
  isHeld: Boolean

  """
  Whether this transaction has been issued on any billing document.Note: Look for the most recently issued transaction instead of looking through all transactions as some accounts may have initial transactions that were not issued.This will return False if the transaction is not associated with any billing documents.
  """
  isIssued: Boolean
  title: String

  """
  The unique identifier for the most recent billing document linked with the transaction.Note: a transaction may be linked with multiple documents, but this field will only return the identifier for the most recent billing document.
  """
  billingDocumentIdentifier: ID

  """Returns None if a statement is not linked with the transaction."""
  statementId: ID @deprecated(reason: "The 'statementId' field is deprecated.\n\nUse `billingDocumentIdentifier` instead.\n\n- Marked as deprecated on 2023-11-30.\n- Will be removed on 2024-06-01.")
  isReversed: Boolean!

  """Returns True if the transaction is linked with a statement."""
  hasStatement: Boolean

  """
  Returns the note field value for the transaction, which contains additional info.
  """
  note: String
}

type Consumption {
  startDate: Date
  endDate: Date
  quantity: Decimal
  unit: ConsumptionUnit
  usageCost: Int
  supplyCharge: Int
}

"""An enumeration."""
enum ConsumptionUnit {
  kWh
  MJ
}

"""A credit to the customer from the energy retailer."""
type Credit implements TransactionType {
  id: ID
  postedDate: Date

  """The date time when the transaction is created."""
  createdAt: DateTime

  """Unique identifier of the account the transaction belongs to."""
  accountNumber: String

  """
  Gross amount including tax (when payable). Refer to the `amounts` field for a breakdown of this information.
  """
  amount: Int @deprecated(reason: "The 'amount' field is deprecated.\n\nUse `amounts` instead for a breakdown of the relevant net, tax, and gross amounts.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-06-01.")

  """
  The net, tax and gross amounts for the transaction. Note: for payments and repayments, only the net amount is returned.
  """
  amounts: TransactionAmountType

  """
  The customer's resulting balance after this transaction has been applied, in the smallest unit of currency.
  """
  balanceCarriedForward: Int

  """Deprecated."""
  isCredit: Boolean @deprecated(reason: "The 'isCredit' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """Deprecated."""
  isAccountCharge: Boolean @deprecated(reason: "The 'isAccountCharge' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """Deprecated."""
  isAccountPayment: Boolean @deprecated(reason: "The 'isAccountPayment' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.  Returns False if a statement is not linked with the transaction.
  """
  isHeld: Boolean

  """
  Whether this transaction has been issued on any billing document.Note: Look for the most recently issued transaction instead of looking through all transactions as some accounts may have initial transactions that were not issued.This will return False if the transaction is not associated with any billing documents.
  """
  isIssued: Boolean
  title: String

  """
  The unique identifier for the most recent billing document linked with the transaction.Note: a transaction may be linked with multiple documents, but this field will only return the identifier for the most recent billing document.
  """
  billingDocumentIdentifier: ID

  """Returns None if a statement is not linked with the transaction."""
  statementId: ID @deprecated(reason: "The 'statementId' field is deprecated.\n\nUse `billingDocumentIdentifier` instead.\n\n- Marked as deprecated on 2023-11-30.\n- Will be removed on 2024-06-01.")
  isReversed: Boolean!

  """Returns True if the transaction is linked with a statement."""
  hasStatement: Boolean

  """
  Returns the note field value for the transaction, which contains additional info.
  """
  note: String
}

type Metadata {
  """The key for the metadata."""
  key: String!

  """The metadata value."""
  value: JSONString
}

"""
Allows use of a JSON String for input / output from the GraphQL schema.

Use of this type is *not recommended* as you lose the benefits of having a defined, static
schema (one of the key benefits of GraphQL).
"""
scalar JSONString

"""The metadata input type for mutations."""
input MetadataInput {
  """
  An identifier for the associated object, e.g. account_number for the Account linked object type.
  """
  identifier: String!

  """The object that the metadata is associated with."""
  linkedObjectType: LinkedObjectType!

  """The key for the metadata."""
  key: String!

  """The metadata value which should be a valid JSON string."""
  value: JSONString!
}

enum LinkedObjectType {
  ACCOUNT
  ACCOUNT_USER
}

"""A Loyalty Point ledger entry."""
type LoyaltyPointLedgerEntryType {
  id: ID!

  """The `LedgerEntryType`. Either CHARGE or CREDIT."""
  ledgerType: String

  """The value of the charge or credit."""
  value: String

  """
  Equal to the `balance_carried_forward` from the previous ledger entry or zero if this is the first one.
  """
  balanceBroughtForward: String

  """
  Equal to the `balance_brought_forward` plus or minus the value depending on the ledger_type.
  """
  balanceCarriedForward: String

  """The reason the entry was being added."""
  reasonCode: String

  """The date the points were added to the ledger."""
  postedAt: DateTime

  """The account number associated with the entry."""
  accountNumber: String
}

type InkConversation {
  id: ID!

  """The status of the conversation."""
  status: InkConversationStatus!

  """The contact channel identities associated with this conversation."""
  contactChannelIdentities: InkContactChannelIdentities!

  """The account users on the conversation."""
  accountUsers: [AccountUserType!]

  """Conversation events."""
  events(before: String, after: String, first: Int, last: Int): InkConversationEventsConnection!

  """The buckets the conversation is currently in."""
  buckets: [InkBucket!]
}

enum InkConversationStatus {
  OPEN
  OPEN_NEW
  OPEN_CUSTOMER_REPLIED
  OPEN_REMINDED
  SNOOZED
  CLOSED
}

type InkContactChannelIdentities {
  """The default contact for this conversation."""
  default: InkContactChannelIdentity

  """All contacts for this conversation."""
  all: [InkContactChannelIdentity!]!
}

type InkContactChannelIdentity {
  """The channel of the contact."""
  channel: InkCommunicationChannel!

  """The handle."""
  handle: String!

  """The name to display to the user."""
  displayName: String!
}

"""An enumeration."""
enum InkCommunicationChannel {
  EMAIL
  SMS
  POST
}

type InkConversationEventsConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [InkConversationEventsEdge!]!
}

"""A Relay edge containing a `InkConversationEvents` and its cursor."""
type InkConversationEventsEdge {
  """The item at the end of the edge"""
  node: InkConversationEvent!

  """A cursor for use in pagination"""
  cursor: String!
}

union InkConversationEvent = InkNewMessage

"""
This types is used for both the message-received and message-sent conversation events.
"""
type InkNewMessage implements InkConversationEventInterface {
  """The time the conversation event occurred."""
  occurredAt: DateTime!

  """The message."""
  message: InkMessage!
}

interface InkConversationEventInterface {
  """The time the conversation event occurred."""
  occurredAt: DateTime!
}

union InkMessage = InkEmail | InkSMS | InkLine | InkWhatsApp | InkPost | InkGenericMessage

"""This type wraps around the `Message` type for emails."""
type InkEmail {
  """The direction of the email."""
  direction: InkMessageDirection!

  """The addresses that the message was sent to."""
  toHandles: [String!]

  """From email address."""
  fromHandle: String!

  """The delivery status of the message."""
  delivery: InkMessageDelivery!

  """The contact channel identity."""
  contactChannelIdentity: InkContactChannelIdentity!

  """The time the message was sent/received."""
  occurredAt: DateTime!

  """The email subject."""
  subject: String!

  """The content of the message."""
  displayContent: String!

  """Attachments on the message."""
  attachments: [InkMessageAttachment!]!

  """CC recipients on the message."""
  cc: [String!]!

  """Is this an message an email."""
  isChannelEmail: Boolean!

  """All Tags associated with a message."""
  tags: [InkTag!]!
}

enum InkMessageDirection {
  INBOUND
  OUTBOUND
}

type InkMessageDelivery {
  """Message delivery status."""
  status: InkMessageDeliveryStatus!
}

enum InkMessageDeliveryStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
  OUTSIDE_REPLY_WINDOW
}

type InkMessageAttachment {
  """The filename."""
  filename: String!

  """The url for fetching the attachment."""
  fetchUrl: String

  """The size in bytes."""
  sizeInBytes: Int
}

type InkTag implements Node {
  """The ID of the object"""
  id: ID!

  """Tag for a message."""
  name: String!
}

"""This type wraps around the `Message` type for SMS."""
type InkSMS {
  """The direction of the message."""
  direction: InkMessageDirection!

  """The phone number the message was sent from."""
  fromHandle: String!

  """The phone number the message was sent to."""
  toHandle: String!

  """The delivery status."""
  delivery: InkMessageDelivery!

  """The contact channel identity."""
  contactChannelIdentity: InkContactChannelIdentity!

  """The time the message was sent/received at."""
  occurredAt: DateTime!

  """The content of the message."""
  displayContent: String!

  """Is this an SMS message."""
  isChannelSms: Boolean!

  """All Tags associated with a message."""
  tags: [InkTag!]!
}

"""This type wraps around the `Message` type for LINE message."""
type InkLine {
  """The direction of the message."""
  direction: InkMessageDirection!

  """From LINE id."""
  fromHandle: String!

  """To LINE id."""
  toHandle: String!

  """The delivery status of the message."""
  delivery: InkMessageDelivery!

  """The contact channel identity."""
  contactChannelIdentity: InkContactChannelIdentity!

  """The time the message was sent/received."""
  occurredAt: DateTime!

  """The line message content."""
  lineMessage: LineMessage!

  """Is this a LINE message."""
  isChannelLine: Boolean!

  """Attachments on the LINE message."""
  attachments: [InkMessageAttachment!]!

  """All Tags associated with a message."""
  tags: [InkTag!]!
}

union LineMessage = LineTextMessage | LineStickerMessage | LineImageMessage

type LineTextMessage {
  """The display content."""
  displayContent: String!

  """The emojis in the message."""
  emojis: [LineEmoji!]
}

"""
A LINE specific emoji object.
refs: https://developers.line.biz/en/reference/messaging-api/#text-message
"""
type LineEmoji {
  """The location of the emoji in the message."""
  index: Int!

  """The length of the emoji string placeholder."""
  length: Int

  """The product id."""
  productId: String!

  """The emoji id."""
  emojiId: String!
}

type LineStickerMessage {
  """Sticker package id."""
  packageId: String!

  """Sticker id."""
  stickerId: String!

  """Sticker resource type."""
  resourceType: String!

  """Keywords describing the sticker."""
  keywords: [String!]!

  """Text used to customize some stickers."""
  text: String!
}

type LineImageMessage {
  id: ID!
}

"""This type wraps around the `Message` type for WhatsApp message."""
type InkWhatsApp {
  """The direction of the message."""
  direction: InkMessageDirection!

  """From WhatsApp phone number."""
  fromHandle: String!

  """Whatsapp contact phone number."""
  toHandle: String!

  """Whatsapp message delivery status."""
  delivery: InkMessageDelivery!

  """Whatsapp message contact channel identity."""
  contactChannelIdentity: InkContactChannelIdentity!

  """Date when the conversation event was created."""
  occurredAt: DateTime!

  """The vendor id."""
  vendorId: String

  """Whatsapp message content."""
  whatsappContent: WhatsAppTextMessage!

  """Whether or not the message is a whatsapp message."""
  isChannelWhatsapp: Boolean!

  """All Tags associated with a message."""
  tags: [InkTag!]!
}

type WhatsAppTextMessage {
  """Whatsapp text message body."""
  body: String!
}

"""This type wraps around the `Message` type for Post."""
type InkPost {
  """The from property id."""
  fromHandle: String!

  """The to property id."""
  toHandle: String!

  """The notes left when a message was uploaded."""
  displayContent: String!

  """The content of the message."""
  rawPlainTextContent: String!

  """Determine if the message is a post message."""
  isChannelPost: Boolean!

  """The contact channel identity."""
  contactChannelIdentity: InkContactChannelIdentity!
}

"""
This message type is used for messages that belong to contact
channels without a more granular message type.
"""
type InkGenericMessage implements Node {
  """The ID of the object"""
  id: ID!

  """The direction of the message."""
  direction: InkMessageDirection!

  """The identity the message was sent from."""
  fromHandle: String!

  """The identity the message was sent to."""
  toHandle: String!

  """The delivery status."""
  delivery: InkMessageDelivery!

  """The contact channel identity."""
  contactChannelIdentity: InkContactChannelIdentity!

  """The time the message was sent/received at."""
  occurredAt: DateTime!

  """The content of the message."""
  displayContent: String!
}

type InkBucket implements Node {
  """The ID of the object"""
  id: ID!

  """The ink bucket name."""
  name: String!

  """The icon code point."""
  icon: String
}

"""A loyalty card."""
type LoyaltyCardType {
  id: ID!

  """The scheme of the loyalty card."""
  scheme: String

  """The number of the loyalty card."""
  number: String

  """The status of the loyalty card."""
  status: String
}

"""Represents print batch details"""
type PrintBatchType {
  id: ID!

  """The status of the print batch."""
  status: PrintBatchStatus

  """Messages in a print batch."""
  messages(
    """
    Whether to filter to include or exclude high priority messages. If not supplied, no filtering will be performed.
    """
    isHighPriority: Boolean = null
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
  ): PrintMessageTypeConnection
}

"""An enumeration."""
enum PrintBatchStatus {
  OPEN
  CLOSED
  PROCESSED
}

type PrintMessageTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PrintMessageTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""A Relay edge containing a `PrintMessageType` and its cursor."""
type PrintMessageTypeEdge {
  """The item at the end of the edge"""
  node: PrintMessageType

  """A cursor for use in pagination"""
  cursor: String!
}

"""Affiliate link for the organization."""
type AffiliateLinkType {
  id: ID!
  organisation: AffiliateOrganisationType
  subdomain: String!
  trainingStatus: LinkTrainingStatus!
  isBusiness: Boolean!
  contactName: String!
  contactEmail: String!
  landingUrl: String!
}

type AffiliateOrganisationType {
  id: ID!
  name: String!

  """Sales Channel"""
  salesChannel: SalesChannelChoices

  """Allow performing tariff renewals via API."""
  canRenewTariffs: Boolean

  """Default Account Type"""
  defaultAccountType: AccountTypeChoices

  """
  Is this partner allowed to specify payment methods other than Direct Debit in the import csv or API
  """
  allowAlternativePaymentMethods: Boolean

  """
  Are meter point registrations limited for profile classes 1 and 2 for registrations from csv or API
  """
  canRegisterBusinessMeterPoints: Boolean

  """
  Allow registration requests with exiting account user emails to add to the portfolio belonging to the account user.
  """
  canRegisterPortfolioAccounts: Boolean

  """Allow registration requests with customers without an email address."""
  canRegisterCustomersWithoutEmailAddress: Boolean

  """
  Allow this partner access to the IVR support API (modify their own IVR handling through third party 'IVR Flow Editor')
  """
  canUseIvrSupportApi: Boolean

  """
  Allow this partner to skip validation that ensures all meter points belong to the same address
  """
  skipMeterPointAddressValidation: Boolean

  """
  Restrict to field-sales-only products? This is only allowed for the 'field-sales' and 'events' sales channels
  """
  isFieldSalesOnlyProduct: Boolean
}

"""An enumeration."""
enum SalesChannelChoices {
  DIRECT
  PRICE_COMPARISON
  TELESALES
  DIGI_TELESALES
  EVENTS
  FIELD_SALES
  AGGREGATOR
  PARTNERSHIPS
  NEW_TENANT
  MOVE_IN
  WORKPLACE_POP_UP
  BROKER
  PARENT_POWER
  PEOPLE_POWER
  GIFT_OF_KIT
  HIGH_REFERRER
  SUPPLIER_OF_LAST_RESORT
  ACQUISITION
  WORKS_WITH_OCTOPUS
  LANDLORD
  DEBT_COLLECTION_AGENCY
}

"""An enumeration."""
enum LinkTrainingStatus {
  """Not applicable"""
  NOT_APPLICABLE

  """In training"""
  IN_TRAINING

  """Qualified"""
  QUALIFIED
}

"""
Information about what version of Kraken is being executed by this service.
"""
type KrakenVersionType {
  """The version number that is being executed."""
  number: String

  """The git commit SHA that is being executed."""
  SHA: String
}

type TermsAndConditionsType {
  name: String
  pdfUrl: String
  brandCode: String

  """The markdown text of the terms and conditions."""
  markdown: String

  """
  The html of the terms and conditions document rendered as a JSON string.
  """
  html: String
  version: String
  effectiveFrom: DateTime
}

type RateLimitInformation {
  """The maximum number of points the viewer gets for requests per hour."""
  limit: Int

  """The remaining points for the viewer in one hour time limit."""
  remainingPoints: Int

  """The points used so far in one hour time limit."""
  usedPoints: Int
}

type DepositAgreementOutput {
  depositKey: String
  depositAmount: Int
  acceptedAt: DateTime
  fulfilledAt: DateTime
}

"""An enumeration."""
enum PaymentType {
  BPAY
  CARD
  DIRECT_DEBIT
  GMO_REFUND
  PAYMENT_SLIP
}

"""A backend screen is the top-level container for mobile UI."""
union BackendScreenType = ComponentListType

"""A list of components which comprise a screen."""
type ComponentListType implements AccessibilityInterface & IdentifiableInterface & BackendScreenInterface {
  """Whether the element is hidden from view."""
  accessibilityHidden: Boolean

  """Accessible description of the element."""
  accessibilityLabel: String

  """Unique identifier of the object."""
  id: ID

  """The name of the object's type."""
  typename: String

  """The name of the screen."""
  name: String!

  """The minimum client version required to render the screen."""
  requiresVersion: Int!

  """The refresh / polling frequency in milliseconds."""
  refreshFrequency: Int

  """Serialized JSON representation of the screen."""
  screenData: String

  """The list of components."""
  items: [ItemType]!
}

"""Properties relating to the accessibility of features."""
interface AccessibilityInterface {
  """Whether the element is hidden from view."""
  accessibilityHidden: Boolean

  """Accessible description of the element."""
  accessibilityLabel: String
}

"""The identity of an object."""
interface IdentifiableInterface {
  """Unique identifier of the object."""
  id: ID

  """The name of the object's type."""
  typename: String
}

"""A backend screen is the top-level container for mobile UI."""
interface BackendScreenInterface {
  """The name of the screen."""
  name: String!

  """The minimum client version required to render the screen."""
  requiresVersion: Int!

  """The refresh / polling frequency in milliseconds."""
  refreshFrequency: Int

  """Serialized JSON representation of the screen."""
  screenData: String
}

"""
Items are sections making up a screen. They can be different types, hence Union.
"""
union ItemType = TextType | ImageType | AnimationType | RectangularButtonType | PillButtonType | CardComponentType

"""A block of text."""
type TextType implements TextInterface & AccessibilityInterface & IdentifiableInterface {
  """The text content."""
  value: String!

  """The text style, i.e. header, body."""
  textStyle: TextStyle

  """The text alignment."""
  textAlignment: Alignment

  """Whether the element is hidden from view."""
  accessibilityHidden: Boolean

  """Accessible description of the element."""
  accessibilityLabel: String

  """Unique identifier of the object."""
  id: ID

  """The name of the object's type."""
  typename: String
}

interface TextInterface {
  """The text content."""
  value: String!

  """The text style, i.e. header, body."""
  textStyle: TextStyle

  """The text alignment."""
  textAlignment: Alignment
}

"""
The style is the typographical hierarchy.
These are Typescale Categories from the Mobile Design System (Figma).
"""
enum TextStyle {
  TITLE1
  TITLE2
  TITLE3
  TITLE4
  TITLE5
  TITLE6
  BODY1
  BODY2
  BUTTON_TEXT
  CALLOUT1
  CALLOUT2
  CALLOUT3
  SMALL1
  SMALL2
  SMALL3
  INPUT_TITLE
  TABULAR
}

enum Alignment {
  START
  CENTER
  END
}

"""A media element containing an image."""
type ImageType implements SizedItemInterface & MediaInterface & AccessibilityInterface & IdentifiableInterface {
  """The measurement of the element."""
  width: ItemSizeType

  """The resource URL of the media."""
  mediaUrl: String!

  """The horizontal alignment of the media."""
  horizontalAlignment: Alignment

  """Whether the element is hidden from view."""
  accessibilityHidden: Boolean

  """Accessible description of the element."""
  accessibilityLabel: String

  """Unique identifier of the object."""
  id: ID

  """The name of the object's type."""
  typename: String
}

"""Sizes for elements."""
interface SizedItemInterface {
  """The measurement of the element."""
  width: ItemSizeType
}

union ItemSizeType = FractionSizeType | PointsSizeType

"""A fractional measurement."""
type FractionSizeType implements IdentifiableInterface {
  """Unique identifier of the object."""
  id: ID

  """The name of the object's type."""
  typename: String

  """The fractional value."""
  fraction: Decimal!
}

"""A measurement in points."""
type PointsSizeType implements IdentifiableInterface {
  """Unique identifier of the object."""
  id: ID

  """The name of the object's type."""
  typename: String

  """The points value."""
  points: Int!
}

"""The media interface."""
interface MediaInterface {
  """The resource URL of the media."""
  mediaUrl: String!

  """The horizontal alignment of the media."""
  horizontalAlignment: Alignment
}

"""A media element containing an animation, such as a Lottie."""
type AnimationType implements SizedItemInterface & MediaInterface & AccessibilityInterface & IdentifiableInterface {
  """The measurement of the element."""
  width: ItemSizeType

  """The resource URL of the media."""
  mediaUrl: String!

  """The horizontal alignment of the media."""
  horizontalAlignment: Alignment

  """Whether the element is hidden from view."""
  accessibilityHidden: Boolean

  """Accessible description of the element."""
  accessibilityLabel: String

  """Unique identifier of the object."""
  id: ID

  """The name of the object's type."""
  typename: String
}

type RectangularButtonType implements ButtonInterface & IdentifiableInterface {
  """The button style."""
  buttonStyle: ButtonStyle

  """Title text of the button."""
  title: String!

  """The action to perform when the button is pressed."""
  buttonAction: ActionType!

  """Unique identifier of the object."""
  id: ID

  """The name of the object's type."""
  typename: String

  """Colour style of button eg. filled, outlined, text_only."""
  variant: ButtonVariance
}

"""The button interface."""
interface ButtonInterface {
  """The button style."""
  buttonStyle: ButtonStyle

  """Title text of the button."""
  title: String!

  """The action to perform when the button is pressed."""
  buttonAction: ActionType!
}

enum ButtonStyle {
  PRIMARY
  SECONDARY
  TERTIARY
}

"""
Actions are things to do upon a user interaction, such as tapping a button.
"""
union ActionType = DeeplinkActionType | LinkActionType | BackendScreenEventActionType | CloseActionType | ScreenActionType

"""An action which navigates to the URL of another backend screen."""
type DeeplinkActionType implements ActionInterface & IdentifiableInterface {
  """The name of the action object's type."""
  typeName: String

  """Unique identifier of the object."""
  id: ID

  """The name of the object's type."""
  typename: String

  """The URL to navigate to."""
  url: String!
}

"""Actions are events created by buttons and other interaction."""
interface ActionInterface {
  """The name of the action object's type."""
  typeName: String
}

"""An action which navigates to any URL."""
type LinkActionType implements ActionInterface & IdentifiableInterface {
  """The name of the action object's type."""
  typeName: String

  """Unique identifier of the object."""
  id: ID

  """The name of the object's type."""
  typename: String

  """The URL to navigate to."""
  url: String!
}

"""An action which triggers some event in the Kraken backend."""
type BackendScreenEventActionType implements ActionInterface & IdentifiableInterface {
  """The name of the action object's type."""
  typeName: String

  """Unique identifier of the object."""
  id: ID

  """The name of the object's type."""
  typename: String

  """The ID of the event to trigger."""
  eventId: String!

  """List of key-value pairs to pass as parameters to the event."""
  params: [BackendScreenParam]!
}

"""
A key-value pair (both Strings) which is passed as a parameter to a screen.
"""
type BackendScreenParam {
  key: String!
  value: String!
}

"""Closes the screen."""
type CloseActionType implements ActionInterface & IdentifiableInterface & AccessibilityInterface {
  """The name of the action object's type."""
  typeName: String

  """Unique identifier of the object."""
  id: ID

  """The name of the object's type."""
  typename: String

  """Whether the element is hidden from view."""
  accessibilityHidden: Boolean

  """Accessible description of the element."""
  accessibilityLabel: String
}

"""An action which calls another backend screen via its screen id."""
type ScreenActionType implements IdentifiableInterface & ActionInterface {
  """Unique identifier of the object."""
  id: ID

  """The name of the object's type."""
  typename: String

  """The name of the action object's type."""
  typeName: String

  """The ID of the screen to navigate to."""
  screenId: String!

  """
  Map of the parameters (key-value pairs) to pass to the next backend screen.
  """
  params: [BackendScreenParam]!

  """Whether to allow returning to the original caller screen."""
  allowBack: Boolean!
}

enum ButtonVariance {
  FILLED
  OUTLINED
  TEXT_ONLY
}

type PillButtonType implements ButtonInterface & IdentifiableInterface {
  """The button style."""
  buttonStyle: ButtonStyle

  """Title text of the button."""
  title: String!

  """The action to perform when the button is pressed."""
  buttonAction: ActionType!

  """Unique identifier of the object."""
  id: ID

  """The name of the object's type."""
  typename: String
}

"""A card containing a list of items"""
type CardComponentType implements AccessibilityInterface & IdentifiableInterface {
  """Whether the element is hidden from view."""
  accessibilityHidden: Boolean

  """Accessible description of the element."""
  accessibilityLabel: String

  """Unique identifier of the object."""
  id: ID

  """The name of the object's type."""
  typename: String

  """The list of components."""
  items: [CardItemType]!
}

"""Items are sections making up a card."""
union CardItemType = TextType | ImageType | AnimationType | RectangularButtonType | PillButtonType

"""
A key-value pair (both Strings) which is passed in parameters to a backend action.
"""
input BackendScreenParamInputType {
  key: String!
  value: String!
}

type GoodsQuote {
  """ID of the quote."""
  id: Int

  """Code of the quote."""
  code: String

  """Total net amount of the quote in cents."""
  totalNetAmount: Int

  """Date and time when the quote was created."""
  quotedAt: DateTime

  """Products of this quote."""
  goodsQuotedProducts: [GoodsQuotedProduct]

  """Indicates whether or not the quote is expired."""
  hasQuoteExpired: Boolean
}

type GoodsQuotedProduct {
  """Product code."""
  product: String

  """Number of units."""
  numberOfUnits: Int

  """Price per unit."""
  pricePerUnit: Int

  """Net amount."""
  netAmount: Int

  """Currency."""
  currency: String
}

type GoodsProductConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [GoodsProductConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""A Relay edge containing a `GoodsProductConnectionType` and its cursor."""
type GoodsProductConnectionTypeEdge {
  """The item at the end of the edge"""
  node: GoodsProduct

  """A cursor for use in pagination"""
  cursor: String!
}

type GoodsProduct {
  """Product ID."""
  id: Int

  """Market of the product."""
  marketName: String

  """Type of the product."""
  productType: String

  """Product code."""
  code: String

  """Product internal name."""
  internalName: String

  """Product customer name."""
  customerName: String

  """Product notes."""
  notes: String

  """Product description."""
  description: String

  """Product available from."""
  availableFrom: Date

  """Product available to."""
  availableTo: Date

  """Price per unit."""
  pricePerUnit: Float

  """Currency."""
  currency: String
}

type GoodsPurchase {
  """Purchase code."""
  code: String

  """Ledger ID associated to the purchase."""
  ledgerId: String

  """Sale items in this purchase."""
  goodsSaleItems: [GoodsSaleItem]

  """Grants that apply in this purchase."""
  goodsGrants: [GoodsGrant]

  """Market parameters of the purchase."""
  marketParams: JSONString

  """Client parameters of the purchase."""
  clientParams: JSONString
}

type GoodsSaleItem {
  """Product code."""
  product: String

  """Number of units."""
  numberOfUnits: Int

  """Price per unit."""
  pricePerUnit: Float

  """Net amount."""
  netAmount: Float

  """Currency."""
  currency: String
}

type GoodsGrant {
  """Grant type."""
  type: String

  """Net amount."""
  netAmount: Float

  """Currency."""
  currency: String
}

"""
Energy mix data can include the latest carbon intensity index in a region.
"""
type EnergyMixDataType {
  """Current carbon intensity index."""
  carbonIntensityIndex: String
}

"""Paginator of API exceptions."""
type APIExceptionConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [APIExceptionConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""A Relay edge containing a `APIExceptionConnectionType` and its cursor."""
type APIExceptionConnectionTypeEdge {
  """The item at the end of the edge"""
  node: APIExceptionType

  """A cursor for use in pagination"""
  cursor: String!
}

type APIExceptionType {
  id: ID!

  """
  External identifier submitted by the API client to track this exception on their end.
  """
  externalIdentifier: String!
  createdAt: DateTime!

  """Storage for the API client to submit any contextual information."""
  context: JSONString

  """
  Free field for the API caller to categorise a channel. This could be (but not limited to) the client's team that calleded the API, the name of the 'flow' the call belongs to, etc.
  """
  channel: String!

  """Category associated with this exception."""
  category: APIExceptionCategories

  """The account number provided to the exception."""
  accountNumber: String

  """The user id provided to the exception."""
  userId: Int

  """The customer contact provided to the exception."""
  customerContact: String

  """The supply point identifier provided to the exception."""
  supplyPointIdentifier: String

  """The current resolution status for the API exception."""
  resolutionStatus: APIExceptionResolutionStatus!

  """The current resolution type for the API exception."""
  resolutionType: APIExceptionResolutionType!

  """The current priority for the API exception."""
  priority: APIExceptionPriority!

  """The API calls associated with this exception if any."""
  apiCalls: [APICallType]

  """The events associated with this exception if any."""
  events: [APIExceptionEventType]

  """Tags associated with this exception if any."""
  tags: [APIExceptionTags]

  """Notes associated with this exception if any."""
  notes: [APIExceptionNoteType]

  """The operations team assigned to this exception if any."""
  operationsTeam: OperationsTeamType
}

"""An enumeration."""
enum APIExceptionCategories {
  ACCOUNT
  UNKNOWN
}

"""An enumeration."""
enum APIExceptionResolutionStatus {
  ASSIGNED
  CANCELLED
  IN_PROGRESS
  RESOLVED
  UNASSIGNED
  UNSUCCESSFUL
}

"""An enumeration."""
enum APIExceptionResolutionType {
  AUTOMATIC
  MANUAL
  UNASSIGNED
}

"""An enumeration."""
enum APIExceptionPriority {
  LOW
  MEDIUM
  HIGH
}

type APICallType {
  id: ID!

  """The request's correlation id."""
  correlationId: String!

  """
  Free field for the API caller to categorise their own operation name. This field can be used to filter entries on the UI.
  """
  operationName: String!

  """Input data for the API call if any."""
  inputData: JSONString

  """The response from the API call if any."""
  response: JSONString

  """Storage for the API client to submit any contextual information."""
  context: JSONString
  createdAt: DateTime!
}

type APIExceptionEventType {
  id: ID!

  """The type of the event."""
  eventType: String!

  """The category of the event."""
  category: String!

  """A description of the event."""
  description: String

  """A JSON context to be provided with the event, if any."""
  context: JSONString
  createdAt: DateTime!
}

"""An enumeration."""
enum APIExceptionTags {
  MOVE_IN
  MOVE_OUT
  PRODUCT_UPDATE
}

type APIExceptionNoteType {
  """The ID of the API Exception note."""
  id: ID!

  """The content of the API Exception note."""
  body: String!

  """Timestamp of when the API Exception note was created."""
  createdAt: DateTime!
}

input APIExceptionQueryInput {
  """The external identifier to filter for."""
  externalIdentifier: String

  """The resolution status to filter for."""
  resolutionStatus: APIExceptionResolutionStatus = null

  """The resolution type to filter for."""
  resolutionType: APIExceptionResolutionType = null

  """The channel to filter for."""
  channel: String

  """The priority to filter for."""
  priority: APIExceptionPriority = null

  """Tags to filter for."""
  tags: [APIExceptionTags]

  """The category to filter for."""
  category: APIExceptionCategories = null

  """The account number to filter for."""
  accountNumber: ID

  """The user ID to filter for."""
  userId: ID

  """The customer contact to filter for."""
  customerContact: String

  """The supply point identifier to filter for."""
  supplyPointIdentifier: ID
}

type CreditReasonType {
  """The credit reason code."""
  code: String

  """The credit reason display text."""
  display: String

  """Whether the credit reason is deprecated."""
  isDeprecated: Boolean

  """Whether the credit reason is sales tax exempt."""
  isTaxExempt: Boolean

  """Whether the credit reason is hidden."""
  isHidden: Boolean

  """The group the credit reason belongs to (if applicable)."""
  group: String
}

type ChargeReasonType {
  """The charge reason code."""
  code: String

  """The charge reason display text."""
  display: String

  """Whether the charge reason is deprecated."""
  isDeprecated: Boolean

  """Whether the charge reason is sales tax exempt."""
  isTaxExempt: Boolean

  """Whether the charge reason is hidden."""
  isHidden: Boolean

  """The group the charge reason belongs to (if applicable)."""
  group: String
}

"""A single accout search hit"""
type AccountSearchItemType {
  """The account found."""
  account: AccountType

  """How well the account matched the search terms."""
  score: Decimal
}

input AccountSearchInputType {
  """The account number eg. A-FF15AE70."""
  accountNumber: String

  """The portfolio number eg. P-A123B456."""
  portfolioNumber: String

  """URN Number."""
  urn: String

  """The Account User ID (not account number)."""
  user: String

  """Internal account id (not account number)."""
  account: String

  """Statements."""
  statements: String

  """Meter Serial Number."""
  meterSerialNumber: String

  """Location (Supply or Billing, full or partial, address or post code)."""
  location: String

  """Account or Billing name."""
  billingName: String

  """Business name."""
  businessName: String

  """Business identifier or number."""
  businessNumber: String

  """Account Reference."""
  accountReferences: String

  """MPAN of property."""
  mpan: String

  """MPRN of property."""
  mprn: String

  """Telephone."""
  telephoneNumber: String
}

type SignUp {
  """Boolean indicating if the sign up was successful."""
  success: Boolean!
}

input SignUpInput {
  """Kraken account number."""
  accountNumber: String!

  """The target start date for the products."""
  targetStartDate: Date!

  """The list of products to sign up against the supplied account."""
  products: [ProductsInput]!
}

input ProductsInput {
  """The product code."""
  code: String!

  """
  Market specific context required to sign up the account to the product(s).
  """
  context: SupplyInput!
}

input SupplyInput {
  """Sign up context for GBR gas enrollments."""
  gbrGas: GasSupplyInput = null

  """Sign up context for GBR electricity enrollments."""
  gbrElectricity: ElectricitySupplyInput = null
}

input GasSupplyInput {
  """The MPRN of the supply point."""
  mprn: String

  """String that maps to a defined RegistrationType object."""
  registrationType: String
}

input ElectricitySupplyInput {
  """The MPAN of the supply point."""
  mpan: String

  """String that maps to a defined RegistrationType object."""
  registrationType: String
}

"Publish a trigger within the transactional messaging service.\n\nThe possible errors that can be raised are:\n\n- KT-CT-9901: Invalid trigger type code.\n- KT-CT-9902: Invalid trigger type params.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type PublishTransactionalMessagingTrigger {
  possibleErrors: [PossibleErrorType]

  """The trigger that has been published."""
  trigger: TriggerType
}

type TriggerType {
  """The ID of the trigger."""
  id: String!
}

input PublishTransactionalMessagingTriggerInput {
  """The code of the trigger type to be published."""
  triggerTypeCode: String!

  """
  The params of the trigger type, as a JSON string. These are defined in the Params class for a trigger type.
  """
  params: JSONString!
}

"The possible errors that can be raised are:\n\n- KT-CT-4123: Unauthorized.\n- KT-CT-9601: Invalid data.\n- KT-CT-9602: Unable to create contribution agreement.\n- KT-CT-9605: Contribution amount cannot be 0 or negative.\n- KT-CT-9606: Scheme is not accepting contributions at this time.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateContributionAgreement {
  possibleErrors: [PossibleErrorType]

  """The created contribution agreement."""
  contributionAgreement: ContributionAgreementType
}

input CreateContributionAgreementInput {
  """The account number."""
  accountNumber: String!

  """The code of the scheme to contribute to."""
  schemeCode: String!

  """The frequency of contributions."""
  interval: Interval!

  """
  The amount contributed per interval. Note, this is in the smallest domination that the currency supports. e.g. Pence, Cents, Yen, etc.
  """
  amount: Int!

  """The start datetime of the agreement."""
  activeFrom: DateTime!

  """The end datetime of the agreement, if any."""
  activeTo: DateTime
}

"The possible errors that can be raised are:\n\n- KT-CT-9603: Unable to find contribution agreement.\n- KT-CT-4123: Unauthorized.\n- KT-CT-9604: Unable to end contribution agreement.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type EndContributionAgreement {
  possibleErrors: [PossibleErrorType]

  """The created contribution agreement."""
  contributionAgreement: ContributionAgreementType
}

input EndContributionAgreementInput {
  """The ID of the Contribution Agreement to end."""
  contributionAgreementId: ID!

  """The future end datetime of the agreement. If not given, terminate now."""
  endAt: DateTime
}

"Redeem Loyalty Points as account credit.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4178: No account found with given account number.\n- KT-CT-9201: No Loyalty Point ledger found for the user.\n- KT-CT-9202: Loyalty Points adapter not configured.\n- KT-CT-9203: No ledger entries for the ledger.\n- KT-CT-9205: Insufficient Loyalty Points.\n- KT-CT-9206: Indivisible points.\n- KT-CT-9204: Negative or zero points set.\n- KT-CT-9208: Invalid posted at datetime.\n- KT-CT-9209: Negative Loyalty Points balance.\n- KT-CT-9210: Unhandled Loyalty Points exception.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
type RedeemLoyaltyPointsForAccountCredit {
  possibleErrors: [PossibleErrorType]

  """The number of OctoPoints that were redeemed."""
  pointsRedeemed: Int
}

"""The input type for redeeming Loyalty Points."""
input RedeemLoyaltyPointsInput {
  """The account number."""
  accountNumber: String!

  """The number of Loyalty Points to redeem."""
  points: Int!
}

"Transfer Loyalty Points between users.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1111: Unauthorized.\n- KT-CT-4181: The user is not associated with the account.\n- KT-CT-9205: Insufficient Loyalty Points.\n- KT-CT-9204: Negative or zero points set.\n- KT-CT-9208: Invalid posted at datetime.\n- KT-CT-9209: Negative Loyalty Points balance.\n- KT-CT-9210: Unhandled Loyalty Points exception.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
type TransferLoyaltyPointsBetweenUsers {
  possibleErrors: [PossibleErrorType]

  """The number of OctoPoints that were transferred."""
  pointsTransferred: Int
}

"""The input type for transferring Loyalty Points."""
input TransferLoyaltyPointsBetweenUsersInput {
  """The account number."""
  accountNumber: String!

  """The account user receiving the points."""
  receivingUserId: String!

  """The number of Loyalty Points to transfer."""
  points: Int!
}

"Set the Loyalty Points user for the account.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1111: Unauthorized.\n- KT-CT-4181: The user is not associated with the account.\n- KT-CT-9210: Unhandled Loyalty Points exception.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
type SetLoyaltyPointsUser {
  possibleErrors: [PossibleErrorType]

  """ID of the new Loyalty Points user."""
  newLoyaltyPointsUserId: String
}

"""The input type for setting the Loyalty Points user."""
input SetLoyaltyPointsUserInput {
  """The account number."""
  accountNumber: String!

  """The account user receiving the points."""
  newLoyaltyPointsUserId: String!
}

"Use a referral code to create a referral and trigger a referral reward.\n\nThe possible errors that can be raised are:\n\n- KT-CT-6723: Unauthorized.\n- KT-CT-6710: Unable to create referral.\n- KT-CT-6711: Accounts may not self-refer.\n- KT-CT-6713: Referring and referred account brands do not match.\n- KT-CT-6712: Invalid reference.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateReferral {
  possibleErrors: [PossibleErrorType]

  """
  The reward amount to be issued to the referred account, in smallest currency subunits.
  """
  referredAccountRewardAmount: Int
}

"""Required information for creating a referral"""
input CreateReferralInput {
  """The account number for the referred account."""
  accountNumber: String!

  """An email address, link or code, referencing the referring account."""
  reference: String!
}

"Create a new portfolio.\n\nThe possible errors that can be raised are:\n\n- KT-CT-9402: Received an invalid brandCode.\n- KT-CT-9401: Received an invalid operationsTeamId.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreatePortfolio {
  possibleErrors: [PossibleErrorType]

  """The created portfolio."""
  portfolio: PortfolioType
}

input CreatePortfolioInput {
  """
  The brand to associate with this portfolio, if not provided the default brand will be used.
  """
  brandCode: String = "EON_NEXT"

  """
  The ID of the operations team to associate with this portfolio.If no team is provided, no team will be assigned to the portfolio.
  """
  operationsTeamId: ID

  """
  Whether collective bills should be issued for the portfolio's accounts. The default value is False.
  """
  collectiveBilling: Boolean = false
}

"Close the Open Print Batch if any.\n\nThe possible errors that can be raised are:\n\n- KT-CT-9010: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CloseOpenPrintBatch {
  possibleErrors: [PossibleErrorType]
  printBatch: PrintBatchType
}

"Mark a closed print batch as Processed\n\nThe possible errors that can be raised are:\n\n- KT-CT-9011: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type MarkPrintBatchAsProcessed {
  possibleErrors: [PossibleErrorType]
  printBatch: PrintBatchType
}

"Create a Loyalty Card for the given account user.\n\nThe possible errors that can be raised are:\n\n- KT-CT-5412: No account user exists with the given id.\n- KT-CT-8610: Invalid data.\n- KT-CT-8611: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateOrUpdateLoyaltyCardMutation {
  possibleErrors: [PossibleErrorType]

  """Created or updated loyalty card."""
  loyaltyCard: LoyaltyCardType
}

input CreateOrUpdateLoyaltyCardInput {
  """The id of the account user."""
  accountUserId: String

  """The scheme of the loyalty card."""
  scheme: String

  """The number of the loyalty card."""
  number: String
}

union LinkUserToLineResponse = LineLinkRedirectResponse | LinkTokenNotFound | AlreadyLinkedError

"""Link Successful. Complete link process with LINE."""
type LineLinkRedirectResponse {
  redirectUrl: String!
}

"""
Returned when no LineAccountLink record matching the parameters exists.
"""
type LinkTokenNotFound {
  """The type of error that occurred."""
  type: LineLinkErrorType!
}

enum LineLinkErrorType {
  NO_MATCHING_LINE_LINK
  ALREADY_LINKED
}

"""Returned when an account already has a LINE account linked to it."""
type AlreadyLinkedError {
  """The type of error that occurred."""
  type: LineLinkErrorType!
}

"""Link an AccountUser to a LINE account."""
input LinkUserToLineInput {
  linkToken: String!
}

union UnlinkUserFromLineResponse = LineUnlinkedResponse | LinkTokenNotFound | LineCommonError

type LineUnlinkedResponse {
  message: String!
}

"""
A base error type. Should be used for general application or lower level errors.
"""
type LineCommonError {
  """The error message to display to the user."""
  message: String!

  """The field that for which this error should be associated"""
  field: String
}

"Create an affiliate link for a new sales agent.\n\nThe possible errors that can be raised are:\n\n- KT-CT-7711: Invalid data.\n- KT-CT-7713: Invalid data.\n- KT-CT-7714: Invalid data.\n- KT-CT-7715: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateAffiliateLink {
  possibleErrors: [PossibleErrorType]
  affiliateLink: AffiliateLinkType
}

input CreateAffiliateLinkInputType {
  """The organisation for whom to create the affiliate link for."""
  organisationId: ID!

  "\nWill be validated as follows:\n\n- should be at least two characters\n- should only contain (letters, numbers, and Hyphen)\n- should not contain bad words\n- should not contain any of the reserved words including:\n affiliates, api, business, click, consul, developer, friends, kraken, mail, sendgrid, tech, webhooks, www, www2"
  subdomain: String!
  contactName: String!
  contactEmail: String!
}

"Update an affiliate link of an existing sales agent.\n\nThe possible errors that can be raised are:\n\n- KT-CT-7711: Invalid data.\n- KT-CT-7713: Invalid data.\n- KT-CT-7714: Invalid data.\n- KT-CT-7715: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type UpdateAffiliateLink {
  possibleErrors: [PossibleErrorType]
  affiliateLink: AffiliateLinkType
}

input UpdateAffiliateLinkInputType {
  """The id of the affiliate link that is going to be edited."""
  linkId: ID!

  """The organisation for whom to update the affiliate link for."""
  organisationId: ID

  "\nWill be validated as follows:\n\n- should be at least two characters\n- should only contain (letters, numbers, and Hyphen)\n- should not contain bad words\n- should not contain any of the reserved words including:\n affiliates, api, business, click, consul, developer, friends, kraken, mail, sendgrid, tech, webhooks, www, www2"
  subdomain: String
  contactName: String
  contactEmail: String
  isBusiness: Boolean
  landingUrl: String
  trainingStatus: String
}

"Create an affiliate organisation.\n\nThe possible errors that can be raised are:\n\n- KT-CT-7716: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateAffiliateOrganisation {
  possibleErrors: [PossibleErrorType]
  affiliateOrganisation: AffiliateOrganisationType
}

input CreateAffiliateOrganisationInputType {
  name: String!

  """Sales Channel"""
  salesChannel: SalesChannelChoices!

  """Default Account Type"""
  defaultAccountType: AccountTypeChoices!

  """
  Are meter point registrations limited for profile classes 1 and 2 for registrations from csv or API
  """
  canRegisterBusinessMeterPoints: Boolean

  """
  Allow registration requests with exiting account user emails to add to the portfolio belonging to the account user.
  """
  canRegisterPortfolioAccounts: Boolean

  """Allow registration requests with customers without an email address."""
  canRegisterCustomersWithoutEmailAddress: Boolean

  """
  Allow this partner to skip validation that ensures all meter points belong to the same address
  """
  skipMeterPointAddressValidation: Boolean

  """
  Is this partner allowed to specify payment methods other than Direct Debit in the import csv or API
  """
  allowAlternativePaymentMethods: Boolean

  """Allow performing tariff renewals via API."""
  canRenewTariffs: Boolean

  """
  Allow this partner access to the IVR support API (modify their own IVR handling through third party 'IVR Flow Editor')
  """
  canUseIvrSupportApi: Boolean

  """
  Restrict to field-sales-only products? This is only allowed for the 'field-sales' and 'events' sales channels
  """
  isFieldSalesOnlyProduct: Boolean
}

"Update an affiliate organisation.\n\nThe possible errors that can be raised are:\n\n- KT-CT-7717: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type UpdateAffiliateOrganisation {
  possibleErrors: [PossibleErrorType]
  affiliateOrganisation: AffiliateOrganisationType
}

input UpdateAffiliateOrganisationInputType {
  """The organisation that is going to be edited."""
  organisationId: ID!
  name: String

  """Sales Channel"""
  salesChannel: SalesChannelChoices = null

  """Default Account Type"""
  defaultAccountType: AccountTypeChoices = null

  """
  Are meter point registrations limited for profile classes 1 and 2 for registrations from csv or API
  """
  canRegisterBusinessMeterPoints: Boolean

  """
  Allow registration requests with exiting account user emails to add to the portfolio belonging to the account user.
  """
  canRegisterPortfolioAccounts: Boolean

  """Allow registration requests with customers without an email address."""
  canRegisterCustomersWithoutEmailAddress: Boolean

  """
  Allow this partner to skip validation that ensures all meter points belong to the same address
  """
  skipMeterPointAddressValidation: Boolean

  """
  Is this partner allowed to specify payment methods other than Direct Debit in the import csv or API
  """
  allowAlternativePaymentMethods: Boolean

  """Allow performing tariff renewals via API."""
  canRenewTariffs: Boolean

  """
  Allow this partner access to the IVR support API (modify their own IVR handling through third party 'IVR Flow Editor')
  """
  canUseIvrSupportApi: Boolean

  """
  Restrict to field-sales-only products? This is only allowed for the 'field-sales' and 'events' sales channels
  """
  isFieldSalesOnlyProduct: Boolean
}

"""Create a session for an affiliate link."""
type CreateAffiliateSession {
  affiliateSession: AffiliateSessionType
}

"""A tracked session for the affiliate link."""
type AffiliateSessionType {
  id: ID!
  ipAddress: String
  userAgent: String!
  queryParams: JSONString!
  link: AffiliateLinkType
}

input CreateAffiliateSessionInputType {
  """The affiliate link for whom to create the session for."""
  linkId: ID!

  """The IP Address of the user."""
  ipAddress: String

  """The HTTP user agent."""
  userAgent: String

  """Additional query parameters to attach to this session."""
  queryParams: JSONString

  """The quote share that led to this session."""
  quoteShareId: ID
}

"""Validate whether a user's email is a valid email via the Kickbox API."""
type ValidateEmail {
  """Whether the email is valid or not."""
  isValid: Boolean
}

"""Input required to validate email address via Kickbox"""
input ValidateEmailInput {
  """The user's email address."""
  email: String!
}

"""Validate whether a user's phone number is a valid phone number."""
type ValidatePhone {
  """Whether the phone number is valid or not."""
  isValid: Boolean
}

input ValidatePhoneNumberInput {
  """The user's phone number."""
  phoneNumber: String!
}

"Returns an Action to perform, e.g. a screen to load.\n\nBackendScreenEvents are specific types of Action which trigger a mutation in the Kraken backend.\nThey return an action (any type), such as a ScreenActionType (which is then used to load the next screen).\nAny action registered in the registry should really be an \"event\" with some side-effect in the backend.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1111: Unauthorized.\n- KT-CT-8002: No event found.\n- KT-CT-8003: Event has no execute function.\n- KT-CT-8004: Error executing event in the backend.\n- KT-CT-8007: Incorrect or missing parameters for backend screen event.\n- KT-GB-9310: Account ineligible for joining Octoplus.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
type BackendScreenEvent {
  possibleErrors: [PossibleErrorType]

  """An action to perform."""
  action: ActionType
}

"""Input for a backend action."""
input BackendScreenEventInput {
  """The ID of the action to perform."""
  eventId: ID!

  """
  List of key-value pairs (strings) to pass as parameters to the mutation.
  """
  params: [BackendScreenParamInputType]
}

"The possible errors that can be raised are:\n\n- KT-CT-5514: Unable to submit feedback.\n- KT-CT-5511: The feedback_id should be provided for feedback source.\n- KT-CT-5512: The feedback doesn't match the account.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type SubmitCustomerFeedback {
  possibleErrors: [PossibleErrorType]
  customerFeedback: CustomerFeedbackType
}

type CustomerFeedbackType {
  id: ID!

  """The value attached to the source"""
  rawScore: Int

  """The datetime the feedback was submitted"""
  submittedAt: DateTime
}

input CustomerFeedbackInputType {
  answer: String
  issueResolved: Boolean!
  formId: Int!
  feedbackId: Int!
  accountNumber: String!
}

"Mutation for executing the repayment request use case.\n\nThe possible errors that can be raised are:\n\n- KT-CT-3927: Invalid Amount.\n- KT-CT-3928: Idempotency key used for another repayment request.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
type SubmitRepaymentRequest {
  possibleErrors: [PossibleErrorType]

  """The newly created repayment request."""
  repaymentRequest: RequestRepaymentOutputType
}

"""Output for creating a repayment request."""
type RequestRepaymentOutputType {
  """The ID of the repayment request."""
  requestId: String

  """The current status of the repayment request."""
  status: RepaymentRequestStatus
}

input RequestRepaymentInputType {
  """The account number for the requested ledger's account."""
  accountNumber: String!

  """The ledger id from which the repayment will be requested."""
  ledgerId: String!

  """The amount to be repaid."""
  amountInMinorUnit: Int!

  """The method by which the money will be transferred to the customer."""
  method: RequestableRepaymentMethod = null

  """Unique constraint to prevent duplicate requests."""
  idempotencyKey: String!
}

"""An enumeration."""
enum RequestableRepaymentMethod {
  BANK_TRANSFER
  CHEQUE
}

"Cancel a repayment or refund request.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4231: Unauthorized.\n- KT-CT-3930: The repayment or refund request does not exist.\n- KT-CT-3931: This repayment or refund request cannot be cancelled.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
type CancelRepaymentRequest {
  possibleErrors: [PossibleErrorType]

  """The cancelled repayment/refund request."""
  repaymentRequest: CancelRepaymentRequestOutputType
}

"""Output from cancelling a repayment or refund request."""
type CancelRepaymentRequestOutputType {
  """The ID of the cancelled request."""
  requestId: String

  """The current status of the cancelled request."""
  status: RepaymentRequestStatus
}

input CancelRepaymentRequestInputType {
  """The id of the request to be cancelled."""
  requestId: String!
}

"Allow a repayment to be submitted.\n\nThe possible errors that can be raised are:\n\n- KT-CT-3944: Account repayment does not exist.\n- KT-CT-3945: Unable to allow a repayment to be submitted.\n- KT-CT-3950: The provided reason text is too long.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type AllowRepaymentSubmission {
  possibleErrors: [PossibleErrorType]

  """The repayment ID."""
  repaymentId: ID

  """Resulting Repayment Intervention details."""
  repaymentIntervention: RepaymentInterventionType
}

type RepaymentInterventionType {
  """The repayment intervention outcome."""
  outcome: String

  """The repayment intervention reason."""
  reason: String
}

"""Input fields for Repayment Intervention."""
input RepaymentInput {
  """The repayment ID."""
  repaymentId: ID!

  """The Repayment Intervention reason."""
  reason: String
}

"Block a repayment from being submitted.\n\nThe possible errors that can be raised are:\n\n- KT-CT-3944: Account repayment does not exist.\n- KT-CT-3946: Unable to block a repayment from being submitted.\n- KT-CT-3950: The provided reason text is too long.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type BlockRepaymentSubmission {
  possibleErrors: [PossibleErrorType]

  """The repayment ID."""
  repaymentId: ID

  """Resulting Repayment Intervention details."""
  repaymentIntervention: RepaymentInterventionType
}

"Collect deposit for the given account.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4177: Unauthorized.\n- KT-CT-5711: No collection is required.\n- KT-CT-5712: Deposit agreement does not exist or has not been accepted.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CollectDeposit {
  possibleErrors: [PossibleErrorType]
  payment: CollectDepositOutput
}

type CollectDepositOutput {
  status: CollectDepositStatusChoices
  paymentDate: Date
}

enum CollectDepositStatusChoices {
  APPROVED
  CLEARED
  CANCELLED
  HELD_FOR_REVIEW
  FAILED
  PENDING
  REQUESTED
  SCHEDULED
  NONE
}

input CollectDepositInput {
  accountNumber: String!
  depositKey: String!
  idempotencyKey: String!
}

"Record the customer's acceptance of a deposit agreement.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4177: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type RecordDepositAgreementAccepted {
  possibleErrors: [PossibleErrorType]
  isRecorded: Boolean
}

input DepositAgreementInput {
  accountNumber: String!
  depositKey: String!
}

"Create a new deposit agreement for the account if it needs one.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4177: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateDepositAgreement {
  possibleErrors: [PossibleErrorType]
  depositAgreement: CreateDepositAgreementOutput
}

type CreateDepositAgreementOutput {
  depositRequired: Boolean
  depositAmount: Int
}

input CreateDepositAgreementInput {
  accountNumber: String!
  depositKey: String!
  reason: String!
}

"Initiate a standalone payment and return the client secret required to complete it.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4177: Unauthorized.\n- KT-CT-3943: Invalid ledger.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type InitiateStandalonePayment {
  possibleErrors: [PossibleErrorType]
  payment: InitiateStandalonePaymentOutput
}

"""Tokens required to collect and retrieve a standalone payment."""
type InitiateStandalonePaymentOutput {
  """The retrieval token for this standalone payment."""
  retrievalToken: String!

  """The secret used to collect the payment."""
  secretToken: String!
}

"""
Input fields for initiating a standalone payment.

The amount should always be provided in the minor unit of currency (e.g., pence not pounds,
cents not dollars, etc.).

A standalone payment can be made against a specific ledger (e.g., a debt ledger) by
providing the ledger id. Accounts have a default ledger that will be used if not provided.
"""
input InitiateStandalonePaymentInput {
  """The account number."""
  accountNumber: String!

  """The amount to be collected in the minor unit of currency."""
  amount: Int!

  """A description of the purpose of the payment."""
  description: String!

  """The method by which the payment is being collected."""
  collectionMethod: CollectionMethod = null

  """
  The id of the specific ledger against which this payment should be applied.
  """
  ledgerId: ID
}

enum CollectionMethod {
  CARD
  DIRECT_DEBIT
}

"Get the client secret needed to create a new payment instruction using an embedded form.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4177: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type GetEmbeddedSecretForNewPaymentInstruction {
  possibleErrors: [PossibleErrorType]
  secretKey: String
}

"""
The input for getting the client secret for an embedded new card payment method form.
"""
input GetEmbeddedSecretForNewPaymentInstructionInput {
  """The account number."""
  accountNumber: String!

  """The type of the new payment instruction."""
  instructionType: PaymentType!

  """
  **WARNING: Will be mandatory in future versions**
  
   The ledger ID.
  """
  ledgerId: String
}

"Store a new payment instruction created through the embedded process.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4177: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type StorePaymentInstruction {
  possibleErrors: [PossibleErrorType]

  """The stored payment instruction."""
  paymentInstruction: PaymentInstructionType
}

"""
The input for storing a new payment instruction created through the embedded process.
"""
input StorePaymentInstructionInput {
  """The account number."""
  accountNumber: String!

  """The type of the new payment instruction."""
  instructionType: PaymentType!

  """The datetime from which the instruction is vaild."""
  validFrom: DateTime!

  """The vendor's reference for this payment method."""
  vendorReference: String!

  """
  **WARNING: Will be mandatory in future versions**
  
   The ledger ID to which the instructions will be linked.
  """
  ledgerId: String
}

"Invalidates a payment instruction.\n\nThe possible errors that can be raised are:\n\n- KT-CT-3926: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type InvalidatePaymentInstruction {
  possibleErrors: [PossibleErrorType]
  instruction: InvalidatePaymentInstructionOutput
}

"""Output for invalidating an arbitrary payment instruction."""
type InvalidatePaymentInstructionOutput {
  id: Int
}

"""Input for invalidating an arbitrary payment instruction."""
input InvalidatePaymentInstructionInput {
  accountNumber: String!

  """The id of the payment instruction to be invalidated."""
  id: String!
}

"The possible errors that can be raised are:\n\n- KT-CT-3940: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type SetUpDirectDebitInstruction {
  possibleErrors: [PossibleErrorType]
  paymentInstruction: DirectDebitInstructionType
}

input SetUpDirectDebitInstructionInput {
  accountNumber: String!
  ledgerId: ID!
  validFrom: DateTime!
  bankDetails: BankDetailsInput!
}

input BankDetailsInput {
  accountHolder: String
  iban: String
  accountNumber: String
  bankCode: String
  branchCode: String
  accountType: String
}

"The possible errors that can be raised are:\n\n- KT-CT-3932: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CollectPayment {
  possibleErrors: [PossibleErrorType]

  """
  Details about the collected payment. Note that we might not be able to collect the payment (e.g. if there is no usable payment instruction), in which case the status of the returned payment might be failed or cancelled.
  """
  payment: AccountPaymentType
}

input CollectPaymentInput {
  """The account number."""
  accountNumber: String!

  """The payment amount (in pence)."""
  amount: Int!

  """
  The date to attempt to take the payment. Cannot be a date in the past. Payment will be collected on the requested date or as soon as possible after that date.
  """
  paymentDate: Date!

  """The reason a payment is being collected, for internal audit purposes"""
  description: String!
  idempotencyKey: String!

  """The type of the payment instruction."""
  collectionMethod: PaymentType = null

  """The ID of the ledger on which to collect the payment."""
  ledgerId: ID!
}

"The possible errors that can be raised are:\n\n- KT-CT-3924: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type AmendPayment {
  possibleErrors: [PossibleErrorType]
  payment: AccountPaymentType
}

input AmendPaymentInput {
  """The account number."""
  accountNumber: String!

  """The ID of the payment to amend."""
  paymentId: Int!

  """The new amount for the amended payment"""
  amount: Int!

  """The new date to collect the payment"""
  paymentDate: Date!

  """Reason for amending the payment."""
  reason: String
}

type AssignInkBucketPayload {
  """The conversation that will be assigned to the bucket."""
  conversation: InkConversation!

  """The bucket that the conversation will be assigned to."""
  bucket: InkBucket!
  clientMutationId: String
}

input AssignInkBucketInput {
  """The relay id of the conversation that will be assigned to the bucket."""
  conversationRelayId: ID!

  """The name of the bucket to assign the conversation to."""
  bucketName: String!
  clientMutationId: String
}

type UpdateMessageTagsPayload {
  """Confirmed tags."""
  tags: [InkTag!]!
  clientMutationId: String
}

input UpdateMessageTagsInput {
  """The message to set the tags on."""
  messageRelayId: ID!

  """The tag names to set on the message."""
  tagNames: [String!]!

  """The tag code to set on the message."""
  taggerCode: String!

  """The tag version to set on the message."""
  taggerVersion: String!
  clientMutationId: String
}

"""Register an Ink inbound message."""
type CreateInkInboundMessagePayload {
  """The Ink message that was created."""
  message: InkMessage!
  clientMutationId: String
}

input CreateInkInboundMessageInput {
  channel: InkCommunicationChannel!

  "\nAn arbitrary, unique ID for this message.\n\nThis must be unique for each message that is supplied\nusing the same organisation; collisions between messages\nprovided by different organisations are tolerated.\n\nStored as vendor_id.\n"
  messageId: String!
  newMessage: InkMessageInput!
  clientMutationId: String
}

"""
An Ink message used as an input.

This is intended to be morally equivalent to a tagged union; exactly
one of the properties provided here is expected to be provided.

At current, only the generic message type is provided, because only
the generic message type is currently supported as an input type.
This is intended to be a backwards-compatible extension point to
allow other message input types to be added in the future.
"""
input InkMessageInput {
  generic: InkGenericMessageInput
  email: InkEmailMessageInput
}

"""This type is used to create an generic message."""
input InkGenericMessageInput {
  """The content of the message, as plain text."""
  plainTextContent: String!

  """Message attachments."""
  attachments: [InkGenericMessageAttachmentInput!]

  """The identity the message was sent from."""
  fromHandle: String!

  """The identity the message was sent to."""
  toHandle: String!
}

input InkGenericMessageAttachmentInput {
  """The S3 key of the attachment."""
  s3Key: String!

  """The S3 bucket of the attachment."""
  s3Bucket: String!
}

"""This type is used to create an inbound email."""
input InkEmailMessageInput {
  """The content of the message, as plain text."""
  plainTextContent: String!

  """Message attachments."""
  attachments: [InkGenericMessageAttachmentInput!]

  """The email subject/title."""
  subject: String!

  """The email address the message was sent from."""
  fromAddress: Email!

  """The email addresses the message was sent to."""
  toAddresses: [Email!]!

  """The carbon copy (cc) email addresses the message was sent to."""
  ccAddresses: [Email!]
}

scalar Email

"The possible errors that can be raised are:\n\n- KT-CT-7620: Channel not supported.\n- KT-CT-7618: Unable to process message.\n- KT-CT-7624: Error when generating the presigned URL.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type GenerateInkPresignedUrl {
  possibleErrors: [PossibleErrorType]

  """A presigned URL for the user to upload to the quarantine bucket."""
  uploadUrl: String!

  """
  Presigned post fields; key, awsAccessKeyId, xAmzSecurityToken, policy, signature.
  """
  presignedPostFields: PresignedPostFields
}

"""Fields returned by generate_presigned_post."""
type PresignedPostFields {
  """The S3 bucket key."""
  key: String!

  """The AWS access key ID."""
  awsAccessKeyId: String!

  """The AMZ security token."""
  xAmzSecurityToken: String!

  """The S3 policy."""
  policy: String!

  """AWS Signature Version 4 Authentication."""
  signature: String!
}

input GenerateInkPresignedUrlInput {
  """The channel of the contact."""
  channel: InkCommunicationChannel!

  """The name of the file."""
  filename: String!
}

"The possible errors that can be raised are:\n\n- KT-CT-8202: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateGoodsQuote {
  possibleErrors: [PossibleErrorType]

  """Goods quote created for the customer."""
  goodsQuote: GoodsQuote
}

input CreateGoodsQuoteInput {
  """The account number."""
  accountNumber: String!

  """Products to get a quote for."""
  productsToQuote: [ProductToQuoteInput]!

  """A JSON object containing client parameters to store on the quote."""
  clientParams: GenericScalar
}

"""Represents a product and the quantity to quote for a customer."""
input ProductToQuoteInput {
  """ID of the product to quote."""
  productId: Int!

  """Number of units."""
  numberOfUnits: Int!

  """Price per unit in smallest sub-unit of the currency."""
  pricePerUnit: Int

  """Currency."""
  currency: String!
}

"The possible errors that can be raised are:\n\n- KT-CT-8202: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateGoodsQuoteWithoutAccount {
  possibleErrors: [PossibleErrorType]

  """Goods quote created for the customer."""
  goodsQuote: GoodsQuote
}

input CreateGoodsQuoteWithoutAccountInput {
  """Customer profile."""
  customerProfile: CustomerProfileInput!

  """Products to get a quote for."""
  productsToQuote: [ProductToQuoteInput]!

  """A JSON object containing client parameters to store on the quote."""
  clientParams: GenericScalar
}

input CustomerProfileInput {
  """Customer's given name."""
  givenName: String!

  """Customer's family name."""
  familyName: String!

  """Customer's email."""
  email: String!

  """Customer's phone number."""
  phoneNumber: String!

  """Customer's postcode."""
  postcode: String!

  """Line 1 of customer's address."""
  addressLine1: String!

  """Line 2 of customer's address."""
  addressLine2: String

  """Line 3 of customer's address."""
  addressLine3: String

  """Line 4 of customer's address."""
  addressLine4: String

  """Line 5 of customer's address."""
  addressLine5: String
}

"The possible errors that can be raised are:\n\n- KT-CT-8223: Unauthorized.\n- KT-CT-8201: Received an invalid quoteId.\n- KT-CT-8224: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type AcceptGoodsQuote {
  possibleErrors: [PossibleErrorType]

  """Goods purchase created."""
  goodsPurchase: GoodsPurchase
}

input AcceptGoodsQuoteInput {
  """The account number."""
  accountNumber: String!

  """ID of the accepted quote."""
  quoteId: Int!

  """A JSON object containing client parameters to store on the quote."""
  clientParams: JSONString

  """A JSON object containing market parameters to store on the purchase."""
  marketParams: JSONString
}

"The possible errors that can be raised are:\n\n- KT-CT-4122: Invalid email.\n- KT-CT-8203: Received an invalid quote code.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
type ShareGoodsQuote {
  possibleErrors: [PossibleErrorType]

  """Goods quote shared."""
  share: GoodsQuoteShare
}

type GoodsQuoteShare {
  """The ID of the quote share."""
  id: Int
}

input ShareGoodsQuoteInput {
  """The quote to share."""
  quoteCode: String!

  """The email to share the quote with."""
  email: String!
}

"The possible errors that can be raised are:\n\n- KT-CT-8206: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateGoodsPurchase {
  possibleErrors: [PossibleErrorType]

  """Goods purchase created."""
  goodsPurchase: GoodsPurchase
}

input CreatePurchaseInput {
  """The account number."""
  accountNumber: String!

  """Products being purchased."""
  saleItems: [ProductToPurchaseInput]!

  """A JSON object containing client parameters to store on the quote."""
  clientParams: JSONString

  """A JSON object containing client parameters to store on the purchase."""
  marketParams: JSONString
}

input ProductToPurchaseInput {
  """Products code to purchase."""
  productCode: String!

  """Number of units."""
  numberOfUnits: Int!
}

"The possible errors that can be raised are:\n\n- KT-CT-1401: Invalid data.\n- KT-CT-1402: Unable to create account reminder.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateAccountReminder {
  possibleErrors: [PossibleErrorType]

  """Account reminder."""
  accountReminder: AccountReminder
}

type AccountReminder {
  """The reminder type."""
  reminderType: AccountReminderTypes

  """Reminder content."""
  content: String

  """When the reminder is due."""
  dueAt: DateTime
}

"""Contains reminder type choices for all territories."""
enum AccountReminderTypes {
  AD_HOC
  DUNNING_REMINDER
  WITHDRAWAL_RECEIVED
  CHURN_PREVENTION
  PLANNED_INTERRUPTION
  PLANNED_INTERRUPTION_MEDICAL_DEPENDENCY
  MOVE_IN_MOVE_OUT_MANUAL_PROCESS
  MOVE_IN_CES_LIFE_SUPPORT_REQUIRED
  MOVE_IN_DEFAULT_PAYMENT_SCHEDULE_FAILED
  CANCEL_MOVE_OUT_UNABLE_TO_REINSTATE_FUTURE_AGREEMENTS
  SMETS2_DATA_REQUEST_FOLLOWUP
  COS_GAIN
  COS_LOSS
  MOVE_IN
  MOVE_OUT
  AMPERAGE_CHANGE
  CUSTOMER_DETAILS_CHANGE
  BILLING
  INDUSTRY_CUSTOMER_TRANSFER_DELAYED
  INDUSTRY_EXCEPTION_CHANGE_OF_SUPPLIER_REJECTED
  INDUSTRY_EXCEPTION_CHANGE_OF_SUPPLIER_CANCELLED
  INDUSTRY_EXCEPTION_CHANGE_OF_SUPPLIER_OBJECTED
  INDUSTRY_EXCEPTION_CHANGE_OF_SUPPLIER_CONFLICTING_PERIOD
  INDUSTRY_EXCEPTION_CHANGE_REQUEST_OBJECTED
  INDUSTRY_EXCEPTION_CHANGE_REQUEST_REJECTED
  INDUSTRY_EXCEPTION_CHANGE_REQUEST_CANCELLED
  INDUSTRY_EXCEPTION_CHANGE_REQUEST_OBJECTION_MISSING_ACK
  INDUSTRY_EXCEPTION_CHANGE_REQUEST_WITHDRAWAL_REJECTED
  INDUSTRY_EXCEPTION_CHANGE_REQUEST_OBJECTION_REJECTED
  INDUSTRY_EXCEPTION_CHANGE_REQUEST_OBJECTION_WITHDRAWAL_REJECTED
  INDUSTRY_EXCEPTION_UNABLE_TO_PROCESS_ROLR
  INDUSTRY_EXCEPTION_CHANGE_OF_SUPPLIER_GAIN_COMPLETION_OVERDUE
  INDUSTRY_EXCEPTION_CHANGE_REQUEST_COMPLETED
  INDUSTRY_EXCEPTION_CHANGE_REQUEST_CANCELLATION_FAILED
  INDUSTRY_EXCEPTION_SITE_ACCESS_DETAILS_NOTIFICATION_REJECTED
  INDUSTRY_EXCEPTION_SITE_ACCESS_DETAILS_NOTIFICATION_MISSING_BUSINESS_ACCEPTANCE
  INDUSTRY_MANUAL_CUSTOMER_DETAILS_NOTIFICATION_REQUIRED
  INDUSTRY_EXCEPTION_CUSTOMER_DETAILS_NOTIFICATION_MISSING_BUSINESS_ACCEPTANCE
  INDUSTRY_EXCEPTION_CUSTOMER_DETAILS_NOTIFICATION_MISSING_MANDATORY_FIELDS
  INDUSTRY_EXCEPTION_CUSTOMER_DETAILS_NOTIFICATION_INVALID_BILLING_ADDRESS
  INDUSTRY_EXCEPTION_CUSTOMER_DETAILS_REQUEST_SPECIAL_REASON
  INDUSTRY_EXCEPTION_CUSTOMER_DETAILS_NOTIFICATION_REJECTED
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_MULTIPLE_ACCOUNTS_MATCHES
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_MULTIPLE_LIFE_SUPPORT_CONTACT_MATCHES
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_FAILED_TO_SEND
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_UNKNOWN_CONTACT
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_INVALID_PHONE
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_INVALID_CONTACT_METHOD
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_RECEIVED_FROM_NON_REGISTRATION_OWNER
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_CONTAINS_UNEXPECTED_DATA
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_REQUEST_REJECTED
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_REJECTED
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_REQUEST_MISSING_BUSINESS_ACCEPTANCE
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_MISSING_BUSINESS_ACCEPTANCE
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_REQUEST_MISSING_LIFE_SUPPORT_NOTIFICATION
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_CONTACT_USER_REMOVED_FROM_ACCOUNT
  INDUSTRY_MANUAL_ACTION_REQUIRED
  INDUSTRY_MANUAL_LIFE_SUPPORT_NOTIFICATION_REQUIRED
  INDUSTRY_VIC_DRO_MANUAL_LIFE_SUPPORT_EXTENSION_REQUEST
  INDUSTRY_EXCEPTION_HOUSE_MOVE_ENROLMENT_SERVICE_ORDER_ALREADY_IN_PROGRESS
  INDUSTRY_EXCEPTION_HOUSE_MOVE_ENROLMENT_UNABLE_TO_COPY_LAST_METER_READING
  INDUSTRY_EXCEPTION_HOUSE_MOVE_ENROLMENT_CANNOT_CALCULATE_MOVE_IN_READING
  INDUSTRY_EXCEPTION_METER_POINT_ENROLMENT_INCOMPLETE_COULD_NOT_SEND_SERVICE_ORDER
  INDUSTRY_EXCEPTION_UNABLE_TO_ENROL_METER_POINT_INCOMPLETE_COULD_NOT_SEND_CHANGE_REQUEST
  INDUSTRY_EXCEPTION_UNABLE_TO_ENROL_METER_POINT_NEXT_SCHEDULED_READ_DATE_PAST
  INDUSTRY_EXCEPTION_RELINKING_OCCURRED_DURING_SDR_SYNC
  INDUSTRY_SEND_LIFE_SUPPORT_DE_REGISTRATION_FORM
  INDUSTRY_LIFE_SUPPORT_MANUAL_BEST_ENDEAVOUR_REQUIRED
  INDUSTRY_LIFE_SUPPORT_REVIEW_DEREGISTRATION
  INDUSTRY_LIFE_SUPPORT_REVIEW_POST_DEREGISTRATION_COMMS
  INDUSTRY_LIFE_SUPPORT_REVIEW_POST_DEREGISTRATION
  INDUSTRY_LIFE_SUPPORT_CANCEL_DEREGISTRATION_FAILED
  INDUSTRY_LIFE_SUPPORT_REGISTRATION_FOLLOW_UP_REQUIRED
  INDUSTRY_LIFE_SUPPORT_REVIEW_AFTER_CANCELLED_MOVE_OUT_FOR_NEXT_ACCOUNT
  INDUSTRY_LIFE_SUPPORT_REVIEW_ATTEMPTED_CANCELLED_MOVE_OUT_FOR_NEXT_ACCOUNT
  INDUSTRY_UNABLE_TO_CREATE_RECORD
  INDUSTRY_CHANGE_OF_SUPPLIER_DOUBLE_GAIN
  INDUSTRY_METER_POINT_MISSING_CUSTOMER_CLASSIFICATION
  INDUSTRY_READINGS_NOT_SENT
  INDUSTRY_WARNING_MESSAGE_RECEIVED
  SERVICE_ORDER_ACKNOWLEDGEMENT_OVERDUE
  SERVICE_ORDER_INITIAL_RESPONSE_OVERDUE
  SERVICE_ORDER_NOT_COMPLETED
  SERVICE_ORDER_CANCELLATION_REQUEST_REJECTED
  SERVICE_ORDER_PARTIALLY_COMPLETED
  SERVICE_ORDER_UNABLE_TO_CHARGE
  SERVICE_ORDER_REQUEST_REJECTED
  SERVICE_ORDER_UNSOLICITED_RECEIVED
  SERVICE_ORDER_UNSOLICITED_RECEIVED_DEENERGISED_METER_POINT
  SERVICE_ORDER_FAILED
  SERVICE_ORDER_CANCELLATION_FAILED
  SERVICE_ORDER_OTHER_JOB_ENQUIRY_CODE
  SPECIAL_READ_FAILED
  SPECIAL_READ_CANCELLATION_FAILED
  SPECIAL_READ_OUTSTANDING
  SPECIAL_READ_WITH_ESTIMATE_READ_RECEIVED
  NETWORK_TARIFF_ONE_WAY_NOTIFICATION
  METER_EXCHANGE_ONE_WAY_NOTIFICATION
  METER_FAULT_AND_ISSUE_ONE_WAY_NOTIFICATION_ACCEPTED
  METER_FAULT_AND_ISSUE_ONE_WAY_NOTIFICATION_REJECTED
  NOTICE_OF_METERING_WORKS_ONE_WAY_NOTIFICATION
  SMETS2_HEALTH_CHECK
  SMETS2_IHD_HEALTH_CHECK
  CUSTOMER_REPORTED_SMART_METER_ISSUES
  D0010_CREATION_FAILURE
  ACCOUNT_COOL_OFF
  D0052_CREATION_FAILURE
  D0205_CREATION_FAILURE
  PLANNED_INTERRUPTION_ONE_WAY_NOTIFICATION
  PLANNED_INTERRUPTION_ONE_WAY_NOTIFICATION_REJECTED
  PLANNED_INTERRUPTION_NOTIFICATION_SENT_TO_LIFE_SUPPORT_CUSTOMER
  FIELDWORKS_ALLOCATE_NMI_MARKET_PARTICIPANTS_NOT_SET
  FIELDWORKS_BULK_DEPLOYMENT_JOURNEY_AUTO_CANCELLED
  FIELDWORKS_METER_FAULT_JOURNEY_AUTO_CANCELLED
  FIELDWORKS_MULTIPLE_OPEN_JOURNEYS_FOR_METER_POINT
  FIELDWORKS_UPLOAD_ATTACHMENT_TO_JEMENA_PORTAL
  FIELDWORKS_OBTAIN_SUPPLY_ABOLISHMENT_APPROVAL
  FIELDWORKS_JOURNEY_CANCELLED_DUE_TO_LIFE_SUPPORT_REGISTRATION
  FIELDWORKS_METER_FAULT_RECEIVED
  FIELDWORKS_MIRN_DISCOVERY_FAILED
  FIELDWORKS_CHANGE_RETAILER_FAILED
  FIELDWORKS_SERVICE_ORDER_PARTIALLY_COMPLETED
  COS_GAIN_REL_RETRIEVAL_FAILURE
  INDUSTRY_EXCEPTION_UNABLE_TO_ENROL_METER_POINT_INVALID_NMI_METER_STATUS
  FIELDWORKS_JOURNEY_ATTACHMENTS
  FIELDWORKS_SERVICE_ORDER_ATTACHMENTS
  FIELDWORKS_SERVICE_ORDER_UNABLE_TO_ACCESS_WITH_CUSTOMER_CONSULTATION
  FIELDWORKS_METER_FAULT_NCOM_COMMS_FAILED
  FIELDWORKS_MOVE_OUT_CANCELLED_WHILE_SUPPLY_ABOLISHMENT_IN_PROGRESS
  FIELDWORKS_SUPPLY_PERIOD_DOES_NOT_EXIST_FOR_METERPOINT
  FIELDWORKS_METERPOINT_IS_NOT_ACTIVE
  FIELDWORKS_EXPECTED_METER_POINT_NOT_CREATED
  FIELDWORKS_NEW_CONNECTION_DATA_NOT_VALID
  FIELDWORKS_NEW_CONNECTION_COMPLETION_REVIEW
  FIELDWORKS_EXPECTED_METER_READ_NOT_RECEIVED
  FIELDWORKS_EXPECTED_NTCS_NOT_RECEIVED
  FIELDWORKS_CONTACT_SO_RECIPIENT_TO_UPDATE_THE_SO_DETAILS
  FIELDWORKS_INVESTIGATE_WHETHER_JOURNEY_NEEDS_CONTINUATION
  FIELDWORKS_ASSIGN_METERING_COORDINATOR_STEP_FAILED
  FIELDWORKS_ASSIGN_METERING_PROVIDER_STEP_FAILED
  FIELDWORKS_OBTAIN_CUSTOMER_APPROVAL_BEFORE_PROGRESSING
  FIELDWORKS_MANUALLY_COMPLETE_CUSTOMER_MOVE_IN
  AUS_EMBEDDED_WATER_READING_FAILURE
  AUS_EMBEDDED_WATER_ESTIMATION_REQUIRED_FOR_SKIPPED_READING
  AUS_VIC_SHAREDFUSE_NOTIFICATION
  JPN_SUPPLY_DETAILS_UPDATE_CONFIRMATION
  JPN_READINGS_NOT_RECEIVED
  JPN_FINAL_READING_OUTSIDE_AGREEMENT
  JPN_CONFIRMATION_OF_RELOCATION
  JPN_SHORT_TERM_MOVE_IN_REJECTION
  JPN_CALL_FOR_DUNNING_CAMPAIGN
  JPN_CONFIRM_PAYMENT_FOR_DUNNING_CAMPAIGN
  DUNNING_OUTBOUND_REMINDER_CALL
  DUNNING_BEST_ENDEAVOURS_CALL
  DUNNING_DISCONNECTION_OUTBOUND_REMINDER_CALL
  DUNNING_DISCONNECTION_DE_ENERGISATION_ASSESSMENT
  DUNNING_MANDATORY_NOTICE_EMAIL_FAILURE
  DUNNING_DISCONNECTION_MANDATORY_NOTICE_EMAIL_FAILURE
  DUNNING_VACANT_CONSUMPTION_DE_ENERGISATION_ASSESSMENT
  DUNNING_REMINDER_CALL
  DUNNING_REMINDER_DISCONNECTION_APPLICATION
  DUNNING_REMINDER_PAYMENT_MADE
  NON_ENERGY_PAYMENT_CALL_REMINDER
  PAYMENTS_FAILED_REPAYMENT
  PAYMENT_PLAN
  PAYMENT_PLAN_MISSED_INSTALMENT
  POST_HARDSHIP_CANCELLATION
  PAYMENT_PLAN_HARDSHIP_COMPLETION
  PAYMENT_PLAN_HARDSHIP_COMPLETION_WORKFLOW_CANCELLED
  HARDSHIP_GRADUATION_ASSESSMENT
  HARDSHIP_REMOVAL_ASSESSMENT
  PAYMENT_INSTRUCTION_FAILED
  DISCONNECTION_MANDATORY_NOTICE_EMAIL_FAILURE
  DISCONNECTION_MANDATORY_NOTICE_SMS_FAILURE
  INDUSTRY_EXCEPTION_STANDING_DATA_PROPERTIES_ADDRESS_FAILED_TO_UPDATE
  MARKET_SUPPLY_EXCEPTION_AGREEMENT_FAILED_TO_TERMINATE
  MARKET_SUPPLY_EXCEPTION_AGREEMENT_FAILED_TO_CREATE
  MARKET_SUPPLY_EXCEPTION_AGREEMENT_FAILED_TO_UPDATE
  MARKET_SUPPLY_EXCEPTION_MISSING_ACCOUNT_QUOTED_PRODUCT
  MARKET_SUPPLY_EXCEPTION_AGREEMENT_FAILED_TO_REVERSE_TERMINATION
  GAS_EXCEPTION_SITE_ACCESS_DETAILS_RECEIVED_FOR_NON_EXISTENT_METER
  GAS_EXCEPTION_CUSTOMER_DETAILS_NOTIFICATION_FAILED
  GAS_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_FAILED
  GAS_EXCEPTION_SITE_ACCESS_DETAILS_NOTIFICATION_FAILED
  GAS_EXCEPTION_SITE_ADDRESS_DETAILS_NOTIFICATION_FAILED
  GAS_EXCEPTION_METER_DATA_VERIFY_REQUEST_FAILED
  GAS_EXCEPTION_METER_DATA_VERIFY_RESPONSE_OVERDUE
  GAS_EXCEPTION_METER_DATA_VERIFY_RESPONSE_NO_CHANGE_WITH_EXPLANATION
  GAS_EXCEPTION_METER_DATA_VERIFY_RESPONSE_WITHOUT_REVISED_READ
  GAS_NOTIFICATION_CHANGE_OF_SITE_ADDRESS
  INDUSTRY_EXCEPTION_NEXT_SCHEDULED_READ_DATE_TOO_FAR_IN_FUTURE
  GAS_EXCEPTION_CUSTOMER_TRANSFER_CANCELLED
  GAS_EXCEPTION_CUSTOMER_TRANSFER_REJECTED
  GAS_MANUAL_SERVICE_ORDER_REQUIRED_FOR_ENROLMENT
  GAS_READING_REMOVED_INSTALLED_RECEIVED
  GAS_UNKNOWN_CUSTOMER_CLASSIFICATION_CODE_RECEIVED
  BILLING_AMENDED_METER_READ_BASIC
  BILLING_AMENDED_METER_READ_GAS
  BILLING_AMENDED_METER_READ_INTERVAL_LEGACY
  BILLING_AMENDED_METER_READ_INTERVAL
  BILLING_AMENDED_METER_READ_PRE_MIGRATION
  BILLING_AMENDED_METER_READ_CES_ELEC_BASIC
  BILLING_AMENDED_METER_READ_CES_ELEC_INTERVAL
  BILLING_REGISTER_REPLACED_OR_REMOVED
  OBSOLETE_BILLING_AMENDED_STANDING_DATA_REGISTER_DELETED
  OBSOLETE_BILLING_AMENDED_STANDING_DATA_REGISTER_CHANGED
  BILLING_CUSTOMER_SELF_READ_RECEIVED
  BILLING_MISSING_READ
  SA_CONCESSION_STATEMENT_CLOSED
  BILLING_BACKDATED_CONCESSION_RECEIVED
  BILLING_BACKDATED_UMS_RECORD_RECEIVED
  BILLING_AMENDED_INTERVAL_DATA_RECEIVED_CAUSING_OVERCHARGE
  BILLING_QUOTED_NTC_DOES_NOT_ALIGN
  FINAL_BILLING_UNABLE_TO_BILL
  MANDATORY_COMMS_NOT_DELIVERED
  CONTRACT_COMMS_NOT_DELIVERED
  MOVE_IN_COMMS_NOT_DELIVERED
  SMART_PREPAY_TOP_UP_UTRN
  SMART_PREPAY_TOP_UP_MULTIPLE_ACTIVE_PROCESSES
  SMART_PREPAY_TOP_UP_FAILURE
  SMART_PREPAY_ADD_DEBT_FAILURE
  SMART_PREPAY_NEED_TO_ADJUST_DEBT
  SMART_METER_MODE_CHANGE_UNSUPPORTED
  HELD_STATEMENT
  AUTOMATED_BILLING_DISABLED
  SOLAR_EXPORT_CREDITS_EXCESS
  ASSIGNED_TO_CREDIT_TEAM
  WORKFLOW_STEP_FAILED
  WORKFLOW_STEP_ERRORED
  WORKFLOW_CANCELLATION_FAILED
  KMT
  SOLR_FINAL_BILL_REMINDER
  COS_GAIN_MIGRATION_ECOES_METER_MISMATCH
  ACCOUNT_MIGRATION_SYNC_XOSERVE_METER_MISMATCH
  SMART_CHANGE_OF_TENANCY_REQUEST_FAILED
  SMART_CHANGE_OF_TENANCY_IN_PROGRESS
  AGREEMENT_REVOKED
  EMBEDDED_NETWORK_EXCEPTION_PARENT_METER_POINT_LOST_OR_LOSING
  EMBEDDED_NETWORK_EXCEPTION_PARENT_METER_POINT_RECEIVED_LIFE_SUPPORT_NOTIFICATION
  EMBEDDED_NETWORK_EXCEPTION_PARENT_METER_POINT_RECEIVED_DANGEROUS_LIFE_SUPPORT_NOTIFICATION
  EMBEDDED_NETWORK_EXCEPTION_DISTRIBUTOR_OWNED_PARENT_LIFE_SUPPORT_RECORD
  EMBEDDED_NETWORK_ALL_CHILD_LIFE_SUPPORT_RECORDS_ARE_DEREGISTERED
  SCHEDULED_BILLING_ADDRESS_UPDATE
  SCHEDULED_OCCUPIER_PACK_SEND
  PROPERTY_ADDRESS_NEEDS_UPDATE
  FRA_ACTIVATION_PROCESS_INCEPTION_CHECKS
  FRA_ACTIVATION_PROCESS_SCHEDULE_SITEWORKS
  FRA_ACTIVATION_PROCESS_GAS_PROVIDER_CHANGE_REQUEST
  FRA_ACTIVATION_PROCESS_PRM_ELIGIBILITY
  FRA_ACTIVATION_PROCESS_AWAITING_SWITCH_READINGS
  FRA_ELEC_ACTIVATION_PROCESS_WRONG_SWITCH_READINGS_FOR_PROVIDER_CALENDAR_TEMPORAL_CLASSES
  FRA_ACTIVATION_PROCESS_COMMANDER_SOUSCRIPTION
  FRA_ACTIVATION_PROCESS_AWAITING_SWITCH_IN_CONFIRMATION
  FRA_ENERGY_CHEQUE_UNKNOWN
  COMMS_TO_BE_PRINTED
  FLOW_FILE_ERROR
  NEW_PSR_ADDED_TO_PREPAY_ACCOUNT
  PSR_IMPORT_COULD_NOT_IDENTIFY_ACCOUNT_USER
  MAIL_RETURNED
  MAIL_FAILED
  DUPLICATE_CARD_FINGERPRINTs
}

input CreateAccountReminderInput {
  """The account number."""
  accountNumber: String!

  """The reminder type."""
  reminderType: AccountReminderTypes!

  """Reminder content."""
  content: String!

  """When the reminder is due."""
  dueAt: DateTime
}

"Create an account reference.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4123: Unauthorized.\n- KT-CT-8310: Invalid data.\n- KT-CT-8311: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateAccountReference {
  possibleErrors: [PossibleErrorType]
  accountReference: AccountReferenceType
}

"""The input type for the account reference."""
input AccountReferenceInput {
  """The account number."""
  accountNumber: String!

  """The namespace for the reference."""
  namespace: String!

  """The reference value."""
  value: String!
}

"Update a reference for a particular account and namespace.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4123: Unauthorized.\n- KT-CT-8310: Invalid data.\n- KT-CT-8311: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type UpdateAccountReference {
  possibleErrors: [PossibleErrorType]
  accountReference: AccountReferenceType
}

"Delete a reference for a particular account and namespace.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4123: Unauthorized.\n- KT-CT-8310: Invalid data.\n- KT-CT-8312: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type DeleteAccountReference {
  possibleErrors: [PossibleErrorType]
  accountReference: DeleteAccountReferenceType
}

type DeleteAccountReferenceType {
  """The namespace associated with the removed AccountReference"""
  namespace: String!
}

input DeleteAccountReferenceInput {
  """The account number associated with the removed AccountReference."""
  accountNumber: String!

  """The namespace associated with the removed AccountReference"""
  namespace: String!
}

"Create an external account event.\n\nThe possible errors that can be raised are:\n\n- KT-CT-7123: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateExternalAccountEvent {
  possibleErrors: [PossibleErrorType]

  """The new event data."""
  event: ExternalAccountEvent
}

type ExternalAccountEvent {
  id: ID!
  eventType: String!
  category: String!
  subcategory: String!
  description: String
  content: JSONString
}

input CreateExternalAccountEventInput {
  """The number of the account that the event should be created for."""
  accountNumber: String!

  """The category of the event."""
  category: ExternalAccountEventCategory!

  """The subcategory of the event."""
  subcategory: ExternalAccountEventSubCategory

  """A human-readable description of the event."""
  description: String

  """An array of content data associated with the event."""
  content: [ExternalAccountEventContent]!
}

"""Enum of allowable event type categories for external account events."""
enum ExternalAccountEventCategory {
  COMMUNICATIONS
  WEB
  MOBILE
  MESSAGING
  DEBT
}

"""
Enum of allowable event type subcategories for external account events.
"""
enum ExternalAccountEventSubCategory {
  TELEPHONE
  EMAIL
  SMS
  PRINT
  PUSH_NOTIFICATION
  SOCIAL_MEDIA
  FEEDBACK
  WHATSAPP
  CLICK_TO_CALL
  DUNNING
}

"""A piece of content associated with an external account event."""
input ExternalAccountEventContent {
  """A human-readable description of the content."""
  description: String!

  """The content type of the content."""
  contentType: ExternalAccountEventContentType!

  """The value of the content."""
  value: String!
}

"""
Enum of allowable content types for external account events.

The content type field is used to determine how to display the content in the account event
description.
"""
enum ExternalAccountEventContentType {
  PLAINTEXT
  LINK
  HTML
  S3
}

"Add credits to an account.\n\nThe possible errors that can be raised are:\n\n- KT-CT-5315: Invalid data.\n- KT-CT-5314: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateAccountCredit {
  possibleErrors: [PossibleErrorType]
  accountCredit: AccountCreditType
}

type AccountCreditType {
  id: ID!

  """"""
  grossAmount: BigInt!

  """"""
  netAmount: BigInt!

  """"""
  salesTaxAmount: BigInt!
  note: String!
  reason: String!
  metadata: AccountCreditMetadataType
}

type AccountCreditMetadataType {
  data: JSONString!
  updatedAt: DateTime!
}

"""The input type for the account credit."""
input CreateAccountCreditInput {
  """The account number."""
  accountNumber: String!

  """The net amount of the credit to be created."""
  netAmount: Int!

  """The gross amount of the credit to be created."""
  grossAmount: Int!

  """The sales tax amount of the credit to be created."""
  salesTaxAmount: Int!

  """Any extra data that will be associated with account credit."""
  metadata: JSONString

  """Optional short note about account credit."""
  note: String

  """The reason why the credit is added to the account."""
  reason: AccountCreditReasonType!
}

"\n    Please note: these labels are exposed in the API documentation.\n    "
enum AccountCreditReasonType {
  """External referral credit"""
  EXTERNAL_REFERRAL_CREDIT
}

"The possible errors that can be raised are:\n\n- KT-CT-5316: Invalid data.\n- KT-CT-5311: The credit reason with the requested code is deprecated.\n- KT-CT-5312: The credit reason with the requested code does not exist.\n- KT-CT-5313: An error occurred whilst posting the credit.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type PostCredit {
  possibleErrors: [PossibleErrorType]

  """Posted account credit."""
  credit: Credit
}

input PostCreditInput {
  """The account number."""
  accountNumber: String!

  """
  The net amount of the credit to be posted. Amount should be posted in the smallest unit of currency.
  """
  netAmount: Int!

  """
  The tax amount of the credit to be posted. Amount should be posted in the smallest unit of currency.
  """
  taxAmount: Int!

  """Optional short note about the credit, to be displayed to the user."""
  displayNote: String

  """
  Optional short note about the credit, to be displayed to internal systems.
  """
  note: String

  """
  The reason why the credit is posted. This should be a valid credit reason code.
  """
  reason: String!

  """The ID of the ledger where the credit will be posted."""
  ledgerId: ID!
}

"Add charges to an account.\n\nThe possible errors that can be raised are:\n\n- KT-CT-5211: The charge reason with the requested code is deprecated.\n- KT-CT-5212: The charge reason with the requested code does not exist.\n- KT-CT-5213: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateAccountCharge {
  possibleErrors: [PossibleErrorType]
  accountCharge: AccountChargeType
}

type AccountChargeType {
  id: ID!

  """"""
  grossAmount: BigInt!

  """Climate change levy"""
  cclAmount: BigInt!

  """"""
  netAmount: BigInt

  """"""
  salesTaxAmount: BigInt
  reason: String!
  note: String!
  displayNote: String!
  metadata: AccountChargeMetadataType
}

type AccountChargeMetadataType {
  data: JSONString!
  updatedAt: DateTime!
}

"""The input type for the account charge."""
input CreateAccountChargeInput {
  """The account number."""
  accountNumber: String!

  """The gross amount of the charge to be added."""
  grossAmount: Int!

  """Any extra data that will be associated with account charge."""
  metadata: JSONString

  """Optional short note about account charge for internal use."""
  note: String

  """Optional short note about account charge for customer display."""
  displayNote: String

  """
  The reason why the charge is added to the account. This should be a valid charge reason code.
  """
  reason: String!
}

"Trigger balance transfer between accounts.\n\nThe possible errors that can be raised are:\n\n- KT-CT-3810: Received an invalid ledger id.\n- KT-CT-3822: Unauthorized.\n- KT-CT-3823: Unauthorized.\n- KT-CT-9701: Balance transfer to same account is not allowed.\n- KT-CT-9702: Balance transfer is not support for debit account with Zero balance.\n- KT-CT-9703: Balance transfer is not supported for debit account.\n- KT-CT-9704: Balance transfer amount should be non-zero.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type TransferLedgerBalance {
  possibleErrors: [PossibleErrorType]

  """Balance transfer details."""
  balanceTransfer: AccountBalanceTransferType
}

type AccountBalanceTransferType {
  """Balance transfer ID."""
  id: ID

  """Debit details."""
  accountCharge: AccountChargeType

  """Credit details."""
  accountCredit: AccountCreditType

  """The reason for the balance transfer."""
  reason: String
}

input TransferLedgerBalanceInputType {
  """Account's ledger from which the requested amount is debited."""
  sourceAccountLedger: AccountLedgerInput!

  """Account's ledger to which the requested amount is credited."""
  targetAccountLedger: AccountLedgerInput!

  """
  The amount ( in lowest unit ) to transfer. If the amount is negative,the effect is reversed  (the source ledger's balance increases and the destination ledger's balance decreases).
  """
  amount: Int!

  """Optional short note about transfer reason."""
  note: String
}

input AccountLedgerInput {
  """The account number."""
  accountNumber: ID!

  """The ledger id for the account."""
  ledgerId: ID!
}

type FormSubmissionOuput {
  id: Int
  content: JSONString
  errors: [SerializerFieldErrorsType]
}

type SerializerFieldErrorsType {
  field: String
  errors: [ErrorTypeUnion!]
}

union ErrorTypeUnion = SerializerErrorType | SerializerFieldErrorsType

type SerializerErrorType {
  message: String
  code: String
}

input FormSubmissionInput {
  """"""
  accountNumber: String!

  """Form type"""
  formType: FormType = null

  """Form content"""
  content: JSONString!
}

"""An enumeration."""
enum FormType {
  """Covid-19 Financial Energy Assessment"""
  COVID_19_FINANCIAL_ENERGY_ASSESSMENT

  """Covid-19 Gas Prices Financial Energy Assessment"""
  COVID_19_GAS_PRICES_FINANCIAL_ENERGY_ASSESSMENT
}

type EmailAuthentication {
  """The DRF token to be used for authentication."""
  token: String
  errors: [ErrorType]
}

type ErrorType {
  field: String!
  messages: [String!]!
}

type APIKeyAuthentication {
  """The DRF token to be used for authentication."""
  token: String
  errors: [ErrorType]
}

type MasqueradeAuthentication {
  """
  A Kraken Token that can be used to authenticate to the API, masquerading as the desired user.
  """
  token: String

  """A list of any errors that occurred while running this mutation."""
  errors: [ErrorType]
}

"Mutation to generate a pre-signed token.\n\nThe pre-signed, expiring and opaque tokens will be swapped\nfor a limited scope JWT (Kraken Token).\n\nThe possible errors that can be raised are:\n\n- KT-CT-1128: Unauthorized.\n- KT-CT-1120: The Kraken Token has expired.\n- KT-CT-1131: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type GeneratePreSignedToken {
  possibleErrors: [PossibleErrorType]
  token: String
  tokenExpiryDatetime: DateTime
  scope: PreSignedTokenScope
}

"\n    Choices class for the pre-signed expiring tokens.\n\n    These choices must have a certain format:\n\n    {ACTION-VERB}_{DEFINING-NOUN}\n\n    They should start with an action verb. It should be a single word.\n    The action verb enables the account user to do the thing (defining noun)\n    that comes after the action verb. Together they represent a task.\n\n    The defining noun could be longer than a single word.\n    Preferably, it should be kept short and simple as much as possible.\n    "
enum PreSignedTokenScope {
  """Scope that enables account user to submit meter readings."""
  SUBMIT_METER_READINGS

  """Scope that enables account user to submit customer feedback."""
  SUBMIT_CUSTOMER_FEEDBACK

  """Scope that enables account user to book smart meter appointments."""
  BOOK_SMART_METER_APPOINTMENTS

  """Edit Customer Marketing Preference"""
  EDIT_CUSTOMER_MARKETING_PREFERENCE

  """Scope that enables account user to join campaigns."""
  JOIN_CAMPAIGNS

  """Scope that enables account user to join campaign events."""
  JOIN_CAMPAIGN_EVENTS

  """Scope that enables account user to visit campaign dashboard."""
  VIEW_CAMPAIGN_DASHBOARDS

  """
  Scope that enables account user to visit detailed property usage pages.
  """
  VIEW_DETAILED_USAGE

  """Scope that enables account user to redeem loyalty points"""
  REDEEM_LOYALTY_POINTS

  """
  Scope that enables account user to generate a renewal quote and renew agreements.
  """
  MANAGE_ACCOUNT_RENEWALS

  """
  Scope that enables account user to checkout a quote (validate terms & conds and provide a payment detail).
  """
  CHECKOUT_QUOTE

  """
  Scope that enables account user to update their blackhole email address.
  """
  UPDATE_BLACKHOLE_EMAIL

  """Update Sensitive Customer Information"""
  UPDATE_SENSITIVE_CUSTOMER_INFORMATION

  """
  Scope that enables account user to accept goods quotes and process goods purchases.
  """
  MANAGE_GOODS_PURCHASES

  """Scope that enables account user to report a property move-out."""
  REPORT_MOVE_OUT

  """
  Scope that enables account user to accept the terms and conditions for a product.
  """
  ACCEPT_TERMS_AND_CONDITIONS

  """
  Scope that enables account user to do a self-serve product switch through the Dashboard.
  """
  MANAGE_PRODUCT_SWITCH
}

"Invalidate a previously issued expiring/pre-signed token.\n\nThis mutation can be used to invalidate the token itself.\n\nTo invalidate tokens issued to a particular user, use\nInvalidatePreSignedTokensForUser mutation.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1129: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type InvalidatePreSignedToken {
  possibleErrors: [PossibleErrorType]
  token: PreSignedToken
}

"""
A pre-signed, expiring and opaque tokens that can be swapped for a limited scope JWT (Kraken Token).
"""
type PreSignedToken {
  key: String!

  """The scope that the token will grant to the account user."""
  scope: ExpiringTokenScope!
  isValid: Boolean
}

"""An enumeration."""
enum ExpiringTokenScope {
  """Scope that enables account user to submit meter readings."""
  SUBMIT_METER_READINGS

  """Scope that enables account user to submit customer feedback."""
  SUBMIT_CUSTOMER_FEEDBACK

  """Scope that enables account user to book smart meter appointments."""
  BOOK_SMART_METER_APPOINTMENTS

  """Edit Customer Marketing Preference"""
  EDIT_CUSTOMER_MARKETING_PREFERENCE

  """Scope that enables account user to join campaigns."""
  JOIN_CAMPAIGNS

  """Scope that enables account user to join campaign events."""
  JOIN_CAMPAIGN_EVENTS

  """Scope that enables account user to visit campaign dashboard."""
  VIEW_CAMPAIGN_DASHBOARDS

  """
  Scope that enables account user to visit detailed property usage pages.
  """
  VIEW_DETAILED_USAGE

  """Scope that enables account user to redeem loyalty points"""
  REDEEM_LOYALTY_POINTS

  """
  Scope that enables account user to generate a renewal quote and renew agreements.
  """
  MANAGE_ACCOUNT_RENEWALS

  """
  Scope that enables account user to checkout a quote (validate terms & conds and provide a payment detail).
  """
  CHECKOUT_QUOTE

  """
  Scope that enables account user to update their blackhole email address.
  """
  UPDATE_BLACKHOLE_EMAIL

  """Update Sensitive Customer Information"""
  UPDATE_SENSITIVE_CUSTOMER_INFORMATION

  """
  Scope that enables account user to accept goods quotes and process goods purchases.
  """
  MANAGE_GOODS_PURCHASES

  """Scope that enables account user to report a property move-out."""
  REPORT_MOVE_OUT

  """
  Scope that enables account user to accept the terms and conditions for a product.
  """
  ACCEPT_TERMS_AND_CONDITIONS

  """
  Scope that enables account user to do a self-serve product switch through the Dashboard.
  """
  MANAGE_PRODUCT_SWITCH
}

"""Input type for the InvalidatePreSignedToken mutation."""
input InvalidatePreSignedTokenInput {
  token: String!
}

"Invalidate pre-signed tokens previously issued to a particular user.\n\nThis mutation can invalidate all pre-signed tokens issued to a\ncustomer, or only tokens of a given scope.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1129: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type InvalidatePreSignedTokensForUser {
  possibleErrors: [PossibleErrorType]
  tokens: [PreSignedToken]
}

"""Input type for the InvalidatePreSignedTokensForUser mutation."""
input InvalidatePreSignedTokensForUserInput {
  """The email address of the user whose tokens should be invalidated."""
  email: String!

  """
  The scope of the token to invalidate.  If this argument is not specified, all pre-signed tokens issued to the user are invalidated.
  """
  scope: PreSignedTokenScope = null
}

"""
Mutation to disable the token used to call this mutation. Requires a valid token
for authentication to avoid a potential denial-of-service issue. The token used
for authentication will be the token disabled.
"""
type DisableToken {
  message: String
}

type RequestResetPasswordMutationPayload {
  email: String!
  isCreateMode: Boolean
  errors: [ErrorType]
  clientMutationId: String
}

input RequestResetPasswordMutationInput {
  email: String!
  isCreateMode: Boolean
  clientMutationId: String
}

type RequestPasswordResetOutputType {
  """The email that requested a password reset email."""
  email: String
}

"""Input type for the RequestPasswordReset mutation."""
input RequestPasswordResetInput {
  """The email requesting a password reset email."""
  email: String!
}

type ResetPasswordMutationPayload {
  errors: [SerializerFieldErrorsType]
  clientMutationId: String
}

input ResetPasswordMutationInput {
  password: String!
  userId: String!
  token: String!
  clientMutationId: String
}

"The unifying approach used to get a Kraken token (JWT: JSON Web Token) with\ndifferent types of input.\n\nThe currently supported inputs are:\n- account user email/password combination\n- account user API key\n- organization live secret key\n- pre-signed key\n- refresh token\n\nThe possible errors that can be raised are:\n\n- KT-CT-1135: Invalid data.\n- KT-CT-1134: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
type ObtainKrakenJSONWebToken {
  possibleErrors: [PossibleErrorType]

  """
  The Kraken Token.  Can be used in the `Authorization` header for subsequent calls to the API to access protected resources.
  """
  token: String!

  """
  The body payload of the Kraken Token.  The same information can be obtained by using JWT decoding tools on the value of the `token` field.
  """
  payload: GenericScalar!

  """
  A token that can be used in a subsequent call to `obtainKrakenToken` to get a new Kraken Token with the same access conditions after the previous one has expired.
  """
  refreshToken: String

  """
  A Unix timestamp representing the point in time at which the refresh token will expire.
  """
  refreshExpiresIn: Int
}

"""The input type for obtaining a Kraken Token (JWT)."""
input ObtainJSONWebTokenInput {
  """Email address of the account user. Use with 'password' field."""
  email: String

  """Password of the account user. Use with 'email' field."""
  password: String

  """
  API key of the account user. Use standalone, don't provide a second input field.
  """
  APIKey: String

  """
  Live secret key of an third-party organization. Use standalone, don't provide a second input field.
  """
  organizationSecretKey: String

  """
  Short-lived, temporary key (that's pre-signed). Use standalone, don't provide a second input field.
  """
  preSignedKey: String

  """
  The refresh token that can be used to extend the expiry claim of a Kraken token. Use standalone, don't provide a second input field.
  """
  refreshToken: String
}

type ForceReauthentication {
  """
  Reports whether the mutation applied successfully.  Should always be 'true'.
  """
  tokensInvalidated: Boolean!

  """
  The time at which forced reauthentication is effective.  Kraken and refresh tokens issued before this time will be invalid.
  """
  effectiveAt: DateTime!
}

"""
The input type for repudiating previously issued Kraken Tokens and refresh tokens.
"""
input ForceReauthenticationInput {
  """
  Also force third-party applications you have authorized to use your account to reauthenticate.
  """
  includeThirdParties: Boolean!
}

"Obtain a long-lived refresh token.\n\nThis mutation is limited to authorized third-party organizations only.\n\nAccount users can only generate short-lived refresh tokens.\n\nThe short-lived refresh tokens (for account users) can be obtained from\nthe 'refreshToken' field in 'obtainKrakenToken' mutation.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1120: The Kraken Token has expired.\n- KT-CT-1121: Please use Kraken Token to issue long-lived refresh tokens.\n- KT-CT-1132: Unauthorized.\n- KT-CT-1122: Long-lived refresh tokens can only be issued for account users.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type ObtainLongLivedRefreshToken {
  possibleErrors: [PossibleErrorType]
  refreshToken: String
  refreshExpiresIn: Int!
}

"""The input type for obtaining a long-lived refresh token."""
input ObtainLongLivedRefreshTokenInput {
  """
  The Kraken Token that will be used to generate the long-lived refresh token.
  """
  krakenToken: String!
}

"Invalidate a previously issued refresh token.\n\nThis mutation can be used to invalidate the token itself.  To\ninvalidate tokens issued to a particular user, use\nInvalidateRefreshTokensForUser.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1130: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type InvalidateRefreshToken {
  possibleErrors: [PossibleErrorType]
  token: RefreshToken
}

"""An opaque token that can be used to renew a Kraken Token."""
type RefreshToken {
  key: String!

  """The datetime when the token will expire."""
  expiryDt: DateTime!
  isValid: Boolean
}

"""Input type for the InvalidateRefreshToken mutation."""
input InvalidateRefreshTokenInput {
  refreshToken: String!
}

"Invalidate refresh tokens previously issued to a particular user.\n\nThis mutation will invalidate all refresh tokens issued to a\ncustomer.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1128: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type InvalidateRefreshTokensForUser {
  possibleErrors: [PossibleErrorType]
  tokens: [RefreshToken]
}

"""Input type for the InvalidateRefreshTokensForUser mutation."""
input InvalidateRefreshTokensForUserInput {
  """The email address of the user whose tokens should be invalidated."""
  email: String!
}

"The possible errors that can be raised are:\n\n- KT-CT-7801: Received an invalid operationsTeamId.\n- KT-CT-7802: The external identifier already exists.\n- KT-CT-7805: Too many tags associated with this API Exception.\n- KT-CT-7806: Cannot create duplicate tags for the same API exception.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateAPIException {
  possibleErrors: [PossibleErrorType]

  """The created APIException."""
  apiException: APIExceptionType
}

input CreateAPIExceptionInput {
  """External identifier mapping an entity on the client's database."""
  externalIdentifier: String!

  """The resolution status. Defaults to UNASSIGNED if not provided."""
  resolutionStatus: APIExceptionResolutionStatus = null

  """The resolution type. Defaults to UNASSIGNED if not provided."""
  resolutionType: APIExceptionResolutionType = null

  """The priority. Defaults to LOW if not provided."""
  priority: APIExceptionPriority = null

  """Contextual information about the exception, if any."""
  context: JSONString

  """The API client channel where the exception was triggered from."""
  channel: String!

  """
  The ID of an operations team to handle this exception. If no team is provided, no team will be assigned to the exception.
  """
  operationsTeamId: Int

  """Tags associated with this exception if any."""
  tags: [APIExceptionTags]

  """
  Category associated with this exception. Uses the default category if not provided.
  """
  category: APIExceptionCategories = UNKNOWN

  """The account number associated with the exception, if available."""
  accountNumber: ID

  """The user ID associated with the exception, if available."""
  userId: Int

  """The customer contact associated with the exception, if available."""
  customerContact: String

  """
  The supply point identifier associated with the exception, if available.
  """
  supplyPointIdentifier: String
}

"The possible errors that can be raised are:\n\n- KT-CT-7804: No fields present in the input for updating the APIException.\n- KT-CT-7803: Received an invalid apiExceptionId.\n- KT-CT-7809: Update results in no changes to API Exception.\n- KT-CT-7805: Too many tags associated with this API Exception.\n- KT-CT-7806: Cannot create duplicate tags for the same API exception.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type UpdateAPIException {
  possibleErrors: [PossibleErrorType]

  """The updated APIException."""
  apiException: APIExceptionType
}

input UpdateAPIExceptionInput {
  """The ID of the API Exception that will be updated."""
  id: Int!

  """
  The new resolution status. If none is provided, the field won't be updated.
  """
  resolutionStatus: APIExceptionResolutionStatus = null

  """
  The new resolution type. If none is provided, the field won't be updated.
  """
  resolutionType: APIExceptionResolutionType = null

  """The new priority. If none is provided, the field won't be updated."""
  priority: APIExceptionPriority = null

  """
  The new context. If none is provided, the field won't be updated. This will completely replace the existing context by the new one.
  """
  context: JSONString

  """The new category. If none is provided, the field won't be updated."""
  category: APIExceptionCategories = null

  """
  The updated list of tags. If none is provided, the field won't be updated.
  """
  tags: [APIExceptionTags]
}

"The possible errors that can be raised are:\n\n- KT-CT-7803: Received an invalid apiExceptionId.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateAPICall {
  possibleErrors: [PossibleErrorType]

  """The created APICall."""
  apiCall: APICallType
}

input CreateAPICallInput {
  """The correlation id header from the HTTP request."""
  correlationId: String!

  """The name of the operation associated with this call."""
  operationName: String!

  """The input data provided to the API, if any."""
  inputData: JSONString

  """The response returned by the API."""
  response: JSONString!

  """Any optional useful context involved in the API call."""
  context: JSONString

  """The ID of the associated API exception, if any."""
  apiExceptionId: Int
}

"The possible errors that can be raised are:\n\n- KT-CT-7803: Received an invalid apiExceptionId.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateAPIExceptionEvent {
  possibleErrors: [PossibleErrorType]

  """The created APIExceptionEvent."""
  apiExceptionEvent: APIExceptionEventType
}

input CreateAPIExceptionEventInput {
  """The event type."""
  eventType: String!

  """The event category."""
  category: String!

  """Any useful event description."""
  description: String!

  """Any optional useful context involved in the event."""
  context: JSONString

  """The ID of the associated API exception, if any."""
  apiExceptionId: Int
}

"The possible errors that can be raised are:\n\n- KT-CT-7803: Received an invalid apiExceptionId.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateAPIExceptionNote {
  possibleErrors: [PossibleErrorType]

  """The created APIExceptionNote."""
  apiException: APIExceptionType
}

input CreateAPIExceptionNoteInput {
  """The body of the note."""
  body: String!

  """The ID of the associated API exception."""
  apiExceptionId: ID!
}

"The possible errors that can be raised are:\n\n- KT-CT-7807: Received an invalid apiExceptionNoteId.\n- KT-CT-7808: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type UpdateAPIExceptionNote {
  possibleErrors: [PossibleErrorType]

  """The updates APIExceptionNote."""
  apiException: APIExceptionType
}

input UpdateAPIExceptionNoteInput {
  """The body of the note."""
  body: String!

  """The ID of the API Exception note being updated."""
  apiExceptionNoteId: ID!
}

type UpdateAccountUserMutationPayload {
  givenName: String
  familyName: String
  pronouns: String
  mobile: String
  email: String
  dateOfBirth: Date
  landline: String
  errors: [ErrorType]
  clientMutationId: String
}

input UpdateAccountUserMutationInput {
  givenName: String
  familyName: String
  pronouns: String
  mobile: String
  email: String
  dateOfBirth: Date
  landline: String
  clientMutationId: String
}

"""Update the account user comms preferences."""
type UpdateAccountUserCommsPreferencesMutationPayload {
  isOptedInToClientMessages: Boolean
  isOptedInToOfferMessages: Boolean
  isOptedInToRecommendedMessages: Boolean
  isOptedInToUpdateMessages: Boolean
  isOptedInToThirdPartyMessages: Boolean
  isOptedInMeterReadingConfirmations: Boolean
  isOptedInToSmsMessages: Boolean
  isUsingInvertedEmailColours: Boolean
  fontSizeMultiplier: Float
  emailFormat: String
  preferredHoldMusic: String
  errors: [ErrorType]
  commsPreferences: AccountUserCommsPreferences
  clientMutationId: String
}

input UpdateAccountUserCommsPreferencesMutationInput {
  isOptedInToClientMessages: Boolean
  isOptedInToOfferMessages: Boolean
  isOptedInToRecommendedMessages: Boolean
  isOptedInToUpdateMessages: Boolean
  isOptedInToThirdPartyMessages: Boolean
  isOptedInMeterReadingConfirmations: Boolean
  isOptedInToSmsMessages: Boolean
  isUsingInvertedEmailColours: Boolean
  fontSizeMultiplier: Float
  emailFormat: String
  preferredHoldMusic: String
  clientMutationId: String
}

"""Update user's password."""
type UpdatePassword {
  " The currently authenticated user. \n\n \n\nThis field requires the `Authorization` header to be set. \n\n"
  viewer: AccountUserType
}

input UpdatePasswordInput {
  """Old password"""
  oldPassword: String!

  """New password"""
  newPassword: String!

  """Confirm new password"""
  newPasswordConfirmed: String!
}

"""Regenerate the user's live secret key."""
type RegenerateSecretKey {
  " The currently authenticated user. \n\n \n\nThis field requires the `Authorization` header to be set. \n\n"
  viewer: AccountUserType
}

"The possible errors that can be raised are:\n\n- KT-CT-5413: Invalid data.\n- KT-CT-5414: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type UpdateUserMutation {
  possibleErrors: [PossibleErrorType]
  viewer: AccountUserType
}

input UpdateUserInput {
  givenName: String
  familyName: String

  """
  How the user would like us to address them (e.g. 'she/her', 'they/them'). Because this field is clearable, null and the empty string are treated differently; passing null or omitting the field leaves the value as-is, but explicitly passing an empty string clears this value.
  """
  pronouns: String
  email: String

  """
  Because this field is clearable, null and the empty string are treated differently; passing null or omitting the field leaves the value as-is, but explicitly passing an empty string clears this value.
  """
  mobile: String
  dateOfBirth: Date

  """
  Because this field is clearable, null and the empty string are treated differently; passing null or omitting the field leaves the value as-is, but explicitly passing an empty string clears this value.
  """
  landline: String

  """
  The user for whom to perform the update. This is only needed when using an Organisation role
  """
  userId: String

  """The user's title."""
  title: String
}

type RegisterPushNotificationBinding {
  pushNotificationBinding: PushNotificationBindingType
}

"""Represents a pairing of a single app installation to an account user."""
type PushNotificationBindingType {
  id: ID!
  messages(offset: Int, before: String, after: String, first: Int, last: Int): PrintMessageTypeConnection!
  user: AccountUserType!
  token: String!
  application: NotifiableApplicationType!
  registeredAt: DateTime!
  expiresAt: DateTime!
}

"""Represents an application that can receive push notifications."""
type NotifiableApplicationType {
  id: ID!

  """Human readable name for the app."""
  name: String!

  """Bundle ID or package name of the app."""
  bundleId: String!
  service: NotifiableApplicationService!
  externalProvider: NotifiableApplicationExternalProvider!

  """
  Project ID used in push notification delivery service. (Currently: AWS Pinpoint)
  """
  externalProjectId: String!
  description: String!
  pushNotificationBindings: [PushNotificationBindingType!]!
}

"""An enumeration."""
enum NotifiableApplicationService {
  """Android (GCM)"""
  GCM

  """iOS (APNs)"""
  APNS

  """iOS Sandbox (APNs Sandbox)"""
  APNS_SANDBOX
}

"""An enumeration."""
enum NotifiableApplicationExternalProvider {
  """AWS Pinpoint"""
  PINPOINT
}

input RegisterPushNotificationBindingInput {
  """Device push notification token."""
  token: String!

  """
  Register a push notification binding. A push notification binding connects an account user to a specific application running on a specific device through a 'registration token' (Android) or 'device token' (iOS). Using this binding we can send push notifications to the account user's devices.
  """
  bundleId: String!
}

"The possible errors that can be raised are:\n\n- KT-CT-5411: Invalid token or no push notification binding found for the given account user.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type DeletePushNotificationBinding {
  possibleErrors: [PossibleErrorType]
  status: DeletePushNotificationBindingOutput
}

enum DeletePushNotificationBindingOutput {
  SUCCESSFUL
  FAILED
}

input DeletePushNotificationBindingInput {
  """Device push notification token."""
  token: String!
}

"Create metadata on an object.\n\nThe possible errors that can be raised are:\n\n- KT-CT-8412: Invalid data.\n- KT-CT-8414: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateMetadata {
  possibleErrors: [PossibleErrorType]
  metadata: Metadata
}

"Update existing metadata on an object.\n\nThe possible errors that can be raised are:\n\n- KT-CT-8413: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type UpdateMetadata {
  possibleErrors: [PossibleErrorType]
  metadata: Metadata
}

type MeasurementType implements MeasurementInterface {
  source: String!

  "\nThis type will return more granular data about the measurement.\n\nFor example, it includes a `typed_source` object that returns typed information about the source of the measurement.\n"
  metaData: MeasurementsMetadataOutput
  value: Decimal!
  unit: String!
  readAt: DateTime!
}

type IntervalMeasurementType implements MeasurementInterface {
  source: String!

  "\nThis type will return more granular data about the measurement.\n\nFor example, it includes a `typed_source` object that returns typed information about the source of the measurement.\n"
  metaData: MeasurementsMetadataOutput
  value: Decimal!
  unit: String!
  readAt: DateTime!
  startAt: DateTime!
  endAt: DateTime!
  durationInSeconds: Int!
  accumulation: Decimal
}

type PropertySearchResult {
  """A score representing the degree of confidence for a match."""
  score: Decimal!

  """The matched property."""
  property: PropertyType!
}

"The possible errors that can be raised are:\n\n- KT-CT-9403: Received an invalid portfolioId.\n- KT-CT-9404: Received an invalid accountUserId.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreatePortfolioUserRole {
  possibleErrors: [PossibleErrorType]

  """The created role for a user in association with a portfolio."""
  portfolioUserRole: PortfolioUserRoleType
}

input CreatePortfolioUserRoleInput {
  """The portfolio to associate the user with."""
  portfolioId: ID!

  """The user to associate with the portfolio."""
  accountUserId: ID!

  """
  The role to assign to the user. If not provided the default role will be used.
  """
  role: PortfolioUserRoleEnum = null
}

"Generate a PAN (Payment Allocation Number) for a smart meter. This can be used to add credit to the meter in a shop,\nif the meter is in prepayment mode.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4045: Meter is not in prepayment mode.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
type GeneratePaymentAllocationNumber {
  possibleErrors: [PossibleErrorType]

  """
  The Payment Allocation Number routes payments made via a PSP (Payment Service Provider) to this device.
  """
  pan: String!
}

"""Identifies a SMETS2 meter (or a SMETS1 E&A'd meter)."""
input SmartMeterDeviceInput {
  """Account number of customer."""
  accountNumber: String!

  """Electricity or gas meter device ID."""
  deviceId: String!
}

type CampaignType {
  name: String!
  slug: String!
  expiryDate: Date
}

"""Quote a given account on a campaign offer."""
type QuoteCampaignOffer {
  quoteCode: String
}

input QuoteCampaignOfferInput {
  """Account number."""
  accountNumber: String!

  """Property to quote on."""
  propertyId: Int!

  """Slug of campaign to quote on."""
  campaignSlug: String!
}

"""
Replace the given agreement with the given product.

TODO: Move this outside of plugin as it is applicable to the wider domain.
"""
type ReplaceAgreement {
  account: AccountInterface
}

interface AccountInterface {
  """The brand of the account."""
  brand: String

  """The current status of the account."""
  status: AccountStatus

  """The current account balance."""
  balance(
    """
    If this variable is set to true, the balance will be calculated based on the sum of balances on all ledgers configured to contribute to this account's balance. Otherwise, only the main ledger's balance will be fetched (legacy behaviour). If you are unsure, set this value to true.
    """
    includeAllLedgers: Boolean = false
  ): Int!

  """The current account overdue balance."""
  overdueBalance: Int

  """Unique reference number from a 3rd party enrolment."""
  urn: String

  """The billing name of the account."""
  billingName: String

  """The billing sub name of the account."""
  billingSubName: String

  """The billing email of the account."""
  billingEmail: String

  """The billing address of the account."""
  billingAddress: String
  billingAddressLine1: String
  billingAddressLine2: String
  billingAddressLine3: String
  billingAddressLine4: String
  billingAddressLine5: String
  billingAddressPostcode: String
  billingCountryCode: String
  billingDeliveryPointIdentifier: String

  """List of billing address lines."""
  splitBillingAddress: [String]

  "\nThe billing address of this account, stored in the new\nlibaddressinput-based format.\n\nNote that `name` and `organization` are very unlikely to be\nsupplied here; the `billing_name` field on the account\nitself is generally used for that purpose instead.\n"
  address: RichAddressType

  """A code that uniquely identifies the account."""
  number: String

  """The portfolio this account is linked to."""
  portfolio: PortfolioType

  """
  Ledgers provide the foundation of bookkeeping functionality. Similar to a bank account, they allow us to keep track of financial activity on a particular customer account.
  """
  ledgers(
    """The ledger to return"""
    ledgerId: ID
  ): [LedgerType]

  """Whether the account can request a credit refund."""
  canRequestRefund: Boolean

  """Details about the eligibility status for requesting a refund."""
  requestRefundEligibility: RequestRefundEligibilityType

  """The payments made into an account from a payment instruction."""
  payments(
    """
    **WARNING: Will be mandatory in future versions**
    
    The ledger to return payments from.
    """
    ledgerId: String
    status: AccountPaymentStatusOptions

    """Filter for payments that were taken for a particular reason."""
    reason: PaymentReasonOptions

    """
    Whether to include payment promises (of any kind: made, broken or fulfilled) or not. The default is to include them.
    """
    includePromises: Boolean = true
    before: String
    after: String
    first: Int
    last: Int
  ): AccountPaymentConnectionTypeConnection

  """The repayments that have been requested for this account."""
  repayments(
    """Only return repayments whose status matches one of these statuses"""
    statuses: [AccountRepaymentStatusOptions]
    before: String
    after: String
    first: Int
    last: Int
  ): AccountRepaymentConnectionTypeConnection

  """
  The schedules that describe how we would expect to take payments for an account on a given month.
  """
  paymentSchedules(
    activeOnDate: Date
    active: Boolean

    """
    If false, we remove the currently valid schedule if it has already fulfilled its purpose and will have no further impact on customer payments, along with any schedules which are not valid from today.
    """
    includeDormant: Boolean = true

    """The ledger to return transactions from."""
    ledgerType: Int

    """The ledger id to return the payment schedules from."""
    ledgerId: ID
    reason: PaymentScheduleReasonOptions
    before: String
    after: String
    first: Int
    last: Int
  ): PaymentScheduleConnectionTypeConnection

  """
  A list displaying the payment forecast for an account. The list starts from today's date (inclusive).
  """
  paymentForecast(
    """The end date to retrieve forecasts for. This end date is inclusive."""
    dateTo: Date!

    """
    The ledger to return payment forecasts from. Defaults to the main ledger when no ID is passed.
    """
    ledgerId: Int
  ): [PaymentForecastType] @deprecated(reason: "The 'paymentForecast' field is deprecated.\n\nPlease use 'paginatedPaymentForecast' instead.\n\n- Marked as deprecated on 2024-01-03.\n- Will be removed on 2025-01-01.")

  """
  Paginated payment forecasts for an account. Starts from today's date (inclusive). The interface supports `last` but does not guarantee 'lastness'.
  """
  paginatedPaymentForecast(
    """The end date to retrieve forecasts for. This end date is inclusive."""
    dateTo: Date

    """
    The ledger to return payment forecasts from. Defaults to the main ledger when no ID is passed.
    """
    ledgerId: Int
    before: String
    after: String
    first: Int
    last: Int
  ): PaymentForecastConnectionTypeConnection

  """The referrals created by this account."""
  referrals(before: String, after: String, first: Int, last: Int): ReferralConnectionTypeConnection

  """Number of referrals created by this account."""
  referralsCreated: Int

  """The rewards applied to this account."""
  rewards: [RewardType]

  """The referral schemes currently active for this account."""
  activeReferralSchemes: ReferralSchemeTypes

  """Fetch transactions that have taken place on the account."""
  transactions(
    """Include only these specific transaction types in the result."""
    transactionTypes: [TransactionTypeFilter] = []

    """Exclude these specific transaction types from the result."""
    transactionTypesExcluded: [TransactionTypeFilter] = []

    """The ledger to return transactions from."""
    ledgerId: Int

    """
    In a multi-ledger scenario, include all ledgers' transactions if `true`. Analogously, if `false` and no `ledgerId` argument is present, the list of transactions defaults to the main ledger (legacy behaviour).
    """
    includeAllLedgers: Boolean

    "\nOptional date representing the beginning of the postedDate range filter.\nThis date value is inclusive.\n"
    fromDate: Date

    "\nOptional date representing the end of the postedDate range filter.\nThis date value is exclusive.\n"
    toDate: Date

    """The order in which to return the transactions."""
    orderBy: TransactionsOrderBy = POSTED_DATE_DESC
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
  ): TransactionConnectionTypeConnection
  provisionalTransactions(before: String, after: String, first: Int, last: Int): ProvisionalTransactionConnectionTypeConnection

  """Fetch annual statements for the account."""
  annualStatements(before: String, after: String, first: Int, last: Int): AnnualStatementConnectionTypeConnection

  """Fetch issued bills (invoices/statements) for the account."""
  bills(
    """Include bills without PDFs."""
    includeBillsWithoutPDF: Boolean = false

    "\nInclude open statements. This flag needs to be used along with\nincludeBillsWithoutPDF=false otherwise results will prove unexpected.\n"
    includeOpenStatements: Boolean = false

    """Include held statements within the results."""
    includeHeldStatements: Boolean = false

    """Include pre-Kraken / historical statements within the results."""
    includeHistoricStatements: Boolean = true

    """Only include bills emailed to the current user's email."""
    onlyCurrentEmail: Boolean = false

    """
    Optional date representing the beginning of the search results. This date value is inclusive.
    """
    fromDate: Date

    """
    Optional date representing the end of the search results. This date value is exclusive.
    """
    toDate: Date

    """
    Optional date representing the beginning of the search results based on issued date. This date value is inclusive.
    """
    issuedFromDate: Date

    """
    Optional date representing the end of the search results based on issued date. This date value is exclusive.
    """
    issuedToDate: Date

    """The order in which to return the bills."""
    orderBy: BillsOrderBy = FROM_DATE_DESC
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
  ): BillConnectionTypeConnection

  """Information about the account's billing cycle."""
  billingOptions: BillingOptionsType

  """Fetch a specific issued bill (invoice/statement) for the account."""
  bill(id: ID!, billType: BillTypeEnum): BillInterface

  """The direct debit instructions of the account"""
  directDebitInstructions(
    """Filter the direct debit instructions by status"""
    statuses: [DirectDebitInstructionStatus]
    before: String
    after: String
    first: Int
    last: Int
  ): DirectDebitInstructionConnectionTypeConnection

  """The account events that were recorded for the account."""
  events(
    """Filter the account events by their type."""
    eventTypes: [AccountEventType]
    before: String
    after: String
    first: Int
    last: Int
  ): AccountEventConnectionTypeConnection

  """
  Applications by this account to become our customer. More recent applications will be listed first.
  """
  applications(before: String, after: String, first: Int, last: Int): AccountApplicationConnectionTypeConnection

  """The type of account."""
  accountType: AccountTypeChoices

  """The company type of a business account."""
  businessType: BusinessTypeOptions @deprecated(reason: "The 'businessType' field is deprecated.\n\nUse `business.businessType` instead\n\n- Marked as deprecated on 2022-03-09.\n- Will be removed on 2024-01-01.")

  """Business info related to a business account."""
  business: BusinessType

  """The method the account has specified they prefer we contact them"""
  commsDeliveryPreference: CommsDeliveryPreference
  communicationDeliveryPreference: String @deprecated(reason: "The 'communicationDeliveryPreference' field is deprecated.\n\nUse `commsDeliveryPreference` instead\n\n- Marked as deprecated on 2022-05-27.\n- Will be removed on 2024-01-01.")

  """Account references linked to this account."""
  references: [AccountReferenceType]

  """
  Files attached to this account. Only available if categories defined in settings.
  """
  fileAttachments: [AccountFileAttachment]

  """
  The maximum amount a customer is allowed to request as a refund and the reason why that's the maximum amount.
  """
  maximumRefund: MaximumRefundType

  """The campaigns associated with an account."""
  campaigns: [AccountCampaignType]

  """
  True if there is an active Hardship Agreement for this account. False otherwise.
  """
  isInHardship: Boolean

  """
  List of active hardship agreements for the user when is_in_hardship is True.
  """
  activeHardshipAgreements: [HardshipAgreementType]

  """Notes for the account."""
  notes: [AccountNoteType]

  """Contribution agreements for account."""
  contributionAgreements: [ContributionAgreementType]

  """Debt collection proceedings for account."""
  debtCollectionProceedings: [DebtCollectionProceedingType]

  """The datetime that the account was originally created."""
  createdAt: DateTime
}

enum AccountStatus {
  """
  A pending account is one that has been created but no registrations have started.
  """
  PENDING

  """Account requires processes to be completed before supply can be set up"""
  INCOMPLETE

  """Withdrawn before supply started"""
  WITHDRAWN

  """Supply could have started, be ongoing or ended."""
  ACTIVE

  """
  An error occurred when we tried to enroll a meter point. This may be deprecated in future in favour of exposing this through enrollment property of a meter point.
  """
  ENROLMENT_ERROR

  """
  Meter point enrollment was rejected. This may be deprecated in future in favour of exposing this through enrollment property of a meter point.
  """
  ENROLMENT_REJECTED

  """Dormant. Users should not be able to log into dormant accounts."""
  DORMANT

  """Void. Account created in error."""
  VOID
}

"\nA postal address.\n\nThis data model is based on the structure used by Google's\n[libaddressinput library](https://github.com/google/libaddressinput)&mdash;so\nyou can use it, or other libraries that use its data model\nand reference data, to accept input.\n\nAll fields can be blank, except for ``country`` which must\nalways be supplied.\n"
type RichAddressType {
  """A personal name."""
  name: String

  """The name of a business or organisation."""
  organization: String

  "\nThe 'street address' component.\n\nThis value can (and often will) contain newline characters\nwhen appropriate.\n\nIn some cases, data may appear in this field instead of the\nbelow fields; e.g. a UK post town name may appear here\ninstead of in the `dependent_locality` field. This happens\nwhen data has been migrated from a legacy format, and that\nformat had insufficient metadata to determine the\nappropriate field.\n\nIf `structured_street_address` is also set, the value of\nthis field will be a string generated from that value.\n"
  streetAddress: String

  "\nThe 'street address' component, in a structured format.\n\nThis field stores the same value as `street_address`, but\nwith more detail; for instance, instead of `123 Example\nStreet` it might be `{'street_number': '123',\n'street_name': 'Example', 'street_type': 'Street'}`. In\nmany cases this will be blank; we only use this field for\nKrakens where we need to supply this level of granularity\nto some third-party service, like a bulk mail provider.\n\nThe exact structure of this value depends on the country _of\nthe address_, which is not necessarily the same as the\ncountry this Kraken is configured to serve. For addresses\noutside of the countries listed below, this field will be\nleft blank.\n\n### `AU`: Australia\n\nThe following keys may be present; all are optional. All\nkeys have string values, and their meaning is the same as\ntheir aseXML counterparts. (Note that, unlike aseXML, all\nkeys are provided at the top level, rather than being\nnested.)\n\n- `flat_or_unit_type`\n- `flat_or_unit_number`\n- `floor_or_level_type`\n- `floor_or_level_number`\n- `building_or_property_name`\n- `location_descriptor`\n- `lot_number`\n- `house_number_1`\n- `house_number_suffix_1`\n- `house_number_2`\n- `house_number_suffix_2`\n- `street_name`\n- `street_type`\n- `street_suffix`\n- `postal_delivery_type`\n- `postal_delivery_number_prefix`\n- `postal_delivery_number_value`\n- `postal_delivery_number_suffix`\n"
  structuredStreetAddress: GenericScalar

  "\nUK dependent localities, or neighbourhoods or boroughs in\nsome other locations.\n"
  dependentLocality: String

  "\nCity or town portion of an address, e.g. US city, AU\nsuburb/town, IT comune, UK post town.\n"
  locality: String

  "\nTop-level administrative subdivision, e.g. US state, AU\nstate/territory, IT region, JP prefecture.\n\n### `AU`: Australia\n\nThis must be one of `NSW`, `VIC`, `QLD`, `TAS`, `ACT`, `SA`,\n`NT`, `WA`. For addresses not within these locations, use\nthe value that Australia Post uses, e.g. `ACT` for the\nJervis Bay Territory or `WA` for Christmas Island.\n"
  administrativeArea: String

  "\nPostal code (ZIP code in the US).\n"
  postalCode: String

  "\nSorting code, e.g. FR CEDEX code. This field is not used in many countries.\n"
  sortingCode: String

  "\nISO 3166-1 alpha-2 code of the country this address belongs\nto, e.g. `AU`, `GB`.\n"
  country: String

  "\nIdentifier used by the local postal service for this\naddress, e.g. AU DPID, GB postcode + Delivery Point Suffix,\nUS Zip-9 + Delivery Point.\n\nThis is the value that gets encoded in the barcode printed\non the envelope by large-volume bulk mail providers.\n"
  deliveryPointIdentifier: String
}

"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar

type PortfolioType {
  id: ID!
  number: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  billingName: String
  collectiveBilling: Boolean!

  """Operations team for this portfolio."""
  operationsTeam: OperationsTeamType
}

type OperationsTeamType {
  id: Int
  teamName: String
  isOffline: Boolean
  isAcceptingCalls: Boolean
}

"""
Ledgers provide the foundation of Krakens bookkeeping functionality. Similar to a bank account, they allow us to keep track of financial activity on a particular Kraken account.
"""
type LedgerType implements LedgerInterface {
  id: ID

  """The display name of the ledger."""
  name: String

  """The ledger type code."""
  ledgerType: String

  """The current balance on the ledger in minor units of currency."""
  balance: Int

  """
  The amount owed from the customer perspective. A positive value implies the customer owes the business, while a negative amount implies the customer is in credit.
  """
  amountOwedByCustomer: Int

  """Whether this ledger's balance contributes to the account's balance."""
  affectsAccountBalance: Boolean

  """
  A statement is a billing document that contains all entries on a ledger during a period of time. A customer can understand how their ledger's balance has changed by looking at each statement in series.
  """
  statements(
    """The id of billing document."""
    statementId: Int
    before: String
    after: String
    first: Int
    last: Int
  ): StatementBillingDocumentConnectionTypeConnection

  """
  An invoice is a bill that contains individual transactions  (i.e. charges, credits, payments, and repayments). These may come from any period of time.
  """
  invoices(
    """The id of the invoice."""
    invoiceId: Int
    before: String
    after: String
    first: Int
    last: Int
  ): InvoiceBillingDocumentConnectionTypeConnection
  transactions(
    """Return these transaction types only."""
    transactionTypes: [TransactionTypeFilter] = []
    before: String
    after: String
    first: Int
    last: Int
  ): TransactionConnectionTypeConnection

  """Repayment requests for a given ledger."""
  repaymentRequests(before: String, after: String, first: Int, last: Int): RepaymentRequestConnectionTypeConnection

  """Refund requests for a given ledger."""
  refundRequests(before: String, after: String, first: Int, last: Int): RefundRequestConnectionTypeConnection
  paymentAdequacy: PaymentAdequacyDetailsType
}

interface LedgerInterface {
  id: ID

  """The display name of the ledger."""
  name: String
  ledgerType: String

  """The current balance on the ledger in minor units of currency."""
  balance: Int

  """
  The amount owed from the customer perspective. A positive value implies the customer owes the business, while a negative amount implies the customer is in credit.
  """
  amountOwedByCustomer: Int

  """Whether this ledger's balance contributes to the account's balance."""
  affectsAccountBalance: Boolean

  """
  A statement is a billing document that contains all entries on a ledger during a period of time. A customer can understand how their ledger's balance has changed by looking at each statement in series.
  """
  statements(before: String, after: String, first: Int, last: Int): StatementBillingDocumentConnectionTypeConnection

  """
  An invoice is a bill that contains individual transactions  (i.e. charges, credits, payments, and repayments). These may come from any period of time.
  """
  invoices(before: String, after: String, first: Int, last: Int): InvoiceBillingDocumentConnectionTypeConnection
  transactions(
    """Return these transaction types only."""
    transactionTypes: [TransactionTypeFilter] = []
    before: String
    after: String
    first: Int
    last: Int
  ): TransactionConnectionTypeConnection

  """Repayment requests for a given ledger."""
  repaymentRequests(before: String, after: String, first: Int, last: Int): RepaymentRequestConnectionTypeConnection

  """Refund requests for a given ledger."""
  refundRequests(before: String, after: String, first: Int, last: Int): RefundRequestConnectionTypeConnection
  paymentAdequacy: PaymentAdequacyDetailsType
}

"""
A statement is a billing document that contains all entries on a ledger during a period of time. A customer can understand how their ledger's balance has changed by looking at each statement in series.
"""
type StatementBillingDocumentConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [StatementBillingDocumentConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `StatementBillingDocumentConnectionType` and its cursor.
"""
type StatementBillingDocumentConnectionTypeEdge {
  """The item at the end of the edge"""
  node: StatementBillingDocumentType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
A statement is a billing document that contains all entries on a ledger during a period of time. A customer can understand how their ledger's balance has changed by looking at each statement in series.
"""
type StatementBillingDocumentType {
  id: Int

  """
  The unique reference of the statement that can be used for identifying the statement externally.
  """
  identifier: String

  """The start of the statement's period."""
  startAt: DateTime!

  """The end of the statement's period."""
  endAt: DateTime!

  """The date and time the statement was sent to the customer."""
  firstIssuedAt: DateTime

  """The earliest charge date of the statement."""
  earliestChargeAt: DateTime

  """The latest charge date of the statement."""
  latestChargeAt: DateTime

  """URL to the PDF of the statement."""
  pdfUrl: String

  """Billing document that annuls this statement."""
  annulledBy: AnnulmentBillingDocumentType
}

"""
An annulment is a billing document that annuls another billing document.
"""
type AnnulmentBillingDocumentType {
  id: Int!

  """ID of the billing document annulled by this annulment."""
  annulledBillingDocumentId: Int!

  """First time the annulment was issued."""
  firstIssued: DateTime

  """URL to the PDF of the annulment."""
  pdfUrl: String
}

"""
An invoice is a bill that contains individual transactions  (i.e. charges, credits, payments, and repayments). These may come from any period of time.
"""
type InvoiceBillingDocumentConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [InvoiceBillingDocumentConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `InvoiceBillingDocumentConnectionType` and its cursor.
"""
type InvoiceBillingDocumentConnectionTypeEdge {
  """The item at the end of the edge"""
  node: InvoiceBillingDocumentType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
An invoice is a bill that contains individual transactions  (i.e. charges, credits, payments, and repayments). These may come from any period of time.
"""
type InvoiceBillingDocumentType {
  id: Int

  """First time the invoice was issued."""
  firstIssued: DateTime

  """URL to the PDF of the Invoice."""
  pdfUrl: String

  """Billing document that annuls this invoice."""
  annulledBy: AnnulmentBillingDocumentType
}

type TransactionConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [TransactionConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""A Relay edge containing a `TransactionConnectionType` and its cursor."""
type TransactionConnectionTypeEdge {
  """The item at the end of the edge"""
  node: TransactionType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
Transactions are a record of money being added or subtracted from the overall account balance
"""
interface TransactionType {
  id: ID
  postedDate: Date

  """The date time when the transaction is created."""
  createdAt: DateTime

  """Unique identifier of the account the transaction belongs to."""
  accountNumber: String

  """
  Gross amount including tax (when payable). Refer to the `amounts` field for a breakdown of this information.
  """
  amount: Int @deprecated(reason: "The 'amount' field is deprecated.\n\nUse `amounts` instead for a breakdown of the relevant net, tax, and gross amounts.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-06-01.")

  """
  The net, tax and gross amounts for the transaction. Note: for payments and repayments, only the net amount is returned.
  """
  amounts: TransactionAmountType

  """
  The customer's resulting balance after this transaction has been applied, in the smallest unit of currency.
  """
  balanceCarriedForward: Int

  """Deprecated."""
  isCredit: Boolean @deprecated(reason: "The 'isCredit' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """Deprecated."""
  isAccountCharge: Boolean @deprecated(reason: "The 'isAccountCharge' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """Deprecated."""
  isAccountPayment: Boolean @deprecated(reason: "The 'isAccountPayment' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.  Returns False if a statement is not linked with the transaction.
  """
  isHeld: Boolean

  """
  Whether this transaction has been issued on any billing document.Note: Look for the most recently issued transaction instead of looking through all transactions as some accounts may have initial transactions that were not issued.This will return False if the transaction is not associated with any billing documents.
  """
  isIssued: Boolean
  title: String

  """
  The unique identifier for the most recent billing document linked with the transaction.Note: a transaction may be linked with multiple documents, but this field will only return the identifier for the most recent billing document.
  """
  billingDocumentIdentifier: ID

  """Returns None if a statement is not linked with the transaction."""
  statementId: ID @deprecated(reason: "The 'statementId' field is deprecated.\n\nUse `billingDocumentIdentifier` instead.\n\n- Marked as deprecated on 2023-11-30.\n- Will be removed on 2024-06-01.")
  isReversed: Boolean!

  """Returns True if the transaction is linked with a statement."""
  hasStatement: Boolean

  """
  Returns the note field value for the transaction, which contains additional info.
  """
  note: String
}

type TransactionAmountType {
  """The net amount (in minor currency units)."""
  net: Int

  """The amount of tax (in minor currency units)."""
  tax: Int

  """The gross amount (in minor currency units)."""
  gross: Int
}

"""
Transaction types which will be included or excluded, depending on the input argument.
"""
enum TransactionTypeFilter {
  """
  For filtering/excluding energy charge transactions: Gas or Electricity.
  """
  ENERGY_CHARGES

  """For filtering/excluding imported charge transactions."""
  IMPORTED_CHARGES

  """For filtering/excluding imported credit transactions."""
  IMPORTED_CREDITS

  """For filtering/excluding imported repayment transactions."""
  IMPORTED_REPAYMENTS

  """For filtering/excluding imported payment transactions."""
  IMPORTED_PAYMENTS
}

type RepaymentRequestConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [RepaymentRequestConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `RepaymentRequestConnectionType` and its cursor.
"""
type RepaymentRequestConnectionTypeEdge {
  """The item at the end of the edge"""
  node: RepaymentRequestType

  """A cursor for use in pagination"""
  cursor: String!
}

type RepaymentRequestType {
  """The ID of the repayment request."""
  requestId: String

  """The amount of money requested."""
  amount: Int

  """Classifier code for repayment reason."""
  reasonCode: String

  """The method by which the money will be transferred to the customer."""
  method: RepaymentMethod

  """
  The payment instruction, if any, associated with the repayment request.
  """
  instruction: PaymentInstructionType

  """The current status of the repayment request."""
  status: RepaymentRequestStatus
}

"\n    Methods by which repayments can be sent to the customer.\n    "
enum RepaymentMethod {
  BANK_TRANSFER
  CHEQUE
  CARD
}

"""Payment Instructions"""
type PaymentInstructionType {
  id: ID!
  status: String!
  sortCode: String!
  iban: String!
  accountHolder: String!
  instructionType: String
  cardPaymentNetwork: String
  cardExpiryMonth: Int
  cardExpiryYear: Int
  bankCode: String
  accountType: String
  validFrom: DateTime!

  """
  The provider to use for this DDI. Most accounts would have SmartDebit as their provider, Iresa customers use GoCardless
  """
  vendor: String!
  cardNumber: String!
  cardType: String

  """A masked reference to a recurring payment method."""
  maskedAccountIdentifier: String
}

"\n    Possible status' for a repayment (or refund) request\n    "
enum RepaymentRequestStatus {
  REQUESTED
  ACCEPTED
  CANCELLED
  REJECTED
}

type RefundRequestConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [RefundRequestConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `RefundRequestConnectionType` and its cursor.
"""
type RefundRequestConnectionTypeEdge {
  """The item at the end of the edge"""
  node: RefundPaymentRequestType

  """A cursor for use in pagination"""
  cursor: String!
}

type RefundPaymentRequestType {
  """The ID of the refund request."""
  requestId: ID

  """The amount of money requested."""
  amount: Int

  """The payment which is being refunded."""
  payment: AccountPaymentType

  """Internal code for the reason the refund is being requested."""
  reasonCode: String

  """The current status of the refund request."""
  status: RepaymentRequestStatus
}

type AccountPaymentType {
  id: ID!

  """Amount of payment in pence"""
  amount: BigInt!

  """The date this payment is scheduled to be debited"""
  paymentDate: Date!
  reference: String!

  """The transaction type of the payment."""
  transactionType: AccountPaymentTransactionTypeChoices

  """The current status of the payment"""
  status: AccountPaymentStatusOptions

  """Surcharge amount generated by this payment."""
  surchargeAmount: Int
}

"""
The `BigInt` scalar type represents non-fractional whole numeric values.
`BigInt` is not constrained to 32-bit like the `Int` type and thus is a less
compatible type.
"""
scalar BigInt

"""An enumeration."""
enum AccountPaymentTransactionTypeChoices {
  DD_FIRST_COLLECTION
  DD_REGULAR_COLLECTION
  DD_RE_PRESENTATION
  DD_FINAL_COLLECTION
  CREDIT_CARD
  DEBIT_CARD
  PREPAID_CARD
  AUSTRALIA_POST
  BACS_DEPOSIT
  BPAY
  BPOINT
  BRISTOL_POUND
  CASH
  CENTREPAY
  CHEQUE
  EAPA_VOUCHER
  ERRONEOUS_PAYMENT
  HEEAS
  IVR
  TRANSFER_FROM_SAP
  FUEL_DIRECT
  EFT
  URGS
  AGENCY
  PAYPOINT_CASH
  PAYPOINT_CARD
  PAYPOINT_CHEQUE
  ALLPAY_CASH
  ALLPAY_CARD
  ALLPAY_CHEQUE
  PAYZONE
  POST_OFFICE_CASH
  POST_OFFICE_CHEQUE
  POST_OFFICE_SAVINGS_STAMPS
  POST_OFFICE_CARD
  DCA_COLLECTION
  PREPAY_KEY
  PREPAY_CARD
  PREPAY_TOKEN
  PREPAY_SMART
  PAYMENT_FEE
  FAILED_REPAYMENT_REVERSAL
  KONBINI
  PAGOPA_NOTICE
  UNKNOWN
}

"""An enumeration."""
enum AccountPaymentStatusOptions {
  """
  The payment has been scheduled for collection and the customer has been notified. While a payment is scheduled, it can still be deleted.
  """
  SCHEDULED

  """The payment has been submitted. From this point it cannot be altered."""
  PENDING

  """
  The payment has been approved by the merchant and added to your Kraken account.
  """
  CLEARED

  """The payment failed permanently."""
  FAILED

  """
  A payment promise has been created, but it has not left the customers bank account.
  """
  PROMISED

  """
  The payment has been made successfully and applied to the Kraken balance.
  """
  FULFILLED

  """The payment promise has been broken."""
  PROMISE_BROKEN

  """Payments made in a previous system and then imported into Kraken."""
  HISTORIC

  """
  Third Party payments are those recorded for financial purposes in a different system but should be added to statements.
  """
  THIRD_PARTY

  """
  The initial state of a payment in Kraken. It should be scheduled with a payment vendor in the future.
  """
  REQUESTED

  """This payment was deleted. From this point it cannot be altered."""
  DELETED
}

"""
Payment adequacy adjusts fixed payment schedules to maintain a healthy ledger balance over a year.
"""
type PaymentAdequacyDetailsType {
  """
  This ledger will be exempt from default Payment Adequacy. This may mean that it is completely exempt, or handled with special rules.
  """
  isCurrentlyExempt: Boolean
}

type RequestRefundEligibilityType {
  """Whether the account can request a refund."""
  canRequestRefund: Boolean!

  """The reason why a refund cannot be requested."""
  reason: String
}

type AccountPaymentConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AccountPaymentConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `AccountPaymentConnectionType` and its cursor.
"""
type AccountPaymentConnectionTypeEdge {
  """The item at the end of the edge"""
  node: AccountPaymentType

  """A cursor for use in pagination"""
  cursor: String!
}

enum PaymentReasonOptions {
  BALANCE_THRESHOLD_CROSSED
  BILL_ISSUED
  PAYMENT_PLAN
  REGULAR_SCHEDULE
}

type AccountRepaymentConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AccountRepaymentConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `AccountRepaymentConnectionType` and its cursor.
"""
type AccountRepaymentConnectionTypeEdge {
  """The item at the end of the edge"""
  node: AccountRepaymentType

  """A cursor for use in pagination"""
  cursor: String!
}

type AccountRepaymentType {
  id: ID!

  """Amount of payment in pence"""
  amount: BigInt!

  """The date this payment is scheduled to be debited"""
  paymentDate: Date!

  """The current status of the repayment"""
  status: AccountRepaymentStatusOptions
}

"""An enumeration."""
enum AccountRepaymentStatusOptions {
  """The request for a repayment has been received but not actioned yet."""
  REQUESTED

  """The repayment has been approved but not made yet."""
  APPROVED

  """
  The payment has been submitted to the merchant. It is still possible for this repayment to fail.
  """
  SUBMITTED

  """
  The repayment failed permanently. This could be because of technical issues, or if the merchant rejects the payment for some reason. The payment will need to be retried by ops.
  """
  FAILED

  """
  The repayment has been made to the merchant to be sent to the customer. This is a terminal state, we don't get any further confirmation.
  """
  PAID

  """
  Third Party payments are those recorded for financial purposes in a different system but should be added to statements.
  """
  THIRD_PARTY

  """Payments made in a previous system and then imported into Kraken."""
  HISTORIC
}

type PaymentScheduleConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PaymentScheduleConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `PaymentScheduleConnectionType` and its cursor.
"""
type PaymentScheduleConnectionTypeEdge {
  """The item at the end of the edge"""
  node: PaymentScheduleType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
An object that represents when we have agreed to take payments from a payment instruction.
"""
type PaymentScheduleType {
  id: ID!

  """The supplementary ledger for this payment schedule, if it is on one"""
  supplementaryLedger: SupplementaryLedgerType
  validFrom: Date!
  validTo: Date

  """The reason the payment schedule was created."""
  reason: PaymentScheduleReasonOptions
  paymentHolidayReason: String!
  paymentDay: Int

  """The frequency of the payment schedule"""
  paymentFrequency: PaymentFrequencyOptions
  paymentFrequencyMultiplier: Int!
  paymentAmount: Int!
  paymentAdequacyAdjustment: Int
  paymentAdequacyAdjustmentExpiryDate: Date
  isVariablePaymentAmount: Boolean!

  """
  The sum of the payment adequacy contributions on the payment schedule that are expected to be taken before the debt repayment is complete.
  """
  totalDebtAmount: Int
  isPaymentHoliday: Boolean

  """The method of payment for the schedule."""
  scheduleType: ScheduleType
}

"""
Ledgers provide the foundation of Krakens bookkeeping functionality. Similar to a bank account, they allow us to keep track of financial activity on a particular Kraken account.
"""
type SupplementaryLedgerType implements SupplementaryLedgerInterface {
  id: ID

  """The display name of the ledger."""
  name: String
  ledgerType: String

  """The current final balance of the ledger in pence."""
  currentBalance: Int
  paymentAdequacy: PaymentAdequacyDetailsType
}

interface SupplementaryLedgerInterface {
  id: ID

  """The display name of the ledger."""
  name: String
  ledgerType: String

  """The current final balance of the ledger in pence."""
  currentBalance: Int
  paymentAdequacy: PaymentAdequacyDetailsType
}

"""An enumeration."""
enum PaymentScheduleReasonOptions {
  """The default value for usual account payments."""
  GENERAL_ACCOUNT_PAYMENT

  """
  A payment schedule created to take a payment around the supply start date of a meterpoint to help prevent accounts accruing debt.
  """
  SSD_PAYMENT

  """
  A payment schedule created to take the final payment when an account is closed.
  """
  FINAL_PAYMENT

  """
  A payment schedule created to take payments to pay back a debt. These schedules typically expire once the debt has been re-payed.
  """
  DEBT_REPAYMENT_PLAN
}

"""An enumeration."""
enum PaymentFrequencyOptions {
  """Weekly"""
  Weekly

  """Monthly"""
  Monthly

  """Planned"""
  Planned
}

"""An enumeration."""
enum ScheduleType {
  BACS_TRANSFER
  CARD_PAYMENT
  DIRECT_DEBIT
  PAYMENT_SLIP
}

type PaymentForecastType {
  paymentNumber: Int
  date: Date
  amount: Int

  """The payment method used for the forecasted payment."""
  method: ScheduleType
}

type PaymentForecastConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PaymentForecastConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `PaymentForecastConnectionType` and its cursor.
"""
type PaymentForecastConnectionTypeEdge {
  """The item at the end of the edge"""
  node: PaymentForecastType

  """A cursor for use in pagination"""
  cursor: String!
}

type ReferralConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReferralConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""A Relay edge containing a `ReferralConnectionType` and its cursor."""
type ReferralConnectionTypeEdge {
  """The item at the end of the edge"""
  node: ReferralType

  """A cursor for use in pagination"""
  cursor: String!
}

"""Details of an account referral"""
type ReferralType implements ReferralInterface {
  id: ID!
  paymentDate: Date

  """The type of reward scheme."""
  schemeType: ReferralSchemeTypeChoices
  referredUserName: String
  paymentStatus: String
  referredUserJoinDate: DateTime
  code: String

  """Payment amount given to the referred account in pence."""
  referredUserPaymentAmount: Int

  """Payment amount given to the referring account in pence."""
  referringUserPaymentAmount: Int

  """
  The payment amount in pence received by the referrer and the referee combined.
  """
  combinedPaymentAmount: Int
}

interface ReferralInterface {
  paymentDate: Date

  """The type of reward scheme."""
  schemeType: ReferralSchemeTypeChoices
  referredUserName: String
  paymentStatus: String
  referredUserJoinDate: DateTime
  code: String

  """Payment amount given to the referred account in pence."""
  referredUserPaymentAmount: Int

  """Payment amount given to the referring account in pence."""
  referringUserPaymentAmount: Int

  """
  The payment amount in pence received by the referrer and the referee combined.
  """
  combinedPaymentAmount: Int
}

"""An enumeration."""
enum ReferralSchemeTypeChoices {
  """Referral Reward."""
  REFERRAL_REWARD

  """Signup Reward."""
  SIGNUP_REWARD

  """Partner Reward."""
  PARTNER_REWARD

  """Promo Reward."""
  PROMO_REWARD

  """Legacy Referral."""
  LEGACY_REFERRAL
}

"\n            A reward is based on a scheme that an account has applied for in order to be\n            eligible for a discount. Examples can include signup, promo, or partner codes that\n            were applied to an account.\n            "
type RewardType implements RewardInterface {
  id: ID!
  paymentDate: Date

  """The type of reward scheme."""
  schemeType: ReferralSchemeTypeChoices

  """Reward amount given to the account in pence."""
  rewardAmount: Int

  """The status of the reward payment."""
  paymentStatus: ReferralStatusChoices
}

interface RewardInterface {
  paymentDate: Date

  """The type of reward scheme."""
  schemeType: ReferralSchemeTypeChoices

  """Reward amount given to the account in pence."""
  rewardAmount: Int

  """The status of the reward payment."""
  paymentStatus: ReferralStatusChoices
}

"""An enumeration."""
enum ReferralStatusChoices {
  """Pending."""
  Pending

  """Paid."""
  Paid

  """Cancelled."""
  Cancelled
}

type ReferralSchemeTypes {
  domestic: ReferralSchemeType
  business: ReferralSchemeType
  friendsAndFamily: ReferralSchemeType @deprecated(reason: "The 'friendsAndFamily' field is deprecated.\n\nPlease use domestic instead.\n\n- Marked as deprecated on 2020-03-05.\n- Will be removed on 2024-01-01.")
}

"""
A referral scheme is a way for one account to earn a reward for referring another. This is achieved by the referred account using a url (provided by the referring account) to sign up.
"""
type ReferralSchemeType {
  """
  A fully qualified url give people to create accounts referred by this scheme.
  """
  referralUrl: String

  """A referral url for display purposes."""
  referralDisplayUrl: String

  """The reward amount received by the referrer."""
  referrerRewardAmount: Int

  """The reward amount received by the referred party."""
  referredRewardAmount: Int

  """The reward amount received by the referrer and the referee combined."""
  combinedRewardAmount: Int

  """
  The number of loyalty points to be awarded to the referrer in addition to the reward amount.
  """
  loyaltyPointsBonus: Int

  """
  Whether the current account is eligible to be referred under this scheme.
  """
  canBeReferred: Boolean

  """The unique code for the scheme."""
  code: String

  """The given name of the person making the referral."""
  referrerGivenName: String

  """The family name of the person making the referral."""
  referrerFamilyName: String @deprecated(reason: "The 'referringFamilyName' field is deprecated.\n\nOnly make use of the referrerGivenName for privacy reasons.\n\n- Marked as deprecated on 2022-11-07.\n- Will be removed on 2023-01-07.")

  """Scheme type of the referral scheme."""
  schemeType: String
}

enum TransactionsOrderBy {
  POSTED_DATE_ASC
  POSTED_DATE_DESC
}

type ProvisionalTransactionConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ProvisionalTransactionConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `ProvisionalTransactionConnectionType` and its cursor.
"""
type ProvisionalTransactionConnectionTypeEdge {
  """The item at the end of the edge"""
  node: ProvisionalTransactionType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
A provisional transaction represents some debit or credit to or from a customer's account which we cannot yet finalise for some reason, but which is still useful to keep a note of, and display to the customer. Provisional transactions are purely to give guidance in the absence of finalised information. We therefore only return provisional transactions that have not been finalised. When a transaction is finalised, it is available through the `transactions` field.
"""
type ProvisionalTransactionType {
  id: ID!

  """
  A user readable string that indicates what this transaction relates to.
  """
  title: String

  """
  The amount in pence for this provisional transaction. It will be negative for charges, positive for credits.
  """
  amount: Int

  """The date at which the charge should be applied to the account."""
  date: Date
}

type AnnualStatementConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AnnualStatementConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `AnnualStatementConnectionType` and its cursor.
"""
type AnnualStatementConnectionTypeEdge {
  """The item at the end of the edge"""
  node: AnnualStatementType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
Annual statements that are sent to the account. They summarize important information about usage and tariffs.
"""
type AnnualStatementType {
  periodStartsAt: DateTime!
  periodEndsAt: DateTime!
  id: ID
  pdfUrl: String
}

"\n\nThis field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).\n\n"
type BillConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BillConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""A Relay edge containing a `BillConnectionType` and its cursor."""
type BillConnectionTypeEdge {
  """The item at the end of the edge"""
  node: BillInterface

  """A cursor for use in pagination"""
  cursor: String!
}

interface BillInterface {
  id: ID
  billType: BillTypeEnum
  fromDate: Date
  toDate: Date

  "Requesting this field generates a temporary URL at which bill is available.\n        This URL will expire after approximately an hour.  It is intended for redirection purposes,\n        NOT persistence in any form (e.g. inclusion in emails or the body of a web page).\n        This field can raise an error with errorClass NOT_FOUND if the bill document has not\n        been created/issued yet.\n\n\n        "
  temporaryUrl: String

  """The date the bill was sent to the customer."""
  issuedDate: Date
}

enum BillTypeEnum {
  STATEMENT
  INVOICE
  CREDIT_NOTE
  PRE_KRAKEN
}

enum BillsOrderBy {
  FROM_DATE_DESC
  ISSUED_DATE_DESC
}

"""Information about an account's billing schedule."""
type BillingOptionsType {
  """
  The day of the month on which the account's billing period should start.
  """
  periodStartDay: Int
  periodLength: AccountBillingOptionsPeriodLength
  periodLengthMultiplier: Int

  """
  If true, this account is billed on specific day of a regular cycle. If false, the billing schedule is flexible, depending on when meter readings are submitted.
  """
  isFixed: Boolean!

  """The date on which the current billing cycle started."""
  currentBillingPeriodStartDate: Date

  """
  The date on which the current billing cycle will end. Null if the account is on flexible billing.
  """
  currentBillingPeriodEndDate: Date

  """
  The next date on which this account will next be billed. This is the same as the start date for their next bill cycle. Null if the account is on flexible billing.
  """
  nextBillingDate: Date
}

"""An enumeration."""
enum AccountBillingOptionsPeriodLength {
  """Monthly"""
  MONTHLY

  """Quarterly"""
  QUARTERLY
}

type DirectDebitInstructionConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [DirectDebitInstructionConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `DirectDebitInstructionConnectionType` and its cursor.
"""
type DirectDebitInstructionConnectionTypeEdge {
  """The item at the end of the edge"""
  node: DirectDebitInstructionType

  """A cursor for use in pagination"""
  cursor: String!
}

"""Direct Debit Instructions"""
type DirectDebitInstructionType {
  id: ID!
  status: String!
  sortCode: String!
  iban: String!
  accountHolder: String!
  instructionType: String
  cardPaymentNetwork: String
  cardExpiryMonth: Int
  cardExpiryYear: Int

  """The last four digits of the account number."""
  lastFourDigitsOfAccountNumber: String @deprecated(reason: "The 'lastFourDigitsOfAccountNumber' field is deprecated.\n\nUse 'maskedAccountIdentifier' for a masked reference to the instruction.\n\n- Marked as deprecated on 2021-12-23.\n- Will be removed on 2024-01-01.")

  """A masked reference to a recurring payment method."""
  maskedAccountIdentifier: String

  """A masked version of the IBAN."""
  maskedIban: String
}

"""An enumeration."""
enum DirectDebitInstructionStatus {
  """The instruction is active and can be used to take payments."""
  ACTIVE

  """The instruction has not yet been set up."""
  PROVISIONAL

  """The instruction could not be set up with the vendor."""
  FAILED

  """The account for this instruction was closed."""
  ACCOUNT_CLOSED
}

type AccountEventConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AccountEventConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""A Relay edge containing a `AccountEventConnectionType` and its cursor."""
type AccountEventConnectionTypeEdge {
  """The item at the end of the edge"""
  node: AccountEvent

  """A cursor for use in pagination"""
  cursor: String!
}

union AccountEvent = EmailEventType | PrintEventType

type EmailEventType implements Node {
  """The ID of the object"""
  id: ID!
  eventType: String!
  occurredAt: DateTime!

  """
  Email message of the email event. Returns null for message's sent/received by other user's on the account
  """
  message: EmailType
}

"""An object with an ID"""
interface Node {
  """The ID of the object"""
  id: ID!
}

"""Represents an email communication"""
type EmailType {
  id: ID!
  channel: MessageChannel!
  toAddress: String!
  fromEmail: String!
  toNumber: String!
  fromNumber: String!
  templateCode: String!
  createdAt: DateTime!
  sentAt: DateTime

  """Attachments of the email message."""
  attachments: [EmailAttachmentType]

  """Subject line of the email message."""
  subject: String
  textBody: String
  htmlBody: String

  """Email sender"""
  sender: String

  """Email recipient"""
  recipient: String
}

"""An enumeration."""
enum MessageChannel {
  """Email"""
  EMAIL

  """SMS"""
  SMS

  """Print"""
  PRINT

  """Intercom"""
  INTERCOM

  """Junifer"""
  JUNIFER

  """Push Notification"""
  PUSH_NOTIFICATION
}

"""Represents a file to attach to a email message."""
type EmailAttachmentType {
  id: ID!
  filename: String!

  """
  Temporary URL at which the attachment is available. This URL will expire after approximately an hour. It is intended for redirection purposes, NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
  """
  temporaryUrl: String
}

type PrintEventType implements Node {
  """The ID of the object"""
  id: ID!
  eventType: String!
  occurredAt: DateTime!

  """Print message of the print event."""
  message: PrintMessageType
}

"""Represents a print communication."""
type PrintMessageType implements Node {
  """The ID of the object"""
  id: ID!
  templateCode: String!
  account: AccountType

  """Attachments of the message."""
  attachments: [PrintAttachmentType]

  """Comms that are marked as high priority."""
  highPriority: Boolean
}

"""
The account object can be one of several attached to a `Portfolio` (which usually has an `AccountUser` which is used to authenticate access to the `Portfolio`'s accounts). Typically a person has a single account attached to a portfolio and properties on the same account will appear on the same bill. Where separate bills are desired, multiple accounts  are created and added to the same portfolio of accounts.
"""
type AccountType implements AccountInterface {
  """A code that uniquely identifies the account."""
  number: String

  """The current status of the account."""
  status: AccountStatus
  id: ID!

  """
  The schedules that describe how we would expect to take payments for an account on a given month.
  """
  paymentSchedules(
    activeOnDate: Date
    active: Boolean

    """
    If false, we remove the currently valid schedule if it has already fulfilled its purpose and will have no further impact on customer payments, along with any schedules which are not valid from today.
    """
    includeDormant: Boolean = true

    """The ledger to return transactions from."""
    ledgerType: Int

    """The ledger id to return the payment schedules from."""
    ledgerId: ID
    reason: PaymentScheduleReasonOptions
    before: String
    after: String
    first: Int
    last: Int
  ): PaymentScheduleConnectionTypeConnection
  users: [AccountUserType!]!

  """The brand of the account."""
  brand: String

  """The current account balance."""
  balance(
    """
    If this variable is set to true, the balance will be calculated based on the sum of balances on all ledgers configured to contribute to this account's balance. Otherwise, only the main ledger's balance will be fetched (legacy behaviour). If you are unsure, set this value to true.
    """
    includeAllLedgers: Boolean = false
  ): Int!

  """The current account overdue balance."""
  overdueBalance: Int

  """Unique reference number from a 3rd party enrolment."""
  urn: String

  """The billing name of the account."""
  billingName: String

  """The billing sub name of the account."""
  billingSubName: String

  """The billing email of the account."""
  billingEmail: String

  """The billing address of the account."""
  billingAddress: String
  billingAddressLine1: String
  billingAddressLine2: String
  billingAddressLine3: String
  billingAddressLine4: String
  billingAddressLine5: String
  billingAddressPostcode: String
  billingCountryCode: String
  billingDeliveryPointIdentifier: String

  """List of billing address lines."""
  splitBillingAddress: [String]

  "\nThe billing address of this account, stored in the new\nlibaddressinput-based format.\n\nNote that `name` and `organization` are very unlikely to be\nsupplied here; the `billing_name` field on the account\nitself is generally used for that purpose instead.\n"
  address: RichAddressType

  """The portfolio this account is linked to."""
  portfolio: PortfolioType

  """
  Ledgers provide the foundation of bookkeeping functionality. Similar to a bank account, they allow us to keep track of financial activity on a particular customer account.
  """
  ledgers(
    """The ledger to return"""
    ledgerId: ID
  ): [LedgerType]

  """Whether the account can request a credit refund."""
  canRequestRefund: Boolean

  """Details about the eligibility status for requesting a refund."""
  requestRefundEligibility: RequestRefundEligibilityType

  """The payments made into an account from a payment instruction."""
  payments(
    """
    **WARNING: Will be mandatory in future versions**
    
    The ledger to return payments from.
    """
    ledgerId: String
    status: AccountPaymentStatusOptions

    """Filter for payments that were taken for a particular reason."""
    reason: PaymentReasonOptions

    """
    Whether to include payment promises (of any kind: made, broken or fulfilled) or not. The default is to include them.
    """
    includePromises: Boolean = true
    before: String
    after: String
    first: Int
    last: Int
  ): AccountPaymentConnectionTypeConnection

  """The repayments that have been requested for this account."""
  repayments(
    """Only return repayments whose status matches one of these statuses"""
    statuses: [AccountRepaymentStatusOptions]
    before: String
    after: String
    first: Int
    last: Int
  ): AccountRepaymentConnectionTypeConnection

  """
  A list displaying the payment forecast for an account. The list starts from today's date (inclusive).
  """
  paymentForecast(
    """The end date to retrieve forecasts for. This end date is inclusive."""
    dateTo: Date!

    """
    The ledger to return payment forecasts from. Defaults to the main ledger when no ID is passed.
    """
    ledgerId: Int
  ): [PaymentForecastType] @deprecated(reason: "The 'paymentForecast' field is deprecated.\n\nPlease use 'paginatedPaymentForecast' instead.\n\n- Marked as deprecated on 2024-01-03.\n- Will be removed on 2025-01-01.")

  """
  Paginated payment forecasts for an account. Starts from today's date (inclusive). The interface supports `last` but does not guarantee 'lastness'.
  """
  paginatedPaymentForecast(
    """The end date to retrieve forecasts for. This end date is inclusive."""
    dateTo: Date

    """
    The ledger to return payment forecasts from. Defaults to the main ledger when no ID is passed.
    """
    ledgerId: Int
    before: String
    after: String
    first: Int
    last: Int
  ): PaymentForecastConnectionTypeConnection

  """The referrals created by this account."""
  referrals(before: String, after: String, first: Int, last: Int): ReferralConnectionTypeConnection

  """Number of referrals created by this account."""
  referralsCreated: Int

  """The rewards applied to this account."""
  rewards: [RewardType]

  """The referral schemes currently active for this account."""
  activeReferralSchemes: ReferralSchemeTypes

  """Fetch transactions that have taken place on the account."""
  transactions(
    """Include only these specific transaction types in the result."""
    transactionTypes: [TransactionTypeFilter] = []

    """Exclude these specific transaction types from the result."""
    transactionTypesExcluded: [TransactionTypeFilter] = []

    """The ledger to return transactions from."""
    ledgerId: Int

    """
    In a multi-ledger scenario, include all ledgers' transactions if `true`. Analogously, if `false` and no `ledgerId` argument is present, the list of transactions defaults to the main ledger (legacy behaviour).
    """
    includeAllLedgers: Boolean

    "\nOptional date representing the beginning of the postedDate range filter.\nThis date value is inclusive.\n"
    fromDate: Date

    "\nOptional date representing the end of the postedDate range filter.\nThis date value is exclusive.\n"
    toDate: Date

    """The order in which to return the transactions."""
    orderBy: TransactionsOrderBy = POSTED_DATE_DESC
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
  ): TransactionConnectionTypeConnection
  provisionalTransactions(before: String, after: String, first: Int, last: Int): ProvisionalTransactionConnectionTypeConnection

  """Fetch annual statements for the account."""
  annualStatements(before: String, after: String, first: Int, last: Int): AnnualStatementConnectionTypeConnection

  """Fetch issued bills (invoices/statements) for the account."""
  bills(
    """Include bills without PDFs."""
    includeBillsWithoutPDF: Boolean = false

    "\nInclude open statements. This flag needs to be used along with\nincludeBillsWithoutPDF=false otherwise results will prove unexpected.\n"
    includeOpenStatements: Boolean = false

    """Include held statements within the results."""
    includeHeldStatements: Boolean = false

    """Include pre-Kraken / historical statements within the results."""
    includeHistoricStatements: Boolean = true

    """Only include bills emailed to the current user's email."""
    onlyCurrentEmail: Boolean = false

    """
    Optional date representing the beginning of the search results. This date value is inclusive.
    """
    fromDate: Date

    """
    Optional date representing the end of the search results. This date value is exclusive.
    """
    toDate: Date

    """
    Optional date representing the beginning of the search results based on issued date. This date value is inclusive.
    """
    issuedFromDate: Date

    """
    Optional date representing the end of the search results based on issued date. This date value is exclusive.
    """
    issuedToDate: Date

    """The order in which to return the bills."""
    orderBy: BillsOrderBy = FROM_DATE_DESC
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
  ): BillConnectionTypeConnection

  """Information about the account's billing cycle."""
  billingOptions: BillingOptionsType

  """Fetch a specific issued bill (invoice/statement) for the account."""
  bill(id: ID!, billType: BillTypeEnum): BillInterface

  """The direct debit instructions of the account"""
  directDebitInstructions(
    """Filter the direct debit instructions by status"""
    statuses: [DirectDebitInstructionStatus]
    before: String
    after: String
    first: Int
    last: Int
  ): DirectDebitInstructionConnectionTypeConnection

  """The account events that were recorded for the account."""
  events(
    """Filter the account events by their type."""
    eventTypes: [AccountEventType]
    before: String
    after: String
    first: Int
    last: Int
  ): AccountEventConnectionTypeConnection

  """
  Applications by this account to become our customer. More recent applications will be listed first.
  """
  applications(before: String, after: String, first: Int, last: Int): AccountApplicationConnectionTypeConnection

  """The type of account."""
  accountType: AccountTypeChoices

  """The company type of a business account."""
  businessType: BusinessTypeOptions @deprecated(reason: "The 'businessType' field is deprecated.\n\nUse `business.businessType` instead\n\n- Marked as deprecated on 2022-03-09.\n- Will be removed on 2024-01-01.")

  """Business info related to a business account."""
  business: BusinessType

  """The method the account has specified they prefer we contact them"""
  commsDeliveryPreference: CommsDeliveryPreference
  communicationDeliveryPreference: String @deprecated(reason: "The 'communicationDeliveryPreference' field is deprecated.\n\nUse `commsDeliveryPreference` instead\n\n- Marked as deprecated on 2022-05-27.\n- Will be removed on 2024-01-01.")

  """Account references linked to this account."""
  references: [AccountReferenceType]

  """
  Files attached to this account. Only available if categories defined in settings.
  """
  fileAttachments: [AccountFileAttachment]

  """
  The maximum amount a customer is allowed to request as a refund and the reason why that's the maximum amount.
  """
  maximumRefund: MaximumRefundType

  """The campaigns associated with an account."""
  campaigns: [AccountCampaignType]

  """
  True if there is an active Hardship Agreement for this account. False otherwise.
  """
  isInHardship: Boolean

  """
  List of active hardship agreements for the user when is_in_hardship is True.
  """
  activeHardshipAgreements: [HardshipAgreementType]

  """Notes for the account."""
  notes: [AccountNoteType]

  """Contribution agreements for account."""
  contributionAgreements: [ContributionAgreementType]

  """Debt collection proceedings for account."""
  debtCollectionProceedings: [DebtCollectionProceedingType]

  """The datetime that the account was originally created."""
  createdAt: DateTime

  """Expected balance in a year's time"""
  projectedBalance: Int

  """Whether the account's payment should be adjusted."""
  shouldReviewPayments: Boolean

  """Top up payment amount in pence that we recommend for an account."""
  recommendedBalanceAdjustment: Int

  """Properties linked to the account now and in the future"""
  properties(
    """
    Returns properties that have an effective period that ends at or after the given activeFrom datetime.
    """
    activeFrom: DateTime
  ): [PropertyType]

  """The electricity agreements belonging to the account"""
  electricityAgreements(active: Boolean): [ElectricityAgreementType]

  """The gas agreements belonging to the account"""
  gasAgreements(active: Boolean): [GasAgreementType]

  """Get details about warm home discount applications and records"""
  warmHomeDiscount: WarmHomeDiscount

  """
  Whether the account is eligible to apply for Warm Home Discount as part of the Scottish Broader Group.
  """
  eligibilityForWarmHomeDiscount: WarmHomeDiscountEligibility

  """The postcode of the billing address."""
  billingPostcode: String

  """Whether the account is eligible for tariff renewal"""
  canRenewTariff: Boolean

  """
  Only relevant for Kraken instances that support daily tracker tariffs. Returns null if not applicable. 
  """
  trackerTariffDailyPricing: TrackerTariffDailyPricing

  """Results of the latest review of the account's payments."""
  paymentAdequacy: PaymentAdequacyType

  """The interest of an account in procuring smart meters."""
  smets2Interest: SmartMeterInterestChoices

  """
  The reason why the account holder is not interested in having a smart meter installed.
  """
  smets2RefusalReason: SMETS2InterestReason

  """The green benefits achieved over the lifetime of an account."""
  greenAccomplishments: GreenAccomplishmentsType

  """Whether an account can change their payment schedule."""
  canChangePayments: Boolean

  """
  The number of days around a move out a final meter reading can be given for.
  """
  cotReadingWindowDays: Int

  """Whether an account can be withdrawn."""
  canBeWithdrawn: Boolean

  """The current estimated supply start day on an account."""
  currentEstimatedSsd: Date

  """The earliest possible supply start day on an account."""
  earliestPossibleSsd: Date

  """The latest possible supply start day on an account."""
  latestPossibleSsd: Date

  """The operations team that the account belongs to."""
  operationsTeam: OperationsTeamType

  """Whether on not the meter readings can be input via IVR."""
  canInputMeterReadingsViaIvr: Boolean

  """Whether or not the account has an active Dunning process."""
  hasActiveDunningProcess: Boolean

  """Whether or not the account has active collections proceedings."""
  hasActiveCollectionsProceedings: Boolean

  """
  Whether or not an account is eligible for an electricity reading incentive.
  """
  isEligibleForElectricityReadingIncentive: Boolean

  """Whether or not an account is eligible for a gas reading incentive."""
  isEligibleForGasReadingIncentive: Boolean

  """
  Whether or not the account is a part of a migration for which we want to switch supplier without customer actions.
  """
  isInBlockingMigration: Boolean
}

"""
User objects are the core of the authentication system. They typically represent a customer who manages a portfolio of one or more accounts.
"""
type AccountUserType {
  id: ID!

  """
  List of accounts that the user is linked to either via portfolio role or account role.
  """
  accounts(
    """
    Optionally filter the user's accounts to only return those linked to portfolios on the specified brands.
    """
    allowedBrandCodes: [BrandChoices]

    """
    Optionally restrict user accounts to only return those linked to portfolios on public facing brands.
    """
    restrictToPublicFacingBrands: Boolean

    """
    Optionally restrict user accounts to only return those with the specified account numbers.
    """
    restrictToAccountNumbers: [String]

    """Optionally exclude accounts with any of the given account types."""
    excludeAccountTypes: [AccountTypeChoices]

    """Optionally exclude accounts that have never had an agreement."""
    excludeAccountsWithoutAgreements: Boolean
  ): [AccountInterface]
  givenName: String!
  familyName: String!
  email: String!
  mobile: String!
  landline: String!
  title: String

  """The user's pronouns e.g. 'she/her', 'he/him', 'they/them'."""
  pronouns: String

  """Designates whether this user is deceased."""
  isDeceased: Boolean!

  """The user's secret key to access the Developer API."""
  liveSecretKey: String

  """
  List of portfolios that the user is linked to via their portfolio roles.
  """
  portfolios(
    """
    Optionally filter the user's portfolios to only return those linked to specified brands.
    """
    allowedBrandCodes: [BrandChoices]

    """
    Optionally restrict the user portfolios to only return those linked to public facing brands.
    """
    restrictToPublicFacingBrands: Boolean
    before: String
    after: String
    first: Int
    last: Int
  ): PortfolioConnectionTypeConnection

  """AccountUser's date of birth."""
  dateOfBirth: Date

  """List of details linked to this user."""
  details: [AccountUserDetailType]

  """We recommend you use fullName instead of this field."""
  displayName: String @deprecated(reason: "The 'displayName' field is deprecated.\n\nPlease use fullName instead of this field.\n\n- Marked as deprecated on 2019-12-11.\n- Will be removed on 2024-01-01.")

  """We recommend you use preferredName or fullName instead of this field."""
  firstName: String @deprecated(reason: "The 'firstName' field is deprecated.\n\nUse 'givenName' instead.\n\n- Marked as deprecated on 2020-09-23.\n- Will be removed on 2023-06-05.")

  """We recommend you use preferredName or fullName instead of this field."""
  lastName: String @deprecated(reason: "The 'lastName' field is deprecated.\n\nUse 'familyName' instead.\n\n- Marked as deprecated on 2020-09-23.\n- Will be removed on 2023-06-05.")

  """The user's full name."""
  fullName: String

  """The user's preferred name."""
  preferredName: String

  """We recommend you use portfolioIds instead of this field."""
  portfolioId: ID @deprecated(reason: "The 'portfolioId' field is deprecated.\n\nPlease use 'portfolioIds' instead.\n\n- Marked as deprecated on 2022-08-04.\n- Will be removed on 2024-01-01.")

  """
  List of portfolio ids that the user is linked to via their portfolio roles.
  """
  portfolioIds(
    """
    Optionally filter the user's portfolios to only return those linked to specified brands.
    """
    allowedBrandCodes: [BrandChoices]

    """
    Optionally restrict the user portfolios to only return those linked to public facing brands.
    """
    restrictToPublicFacingBrands: Boolean
  ): [ID]
  specialCircumstances: SpecialCircumstancesType
  preferences: AccountUserCommsPreferences

  """The user's landline phone number."""
  landlinePhoneNumber: String @deprecated(reason: "The 'landlinePhoneNumber' field is deprecated.\n\nUse 'landline' instead.\n\n- Marked as deprecated on 2021-03-22.\n- Will be removed on 2024-01-01.")

  """List of alternative phone numbers for the account user."""
  alternativePhoneNumbers: [String]

  """Whether there are family issues."""
  hasFamilyIssues: Boolean

  """
  True if user is linked to an account with an active hardship agreement.
  """
  isInHardship: Boolean

  """List of roles a user has for each account they're linked to."""
  accountUserRoles(
    """
    Optionally filter the user's account roles to only return those linked to specific accounts.
    """
    accountNumber: String
  ): [AccountUserRoleType]

  """List of roles a user has for each portfolio they're linked to."""
  portfolioUserRoles(
    """
    Optionally filter the portfolio's user roles to only return those linked to a specific portfolio.
    """
    portfolioNumber: String
  ): [PortfolioUserRoleType]

  """List of hold music options."""
  holdMusicChoices: [TrackOptionType]
  isOptedInToWof: Boolean
}

"""An enumeration."""
enum BrandChoices {
  """Eon Next"""
  EON_NEXT

  """Sainsburys"""
  SAINSBURYS
}

"""An enumeration."""
enum AccountTypeChoices {
  """An account designed to supply/bill business premises."""
  BUSINESS

  """An account designed to supply/bill domestic premises."""
  DOMESTIC

  """
  An account created when we supply a business premises but do not have details for the occupants.
  """
  BUSINESS_OCCUPIER

  """
  An account created when we supply a domestic premises but do not have details for the occupants.
  """
  OCCUPIER

  """
  An account created when we supply domestic premises that are managed by a business, i.e., a B2B2C model.
  """
  MANAGED

  """
  An account which is responsible for all other accounts in the portfolio, i.e. pays the bills for them.
  """
  PORTFOLIO_LEAD
}

"""Paginator of Operations Team"""
type PortfolioConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PortfolioConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""A Relay edge containing a `PortfolioConnectionType` and its cursor."""
type PortfolioConnectionTypeEdge {
  """The item at the end of the edge"""
  node: PortfolioType

  """A cursor for use in pagination"""
  cursor: String!
}

type AccountUserDetailType {
  """The namespace for the property."""
  namespace: String

  """The property value."""
  value: String
}

"""Information about the special circumstances that relate to a user."""
type SpecialCircumstancesType {
  """
  Whether the user has consented for their data to be given to the appropriate industry or regulatory bodies. We typically only ask for this once, so this field can be used to decide whether to ask the user for their initial consent.
  """
  isSharingConsentGiven: Boolean
  records: [SpecialCircumstanceRecordUnion]
}

union SpecialCircumstanceRecordUnion = SpecialCircumstanceRecordType | TemporarySpecialCircumstanceRecordType

"""
Any special circumstances that the user has notified us about, which may entitle them to some specialist services.
"""
type SpecialCircumstanceRecordType {
  id: ID
  summary: String
  internalCode: String
  gasPSRCode: String
  electricityPSRCode: String
}

"""
Any special circumstances that the user has notified us about, which may entitle them to some specialist services. These circumstances have an end date, after which they will not longer apply. Having young children is an example of this in the UK.
"""
type TemporarySpecialCircumstanceRecordType {
  id: ID
  summary: String
  internalCode: String
  gasPSRCode: String
  electricityPSRCode: String
  expiryDate: Date
}

"""Information about the preferences set up for a user."""
type AccountUserCommsPreferences {
  """
  Whether a user has opted in to receive messages from the client or client group. For example, for Octopus Energy this describes whether a user is opted in to offers from Octopus Investments.
  """
  isOptedInToClientMessages: Boolean

  """
  Whether a user has opted in to receive messages offering discounts or other services not directly related to the services the client provides.
  """
  isOptedInToOfferMessages: Boolean

  """
  Whether a user has opted in to receive messages we recommend they read, but are not vital to the utilities the client provides. For example, these could be reminders that the client will take a payment.
  """
  isOptedInToRecommendedMessages: Boolean

  """
  Whether a user has opted in to receive messages updating them on client activities.
  """
  isOptedInToUpdateMessages: Boolean

  """
  Whether a user has opted in to receive messages from the client's preferred third parties.
  """
  isOptedInToThirdPartyMessages: Boolean

  """What format the user would like to receive their emails in."""
  emailFormat: EmailFormats

  """
  Whether a user has opted to have inverted colours in their emails. This is currently only relevant to the Octopus Energy brand, whose emails have a dark background by default.
  """
  isUsingInvertedEmailColours: Boolean

  """
  This setting allows the user to adjust the default font size of the communications sent to them.
  """
  fontSizeMultiplier: Float

  """
  Whether the user has opted in to receive meter reading confirmation emails.
  """
  isOptedInMeterReadingConfirmations: Boolean

  """Whether the user has opted in to receive SMS messages."""
  isOptedInToSmsMessages: Boolean

  """Song which will be used as hold music for the user."""
  preferredHoldMusic: Songs
}

"""An enumeration."""
enum EmailFormats {
  """Plain text emails."""
  TEXT

  """Full featured HTML emails with images and branding."""
  HTML
}

"""An enumeration."""
enum Songs {
  """No Song Preferred"""
  NO_SONG_PREFERRED
}

"""The role a user has in association with one account."""
type AccountUserRoleType {
  id: ID!
  user: AccountUserType!
  account: AccountType!

  """The account role."""
  role: AccountUserRoleEnum
}

"""An enumeration."""
enum AccountUserRoleEnum {
  ADMIN
  MAIN_ACCOUNT_HOLDER
}

"""The role a user has in association with one portfolio."""
type PortfolioUserRoleType {
  id: ID!
  user: AccountUserType!

  """The portfolio role."""
  role: PortfolioUserRoleEnum

  """Portfolio object."""
  portfolio: PortfolioType!
}

"""An enumeration."""
enum PortfolioUserRoleEnum {
  ADMIN
  MAIN_ACCOUNT_HOLDER
}

"""Key value pair for the choice of tracks."""
type TrackOptionType {
  """The title of the track."""
  trackTitle: String

  """The value save for the user to indicate their choice of track."""
  trackCode: String
}

"""An enumeration."""
enum AccountEventType {
  """The email messages that were sent by the account."""
  EMAIL_SENT

  """The email messages that were received by the account."""
  EMAIL_RECEIVED

  """The marketing email messages that were sent by the account."""
  MARKETING_EMAIL_SENT

  """The print messages that were sent to the print partner by the account."""
  PRINT_SENT

  """The print messages that failed to be delivered."""
  PRINT_FAILED

  """The print messages that were returned to sender."""
  PRINT_RETURNED

  """The print messages that were cancelled."""
  PRINT_CANCELLED

  """The print messages that were sent by the print partner."""
  PRINT_SUCCEEDED
}

type AccountApplicationConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AccountApplicationConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `AccountApplicationConnectionType` and its cursor.
"""
type AccountApplicationConnectionTypeEdge {
  """The item at the end of the edge"""
  node: AccountApplicationType

  """A cursor for use in pagination"""
  cursor: String!
}

type AccountApplicationType {
  status: AccountApplicationStatus!
  salesChannel: String!

  """
  The sales subchannel used when signing up. This could for example be a price comparison site.
  """
  salesSubchannel: String

  """Date at which this account decided to switch to us."""
  dateOfSale: Date

  """
  Last day of the cooling off period. Barring changes or objections, the account will be gained on the next business day after this date. This value will only be returned for current applications.
  """
  coolingOffEndDate: Date

  """
  Whether this account application represents a migration into the current system or a regular gain.
  """
  isMigrated: Boolean

  """
  The source system for a migrated account. This could be the previous supplier or the previous account management system.
  """
  migrationSource: String
}

"""An enumeration."""
enum AccountApplicationStatus {
  """Current"""
  CURRENT

  """Failed"""
  FAILED

  """Historic"""
  HISTORIC

  """Withdrawn"""
  WITHDRAWN
}

"""An enumeration."""
enum BusinessTypeOptions {
  """A business account where the company type is sole trader."""
  SOLE_TRADER

  """A business account where the company type is limited."""
  LIMITED

  """A business account where the company type is proprietary limited."""
  PROPRIETARY_LIMITED_COMPANY

  """A business account where the company type is partnership."""
  PARTNERSHIP

  """A business account where the company type is charity."""
  CHARITY

  """A business account where the company type is public limited."""
  PUBLIC_LIMITED_COMPANY

  """
  A business account where the company type is limited liability partnership.
  """
  LIMITED_LIABILITY_PARTNERSHIP

  """A business account where the company type is a trust."""
  TRUST

  """
  A business account where the company has a trading name to carry out its business activities.
  """
  TRADING_AS

  """A business account for a government institution."""
  GOVERNMENT

  """A business account for a non-profit organisation."""
  NON_PROFIT

  """A business account for a church or other religious organisation."""
  CHURCH
}

type BusinessType {
  name: String!
  number: String!

  """The company type of a business account."""
  businessType: BusinessTypeOptions
}

"""The method the account has specified they prefer we contact them"""
enum CommsDeliveryPreference {
  EMAIL
  POSTAL_MAIL
}

type AccountReferenceType {
  namespace: String!
  value: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  account: AccountType!
}

type AccountFileAttachment implements Node & FileAttachment {
  """The ID of the object"""
  id: ID!
  filename: String!
  category: String!

  """Is the file uploaded to S3?"""
  isUploaded: Boolean

  """Is the file ready for use / downloadable?"""
  isReady: Boolean
  fetchUrl: String
  sizeInBytes: Int
}

interface FileAttachment {
  """Is the file uploaded to S3?"""
  isUploaded: Boolean

  """Is the file ready for use / downloadable?"""
  isReady: Boolean
  fetchUrl: String
  sizeInBytes: Int
}

type MaximumRefundType {
  """The maximum amount available to be requested as a refund."""
  amount: Int

  """
  The reason why a specific amount is the maximum available to be requested as a refund.
  """
  reasonToRecommendAmount: MaximumRefundReasonChoices

  """
  The recommended minimum balance an account should have when asking for a refund.
  """
  recommendedBalance: Int
}

"""An enumeration."""
enum MaximumRefundReasonChoices {
  """
  Maximum refund is equal to the current balance minus the account recommended balance.
  """
  MAX_AVAILABLE_AMOUNT

  """
  Maximum refund is equal to the total amount the customer has paid using the current account Direct Debit instruction.
  """
  TOTAL_AMOUNT_PAID_VIA_ACTIVE_DDI

  """
  Maximum refund is equal to the maximum refund amount allowed to be requested via the dashboard.
  """
  MAX_ALLOWED_TO_REQUEST_VIA_DASHBOARD
}

type AccountCampaignType {
  """The date on which the associated campaign itself concludes."""
  campaignExpiryDate: Date

  """The name of the campaign."""
  name: String

  """The slug of the campaign."""
  slug: String

  """The date on which the account's participation in the campaign ends."""
  expiryDate: Date

  """The date that the account's link to the campaign started."""
  startDate: Date
}

"""Represents a Hardship Agreement for a particular Account."""
type HardshipAgreementType {
  id: ID!
  hardshipType: HardshipAgreementHardshipType!

  """These are internal notes detailing the hardship."""
  hardshipDetails: String!
  hardshipEntryReason: HardshipAgreementHardshipEntryReason
  paymentPlanDetails: String!
  startDate: Date!
}

"""An enumeration."""
enum HardshipAgreementHardshipType {
  """Death in the family"""
  DEATH_IN_FAMILY

  """Household illness"""
  HOUSEHOLD_ILLNESS

  """Family violence"""
  FAMILY_VIOLENCE

  """Unemployment"""
  UNEMPLOYMENT

  """Reduced income"""
  REDUCED_INCOME

  """Other"""
  OTHER
}

"""An enumeration."""
enum HardshipAgreementHardshipEntryReason {
  """Customer self-identified as being in hardship"""
  SELF_IDENTIFIED

  """Financial counsellor or external agent referral"""
  EXTERNAL_REFERENCE

  """Retailer referral"""
  RETAILER_REFERRAL
}

type AccountNoteType {
  body: String!
  isPinned: Boolean!
  createdAt: DateTime!
}

"""A single Contribution Agreement."""
type ContributionAgreementType {
  id: ID!

  """The scheme to which the agreement contributes."""
  contributionScheme: ContributionSchemeType

  """The frequency of contributions."""
  interval: Interval

  """The start datetime of the agreement."""
  activeFrom: DateTime

  """The end datetime of the agreement, if any."""
  activeTo: DateTime

  """
  The amount contributed per interval. Note, this is in the smallest domination that the currecy support. e.g. Pence, Cents, Yen, etc.
  """
  amount: Int

  """The periods over which contributions have been made."""
  periods(before: String, after: String, first: Int, last: Int): ContributionPeriodConnection
}

"""A single Contribution Scheme."""
type ContributionSchemeType {
  id: ID!
  code: String!
  displayName: String!

  """Are contributions to this scheme taxable?"""
  taxable: Boolean!

  """Is this scheme currently accepting contributions?"""
  acceptingContributions: Boolean!
}

"\n    The frequency at which contributations are made\n    "
enum Interval {
  MONTHLY
  QUARTERLY
}

"""Pagination for contribution periods."""
type ContributionPeriodConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ContributionPeriodEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""A Relay edge containing a `ContributionPeriod` and its cursor."""
type ContributionPeriodEdge {
  """The item at the end of the edge"""
  node: ContributionPeriodType

  """A cursor for use in pagination"""
  cursor: String!
}

"""A single Contribution Period."""
type ContributionPeriodType {
  id: ID!
  agreement: ContributionAgreementType!

  """When the contribution was fulfilled"""
  fulfilledAt: DateTime

  """The datetime the marks the beginning of the period."""
  periodFrom: DateTime

  """The datetime the marks the end of the period."""
  periodTo: DateTime
}

type DebtCollectionProceedingType {
  """The agency responsible for the collection proceedings."""
  agency: DebtCollectionAgencyType

  """The campaign type of the collection proceedings."""
  campaign: CollectionCampaignType
  amount: Int
  startedAt: DateTime!
  stoppedAt: DateTime
  stopReason: DebtCollectionProceedingStopReason
}

type DebtCollectionAgencyType {
  name: String!
  code: String!
  isActive: Boolean!
}

"""An enumeration."""
enum CollectionCampaignType {
  ADMINISTRATION
  B2B_DISCONNECTION_PROCESS
  BANKRUPTCY
  CVA
  DEBT_ARRANGEMENT_SCHEME_DAS
  DEBT_COLLECTION_AGENCY
  DECEASED
  DRO
  FAILED_ARRANGEMENT
  FIRST_PLACEMENT
  HIGH_RISK
  HOME_VISIT
  INSOLVENT
  IVA
  LIQUIDATION
  LITIGATION
  LOW_RISK
  MEDIUM_RISK
  OCCUPIER
  PTSO
  PVA
  SECOND_PLACEMENT
  SEQUESTRATION
  STOP_VEND_HIGH
  STOP_VEND_LOW
  SWITCH_TO_SMART_PAYG
  THIRD_PARTY
  TRACE
  TRACE_AND_COLLECT
  TRUST_DEED
  VULNERABILITY_VISIT
  VULNERABLE_CUSTOMER
  FINAL_DEBT_COLLECTION
  FINAL_DEBT_COLLECTION_2
  PERSISTENT_DEBT
  LIVE_B2B
  FINAL_B2B
}

"""An enumeration."""
enum DebtCollectionProceedingStopReason {
  """Bankrupt"""
  BANKRUPT

  """Deceased"""
  DECEASED

  """Gone away"""
  GONE_AWAY

  """In prison"""
  IN_PRISON

  """Negative trace"""
  NEGATIVE_TRACE

  """Paid in full"""
  PAID_IN_FULL

  """Process exhausted"""
  PROCESS_EXHAUSTED

  """Process exhausted - no contact"""
  PROCESS_EXHAUSTED_NO_CONTACT

  """Process exhausted - contact"""
  PROCESS_EXHAUSTED_CONTACT

  """Reduced settlement"""
  REDUCED_SETTLEMENT

  """Vulnerable"""
  VULNERABLE

  """Withdrawn"""
  WITHDRAWN

  """Write off"""
  WRITE_OFF

  """Payment arrangement"""
  PAYMENT_ARRANGEMENT

  """Payment plan agreed"""
  PAYMENT_PLAN_AGREED

  """Part payment"""
  PART_PAYMENT

  """PPM arrangement"""
  PPM_ARRANGEMENT

  """PPM requested"""
  PPM_REQUESTED

  """Arrears to client"""
  ARREARS_TO_CLIENT

  """High level complaint"""
  HIGH_LEVEL_COMPLAINT

  """Insolvencies dealing"""
  INSOLVENCIES_DEALING

  """Partial settlement"""
  PARTIAL_SETTLEMENT

  """PPM fitted"""
  PPM_FITTED

  """Refused to deal"""
  REFUSED_TO_DEAL

  """Live to final"""
  LIVE_TO_FINAL

  """COT / COS"""
  COT_COS

  """COS"""
  COS

  """COT proof seen"""
  COT_PROOF_SEEN

  """COT no proof"""
  COT_NO_PROOF

  """Enrolled in Error"""
  ENROLLED_IN_ERROR

  """Low balance"""
  LOW_BALANCE

  """Expired"""
  EXP

  """Unable to locate property"""
  UNABLE_TO_LOCATE_PROPERTY

  """Confirmed empty"""
  CONFIRMED_EMPTY

  """Demolished"""
  DEMOLISHED

  """Unable to trace"""
  UNABLE_TO_TRACE

  """Query"""
  QUERY
}

"""
Represents a property. Conceptually, it collects supply points under an address.
"""
type PropertyType implements PropertyInterface {
  id: String
  postcode: String!

  """The address of the property, formatted into a single string"""
  address: String

  """Property rich address."""
  richAddress: PropertyRichAddressType

  """List of address lines."""
  splitAddress: [String]

  """
  Time periods during which the property is associated with an account. Useful to display information about house-moves, as performing a move out of a property will set the end date for the occupancy period.
  """
  occupancyPeriods: [OccupancyPeriodType]

  """
  Coordinates for the property, useful for displaying the property on a map.
  """
  coordinates: CoordinatesType

  """The embedded network this property belongs to, if any."""
  embeddedNetwork: EmbeddedNetworkType

  """Measurements at a property"""
  measurements(
    """Defaults to the far past which will return the oldest readings."""
    startAt: DateTime = "0001-01-03T00:00:00-00:01:15"

    """Defaults to the far future which will return the most recent readings."""
    endAt: DateTime = "9999-12-29T23:59:59.999999+00:00"

    """Earliest date to return measurements from."""
    startOn: Date

    """Latest date to return measurements for (inclusive)."""
    endOn: Date

    """Timezone to use for grouping. Defaults to Kraken localtime."""
    timezone: String = "Europe/London"

    """Filters for each utility being measured"""
    utilityFilters: [UtilityFiltersInput] = []
    before: String
    after: String
    first: Int
    last: Int
  ): MeasurementConnection

  """Retrieve any smartmeter devices connected to the property."""
  smartDeviceNetworks: [SmartMeterDeviceNetworkType]
  isChangeOfTenancyOngoing: Boolean

  """Indicates if the property meets smart meter install preconditions."""
  isSmets2InstallationAllowed: Boolean

  """Retrieve the details of an electricity meter-point."""
  electricityMeterPoints: [ElectricityMeterPointType]

  """Retrieve the details of a gas meter-point."""
  gasMeterPoints: [GasMeterPointType]

  """
  Likelihood that a smart meter at the given postcode will get a stable network connection.
  """
  wanCoverage: WANCoverageStrengths

  """
  Timeslots for which the property has the possibility to book a smart-meter installation.
  """
  availableSmets2InstallationTimeslots: [Smets2InstallationTimeslotType]
}

interface PropertyInterface {
  id: String

  """The address of the property, formatted into a single string"""
  address: String

  """Property rich address."""
  richAddress: PropertyRichAddressType

  """List of address lines."""
  splitAddress: [String]

  """
  Time periods during which the property is associated with an account. Useful to display information about house-moves, as performing a move out of a property will set the end date for the occupancy period.
  """
  occupancyPeriods: [OccupancyPeriodType]

  """
  Coordinates for the property, useful for displaying the property on a map.
  """
  coordinates: CoordinatesType

  """The embedded network this property belongs to, if any."""
  embeddedNetwork: EmbeddedNetworkType

  """Measurements at a property"""
  measurements(
    """Defaults to the far past which will return the oldest readings."""
    startAt: DateTime = "0001-01-03T00:00:00-00:01:15"

    """Defaults to the far future which will return the most recent readings."""
    endAt: DateTime = "9999-12-29T23:59:59.999999+00:00"

    """Earliest date to return measurements from."""
    startOn: Date

    """Latest date to return measurements for (inclusive)."""
    endOn: Date

    """Timezone to use for grouping. Defaults to Kraken localtime."""
    timezone: String = "Europe/London"

    """Filters for each utility being measured"""
    utilityFilters: [UtilityFiltersInput] = []
    before: String
    after: String
    first: Int
    last: Int
  ): MeasurementConnection
}

type PropertyRichAddressType {
  """A personal name."""
  name: String

  """The name of a business or organisation."""
  organization: String

  "\nThe 'street address' component.\n\nThis value can (and often will) contain newline characters\nwhen appropriate.\n\nIn some cases, data may appear in this field instead of the\nbelow fields; e.g. a UK post town name may appear here\ninstead of in the `dependent_locality` field. This happens\nwhen data has been migrated from a legacy format, and that\nformat had insufficient metadata to determine the\nappropriate field.\n\nIf `structured_street_address` is also set, the value of\nthis field will be a string generated from that value.\n"
  streetAddress: String

  "\nThe 'street address' component, in a structured format.\n\nThis field stores the same value as `street_address`, but\nwith more detail; for instance, instead of `123 Example\nStreet` it might be `{'street_number': '123',\n'street_name': 'Example', 'street_type': 'Street'}`. In\nmany cases this will be blank; we only use this field for\nKrakens where we need to supply this level of granularity\nto some third-party service, like a bulk mail provider.\n\nThe exact structure of this value depends on the country _of\nthe address_, which is not necessarily the same as the\ncountry this Kraken is configured to serve. For addresses\noutside of the countries listed below, this field will be\nleft blank.\n\n### `AU`: Australia\n\nThe following keys may be present; all are optional. All\nkeys have string values, and their meaning is the same as\ntheir aseXML counterparts. (Note that, unlike aseXML, all\nkeys are provided at the top level, rather than being\nnested.)\n\n- `flat_or_unit_type`\n- `flat_or_unit_number`\n- `floor_or_level_type`\n- `floor_or_level_number`\n- `building_or_property_name`\n- `location_descriptor`\n- `lot_number`\n- `house_number_1`\n- `house_number_suffix_1`\n- `house_number_2`\n- `house_number_suffix_2`\n- `street_name`\n- `street_type`\n- `street_suffix`\n- `postal_delivery_type`\n- `postal_delivery_number_prefix`\n- `postal_delivery_number_value`\n- `postal_delivery_number_suffix`\n"
  structuredStreetAddress: GenericScalar

  "\nUK dependent localities, or neighbourhoods or boroughs in\nsome other locations.\n"
  dependentLocality: String

  "\nCity or town portion of an address, e.g. US city, AU\nsuburb/town, IT comune, UK post town.\n"
  locality: String

  "\nTop-level administrative subdivision, e.g. US state, AU\nstate/territory, IT region, JP prefecture.\n\n### `AU`: Australia\n\nThis must be one of `NSW`, `VIC`, `QLD`, `TAS`, `ACT`, `SA`,\n`NT`, `WA`. For addresses not within these locations, use\nthe value that Australia Post uses, e.g. `ACT` for the\nJervis Bay Territory or `WA` for Christmas Island.\n"
  administrativeArea: String

  "\nPostal code (ZIP code in the US).\n"
  postalCode: String

  "\nSorting code, e.g. FR CEDEX code. This field is not used in many countries.\n"
  sortingCode: String

  "\nISO 3166-1 alpha-2 code of the country this address belongs\nto, e.g. `AU`, `GB`.\n"
  country: String

  "\nIdentifier used by the local postal service for this\naddress, e.g. AU DPID, GB postcode + Delivery Point Suffix,\nUS Zip-9 + Delivery Point.\n\nThis is the value that gets encoded in the barcode printed\non the envelope by large-volume bulk mail providers.\n"
  deliveryPointIdentifier: String
}

"""An occupancy period for a property."""
type OccupancyPeriodType {
  id: ID

  """Date the occupancy period is effective from."""
  effectiveFrom: DateTime

  """Date the occupancy period is effective to."""
  effectiveTo: DateTime

  """
  Whether the account associated with the occupancy period is an occupier account type.
  """
  isOccupier: Boolean
}

type CoordinatesType {
  latitude: Float
  longitude: Float
}

"""
Represents an embedded network that holds multiple embedded properties.
"""
type EmbeddedNetworkType {
  id: ID!

  """A unique name/code for the network"""
  name: String!

  """Get details about properties in an embedded network."""
  embeddedProperties: [EmbeddedPropertyType]
}

"""Represents an embedded property in an embedded network."""
type EmbeddedPropertyType {
  id: ID!
  embeddedNetwork: EmbeddedNetworkType!

  """
  The id of the physical property related to this embedded property type.
  """
  propertyId: ID
}

"""Pagination for measurements."""
type MeasurementConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [MeasurementEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""A Relay edge containing a `Measurement` and its cursor."""
type MeasurementEdge {
  """The item at the end of the edge"""
  node: MeasurementInterface

  """A cursor for use in pagination"""
  cursor: String!
}

interface MeasurementInterface {
  source: String!

  "\nThis type will return more granular data about the measurement.\n\nFor example, it includes a `typed_source` object that returns typed information about the source of the measurement.\n"
  metaData: MeasurementsMetadataOutput
  value: Decimal!
  unit: String!
  readAt: DateTime!
}

type MeasurementsMetadataOutput {
  typedSource: TypedSourceOutput
  utilityFilters: UtilityFiltersOutput

  """Statistics relating to the parent measurement node."""
  statistics: [StatisticOutput]
}

type TypedSourceOutput {
  utility: UtilityType
  sourceIdentifier: String
  readingFrequencyType: ReadingFrequencyType
  readingDirection: ReadingDirectionType
  readingQuality: ReadingQualityType
}

enum UtilityType {
  ELECTRICITY
  GAS
}

"""The frequency of the reading."""
enum ReadingFrequencyType {
  """Interval Readings as provided, may be variable in length."""
  RAW_INTERVAL

  """Readings taken in every 5 minute intervals."""
  FIVE_MIN_INTERVAL

  """Readings taken in every 15 minute intervals."""
  FIFTEEN_MIN_INTERVAL

  """Readings taken in every 30 minute intervals."""
  THIRTY_MIN_INTERVAL
  HOUR_INTERVAL
  DAY_INTERVAL
  WEEK_INTERVAL
  MONTH_INTERVAL
  QUARTER_INTERVAL

  """Readings taken on a day to day basis."""
  DAILY

  """Readings taken at a point in time."""
  POINT_IN_TIME
}

"""
Reading direction is based on the utility generated or consumed by the customer.
"""
enum ReadingDirectionType {
  """Reading is based on the customer's usage of the utility."""
  CONSUMPTION

  "\nReading is based on the utility generated by the customer.\n\nFor example: This will return solar readings if a customer has solar panels installed at their location.\n"
  GENERATION
}

enum ReadingQualityType {
  ACTUAL
  ESTIMATE
  COMBINED
}

union UtilityFiltersOutput = ElectricityFiltersOutput | GasFiltersOutput

type ElectricityFiltersOutput {
  readingDirection: ReadingDirectionType
  registerId: String
  readingQuality: ReadingQualityType
  readingFrequencyType: ReadingFrequencyType
  marketSupplyPointId: String
  deviceId: String
}

"\nFilter measurements by gas parameters.\n"
type GasFiltersOutput {
  registerId: String
  readingFrequencyType: ReadingFrequencyType
  marketSupplyPointId: String
  deviceId: String
}

type StatisticOutput {
  """The type of statistic being measured for the parent node."""
  type: ReadingStatisticTypeEnum

  """Display label of the statistic for the parent node."""
  label: String

  """Description of the statistic for the parent node."""
  description: String

  """Monetary cost of the statistic (excluding tax), if applicable."""
  costExclTax: EstimatedMoneyType

  """Monetary cost of the statistic (including tax), if applicable."""
  costInclTax: EstimatedMoneyType

  """Consumption / generation value of the statistic, if applicable."""
  value: Decimal
}

"""The type of statistic for the reading interval."""
enum ReadingStatisticTypeEnum {
  """The calculated cost of standing charges for the interval."""
  STANDING_CHARGE_COST

  """The calculated cost of consumption for the interval."""
  CONSUMPTION_COST

  """The calculated monetary value of generation for the interval"""
  GENERATION_VALUE

  """The apportion cost of a time of use bucket for the interval."""
  TOU_BUCKET_COST

  """The estimated carbon cost of the interval."""
  CARBON_COST
}

type EstimatedMoneyType {
  "\n            Monetary cost of the statistic. This is the smallest unit of currency,\n            e.g. cents for USD or yen for JPY. Because electricity is priced as a commodity, we must\n            account for fractional cents and this field must be a Decimal. Values from this field should\n            likely not be used for accounting purposes.\n        "
  estimatedAmount: Decimal!

  """Monetary currency of the statistic in ISO-4217 format."""
  costCurrency: String!
}

"\nProvide a typed source to filter measurements.\nIf a typed_source and a raw source is given, preference is given to the raw source.\nTo get better results, make sure none of the input fields are empty.\n"
input TypedSourceInputType {
  utility: UtilityType = ELECTRICITY
  readingFrequencyType: ReadingFrequencyType = RAW_INTERVAL
  readingDirection: ReadingDirectionType = CONSUMPTION
  sourceIdentifier: String
  readingQuality: ReadingQualityType = COMBINED
}

"\nFilter measurements by the given utility parameters.\n"
input UtilityFiltersInput {
  electricityFilters: ElectricityFiltersInput = null
  gasFilters: GasFiltersInput = null
}

"\nFilter measurements by electricity parameters.\n"
input ElectricityFiltersInput {
  readingFrequencyType: ReadingFrequencyType = RAW_INTERVAL
  marketSupplyPointId: String
  deviceId: String
  readingDirection: ReadingDirectionType = CONSUMPTION
  registerId: String
  readingQuality: ReadingQualityType = COMBINED
}

"\nFilter measurements by gas parameters.\n"
input GasFiltersInput {
  readingFrequencyType: ReadingFrequencyType = RAW_INTERVAL
  marketSupplyPointId: String
  deviceId: String
  registerId: String
}

"""
This is the network through which a set of SMETS2 devices communicates.
"""
type SmartMeterDeviceNetworkType {
  id: ID!

  """A list of devices attached to one network."""
  smartDevices(
    """Filter the devices by status."""
    statuses: [DeviceStatuses]
  ): [SmartMeterDeviceType]
}

"""A smart meter device."""
type SmartMeterDeviceType {
  id: ID!
  importElectricityMeter: ElectricityMeterType
  exportElectricityMeter: ElectricityMeterType
  gasMeter: GasMeterType
  deviceNetwork: SmartMeterDeviceNetworkType
  serialNumber: String!
  deviceId: String!
  type: DeviceType
  status: DeviceStatus!
  manufacturer: String!
  model: String!
  firmwareVersion: String!

  """
  The payment mode (e.g. credit or prepayment) that the device is currently operating in.
  """
  paymentMode: PaymentMode

  """
  The rate, in pence per week, that debt is being recovered from this device.
  """
  weeklyDebtRecoveryRateInPence: Int
}

"""
An electricity meter is a collection of registers which store readings. Eco7 meters are an example of a meter with multiple registers (for day and night).
"""
type ElectricityMeterType implements Node & Meter {
  id: ID!
  serialNumber: String!
  requiresAccess: Boolean
  isDigital: Boolean
  installationDate: Date
  lastInspectionDate: Date
  createdAt: DateTime!
  updatedAt: DateTime
  activeFrom: Date!
  activeTo: Date
  meterPoint: ElectricityMeterPointType!
  location: String
  currentRating: Int
  makeAndType: String
  meterType: ElectricityMeterMeterType
  certificationDate: Date
  certifiedUntil: Date
  retrievalMethod: String
  importMeter: ElectricityMeterType
  exportMeters(offset: Int, before: String, after: String, first: Int, last: Int): ElectricityMeterTypeConnection!
  prepayLedgers: PrepayLedgersType
  smartImportElectricityMeter: SmartMeterDeviceType
  smartExportElectricityMeter: SmartMeterDeviceType

  """The units of consumption for a smart meter."""
  consumptionUnits: String

  """Whether this meter requires a final change of tenancy (COT) reading."""
  requiresCotFinalReading: Boolean

  """The type of fuel this meter uses."""
  fuelType: String

  """Energy consumption recorded by the meter."""
  consumption(
    """Earliest consumption reading to return. Must specify a timezone."""
    startAt: DateTime!

    """Aggregate consumption according to this grouping."""
    grouping: ConsumptionGroupings!

    """Timezone to use for grouping."""
    timezone: String!
    before: String
    after: String
    first: Int
    last: Int
  ): ConsumptionConnection

  """
  This lets us get around the fact that we already use the field id as a primary key. We will migrate the id field over to be this id eventually.
  """
  nodeId: ID!
  readings(before: String, after: String, first: Int, last: Int): ElectricityMeterReadingConnectionTypeConnection
  registers: [ElectricityMeterRegisterType]

  """Returns if the meter has and allows half hourly readings"""
  hasAndAllowsHhReadings: Boolean
  smartDevices: [SmartMeterDeviceType]

  """Returns if the meter is a traditional prepay meter."""
  isTradPrepay: Boolean

  """Returns if the meter is ready for top up."""
  isReadyForTopup: Boolean
}

interface Meter {
  id: ID!
  serialNumber: String!

  """The units of consumption for a smart meter."""
  consumptionUnits: String

  """Whether this meter requires a final change of tenancy (COT) reading."""
  requiresCotFinalReading: Boolean

  """The type of fuel this meter uses."""
  fuelType: String

  """Energy consumption recorded by the meter."""
  consumption(
    """Earliest consumption reading to return. Must specify a timezone."""
    startAt: DateTime!

    """Aggregate consumption according to this grouping."""
    grouping: ConsumptionGroupings!

    """Timezone to use for grouping."""
    timezone: String!
    before: String
    after: String
    first: Int
    last: Int
  ): ConsumptionConnection
}

"""Pagination for energy consumption readings."""
type ConsumptionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ConsumptionEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""A Relay edge containing a `Consumption` and its cursor."""
type ConsumptionEdge {
  """The item at the end of the edge"""
  node: ConsumptionType

  """A cursor for use in pagination"""
  cursor: String!
}

"""Energy consumption between two points in time."""
type ConsumptionType {
  value: Decimal
  startAt: DateTime
  endAt: DateTime
}

"""An enumeration."""
enum ConsumptionGroupings {
  QUARTER_HOUR
  HALF_HOUR
  HOUR
  DAY
  WEEK
  MONTH
  QUARTER
}

"""
An electricity meterpoint is a collection of meters. Meters can be changed over time, so it is convenient to keep an invariant reference. Sometimes there are multiple active meters on a meterpoint at a time (eg ECO10), but expect that to be an edge case.
"""
type ElectricityMeterPointType implements MeterPointInterface {
  id: ID!
  supplyEndDate: Date
  mpan: String!

  """Standard settlement configuration"""
  ssc: String!
  energisationStatus: String!
  dccServiceFlag: String!
  statusUpdatedAt: DateTime
  oldSupplierId: String
  newSupplierId: String
  smartStartDate: Date
  requiresEnrolment: Boolean!
  targetSsd: Date
  requiresWithdrawal: Boolean!
  hasOpenOpeningReadDispute: Boolean!
  hasOpenClosingReadDispute: Boolean!

  """The profile class of the electricity meter point."""
  profileClass: Int

  """Line loss factor class"""
  llf: String

  """Meter timeswitch code"""
  mtc: Int
  measurementClass: String!
  lastValidatedReadingDate: Date

  """Smart Metering System Operator"""
  smsOperator: String!
  smsOperatorEffectiveFrom: Date
  ihdStatus: String!
  ihdEffectiveFrom: Date
  dccEffectiveFrom: Date
  meters(id: Int, includeInactive: Boolean): [ElectricityMeterType]
  status: String

  """Details of an ongoing enrolment process."""
  enrolment: EnrolmentType

  """The distribution network the grid supply point falls under"""
  gspGroupId: String

  """A list of agents responsible for management of the meterpoint."""
  agentContracts(
    """Filter the contracts by status."""
    statuses: [AgentContractStatusType]
  ): [ElectricityAgentContractType]

  """The ID of the meter point in Junifer."""
  juniferMeterPointId: Int @deprecated(reason: "The 'juniferMeterPointId' field is deprecated.\n\nIt is no longer populated.\n\n- Marked as deprecated on 2023-03-13.\n- Will be removed on 2023-09-13.")

  """
  A list of electricity agreements belonging to an account that is linked to the viewer. Filters out expired agreements by default.
  """
  agreements(
    validAfter: DateTime
    includeInactive: Boolean

    """Exclude agreements starting in the future."""
    excludeFuture: Boolean
  ): [ElectricityAgreementType]
  smartTariffOnboarding: SmartTariffOnboardingType

  """A list of unbilled electricity readings for the meterpoint."""
  unbilledReadings: [ElectricityMeterReadingType]
}

interface MeterPointInterface {
  status: String

  """
  Returns active meters by default, but can be filtered by meter id and active status.
  """
  meters(id: Int, includeInactive: Boolean): [Meter]

  """Details of an ongoing enrolment process."""
  enrolment: EnrolmentType
}

"""Details of an ongoing enrolment process."""
type EnrolmentType {
  """Date the switch started."""
  switchStartDate: Date

  """Target date for supply to start."""
  supplyStartDate: Date

  """The last company to supply this meter point."""
  previousSupplier: String

  """The enrolment status on a meter point."""
  status: EnrolmentStatusOptions
}

"""An enumeration."""
enum EnrolmentStatusOptions {
  """
  The previous supplier objects to the switch. The have not has cancelled the switch yet, but in 99% cases, they will cancel the switch.
  """
  OBJECTION_RECEIVED

  """
  The previous supplier cancelled the switch. This is a terminal state, and we will have to reapply before this can start again.
  """
  REGISTRATION_OBJECTED

  """The overseeing industry body has objected to the switch"""
  REJECTED

  """The request to bring the meter point on supply has been withdrawn."""
  WITHDRAWN

  """
  The meterpoint has been created but the enrolment process has not started yet.
  """
  PRE_REGISTRATION

  """
  Enrolment has been requested. This is the default catch-all status, which is returned when no other defined process is happening.
  """
  REQUESTED

  """Enrolment has been completed."""
  COMPLETED

  """
  Enrolment has been disputed. This could be that the meter point details that have been provided have been disputed.
  """
  DISPUTED

  """
  Enrolment has been accepted by the industry, which means that it has all the information needed to switch supplier and if that information is correct (to it's knowledge)
  """
  ACCEPTED
}

"""An organization who manages a given meterpoint."""
type ElectricityAgentContractType {
  contractType: ElectricityAgentContractContractType!
  effectiveFrom: Date!
  agentId: String
  contractStatus: AgentContractStatusType
}

"""An enumeration."""
enum ElectricityAgentContractContractType {
  """Meter Operator"""
  MOP

  """Data Aggregator"""
  DA

  """Data Collector"""
  DC

  """Metering Service"""
  MS

  """Data Service"""
  DS
}

"""An enumeration."""
enum AgentContractStatusType {
  """The contracts that have been accepted by the agent."""
  ACCEPTED

  """The contracts that have been rejected by the agent."""
  REJECTED

  """The contracts that have been requested by the supplier."""
  REQUESTED

  """
  The contracts for which termination has been requested by the supplier.
  """
  TERMINATION_REQUESTED

  """The contracts that have been terminated."""
  TERMINATED
}

type ElectricityAgreementType implements AgreementInterface {
  id: Int
  validFrom: DateTime
  validTo: DateTime
  agreedFrom: DateTime
  agreedTo: DateTime
  account: AccountType!
  meterPoint: ElectricityMeterPointType!
  tariff: ElectricityTariffType
  isRevoked: Boolean

  """A collection of charges and associated consumption data."""
  lineItems(
    startAt: DateTime!

    """
    Aggregate line items according to this grouping. Note that this doesn't guarantee that the returned items will cover a particular length of time, as it will depend on how the items have been stored, whether the period had daylight savings time changes (and therefore potentially 25 hours) etc.
    """
    grouping: LineItemGroupingOptions!
    itemType: LineItemTypeOptions!

    """Timezone used for grouping."""
    timezone: String!
    before: String
    after: String
    first: Int
    last: Int
  ): LineItemConnection

  """
  List of contracted unit rate uplifts applicable during this agreement's duration. This is only applicable to business accounts where we may pay commission to a third-party intermediary.
  """
  unitRateUplifts: [ElectricityContractUnitRateUplift]
}

interface AgreementInterface {
  id: Int
  validFrom: DateTime
  validTo: DateTime
  agreedFrom: DateTime
  agreedTo: DateTime
  isRevoked: Boolean
}

union ElectricityTariffType = StandardTariff | DayNightTariff | ThreeRateTariff | HalfHourlyTariff | PrepayTariff

type StandardTariff implements TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float

  """
  Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  """
  tariffCode: String
  unitRate: Float

  """Is EPG applied to the unit rate."""
  unitRateEpgApplied: Boolean
  preVatUnitRate: Float
}

interface TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float

  """
  Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  """
  tariffCode: String
}

type DayNightTariff implements TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float

  """
  Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  """
  tariffCode: String
  dayRate: Float

  """Is EPG applied to the unit rate."""
  dayRateEpgApplied: Boolean
  nightRate: Float

  """Is EPG applied to the unit rate."""
  nightRateEpgApplied: Boolean
  preVatDayRate: Float
  preVatNightRate: Float
}

type ThreeRateTariff implements TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float

  """
  Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  """
  tariffCode: String
  dayRate: Float

  """Is EPG applied to the unit rate."""
  dayRateEpgApplied: Boolean
  nightRate: Float

  """Is EPG applied to the unit rate."""
  nightRateEpgApplied: Boolean
  offPeakRate: Float

  """Is EPG applied to the unit rate."""
  offPeakRateEpgApplied: Boolean
  preVatDayRate: Float
  preVatNightRate: Float
  preVatOffPeakRate: Float
}

type HalfHourlyTariff implements TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float

  """
  Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  """
  tariffCode: String
  unitRates: [UnitRate]

  """Information on how agile unit rates have been calculated."""
  agileCalculationInfo: AgileCalculationInfo
}

type UnitRate {
  validFrom: DateTime
  validTo: DateTime

  """Price in pence (inc VAT)."""
  value: Float

  """Price in pence (not including VAT)."""
  preVatValue: Float
}

type AgileCalculationInfo {
  """The maximum value/cap for the unit rate."""
  priceCap: Float

  """The peak offset for the unit rate."""
  peakOffset: Float

  """The price multiplier/coefficient used to calculate the unit rate."""
  gspCoefficient: Float
}

type PrepayTariff implements TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float

  """
  Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  """
  tariffCode: String
  unitRate: Float
  preVatUnitRate: Float
}

"\n\nThis field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).\n\n"
type LineItemConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [LineItemEdge]!
}

"""A Relay edge containing a `LineItem` and its cursor."""
type LineItemEdge {
  """The item at the end of the edge"""
  node: LineItemType

  """A cursor for use in pagination"""
  cursor: String!
}

"""A record of spend on consumption between two points in time."""
type LineItemType {
  startAt: DateTime
  endAt: DateTime
  netAmount: Decimal
  numberOfUnits: Decimal
  itemType: String
  settlementUnit: String
}

"""An enumeration."""
enum LineItemGroupingOptions {
  NONE
  HALF_HOUR
  HOUR
  DAY
  WEEK
  MONTH
  QUARTER
}

"""An enumeration."""
enum LineItemTypeOptions {
  STANDING_CHARGE
  CONSUMPTION_CHARGE
}

type ElectricityContractUnitRateUplift {
  """When this contract is valid from."""
  validFrom: DateTime!

  """When this contract is valid until."""
  validTo: DateTime!

  """The amount to add to the unit rate when billing, in pence/kWh."""
  unitRateUplift: Decimal!
}

"""
The smart tariff onboarding process. Only relevant for Kraken instances that support half hourly tariffs. Returns null if not applicable.
"""
type SmartTariffOnboardingType {
  id: ID!
  latestStatus: SmartOnboardingEventTypes
  latestTermsStatus: SmartOnboardingTermsStatuses
  smartTariffCode: SmartOnboardingTariffCodes
  lastUpdated: String
}

"""An enumeration."""
enum SmartOnboardingEventTypes {
  """Started."""
  STARTED

  """Completed."""
  COMPLETED

  """Cancelled."""
  CANCELLED

  """Note Added."""
  NOTE_ADDED

  """Meter Exchange Email Sent."""
  METER_EXCHANGE_EMAIL_SENT

  """Meter Exchange Booked."""
  METER_EXCHANGE_BOOKED

  """Meter Installed."""
  METER_INSTALLED

  """Meter Readings Available."""
  METER_READINGS_AVAILABLE

  """Terms Email Sent."""
  TERMS_EMAIL_SENT

  """Terms Accepted."""
  TERMS_ACCEPTED

  """Agreements Updated."""
  AGREEMENTS_UPDATED

  """Tariff Switch Confirmation Email Sent."""
  TARIFF_SWITCH_CONFIRMATION_EMAIL_SENT

  """Tariff Changed On Meter."""
  TARIFF_CHANGED_ON_METER

  """Unable To Proceed."""
  UNABLE_TO_PROCEED

  """Previous Agreement Billing Gap Filled."""
  PREVIOUS_AGREEMENT_BILLING_GAP_FILLED
}

"""An enumeration."""
enum SmartOnboardingTermsStatuses {
  """Customer acceptance of T&Cs required"""
  TERMS_ACCEPTANCE_REQUIRED

  """Awaiting customer acceptance of T&Cs"""
  TERMS_EMAIL_SENT

  """T&Cs accepted"""
  TERMS_ACCEPTED
}

"""An enumeration."""
enum SmartOnboardingTariffCodes {
  """Octopus Energy's Agile Octopus tariff"""
  AGILE_OCTOPUS

  """Octopus Energy's Octopus Go tariff"""
  OCTOPUS_GO

  """Octopus Energy's Octopus Go Faster tariff"""
  OCTOPUS_GO_FASTER

  """Octopus Energy's Octopus Go Green tariff"""
  OCTOPUS_GO_GREEN

  """Octopus Energy's Tesla Energy Plan import tariff"""
  TESLA_IMPORT

  """Octopus Energy's Intelligent Octopus Go tariff"""
  INTELLIGENT_OCTOPUS

  """Octopus Energy's Intelligent Octopus Flux tariff"""
  INTELLIGENT_FLUX

  """Octopus Energy's Outgoing Fixed tariff"""
  OUTGOING_FIXED

  """Octopus Energy's Octopus Agile tariff"""
  OUTGOING_AGILE

  """Octopus Energy's Cosy Octopus tariff"""
  COSY_OCTOPUS

  """Octopus Energy's Flux tariff"""
  OCTOPUS_FLUX

  """Octopus Energy's Powerloop tariff"""
  POWERLOOP
}

"""
A electricity meter reading. A reading can in fact contain multiple values for each register (for example for ECO7). They are collected under a common read_at datetime and have a common fuel type.
"""
type ElectricityMeterReadingType implements MeterReading {
  id: ID!
  readAt: DateTime
  readingSource: String
  registers: [RegisterReading]
  source: String
}

interface MeterReading {
  readAt: DateTime
  readingSource: String
  registers: [RegisterReading]
  source: String
}

type RegisterReading {
  identifier: String
  name: String
  value: String
  digits: Int
  isQuarantined: Boolean
}

"""An enumeration."""
enum ElectricityMeterMeterType {
  """Check"""
  CHECK

  """Half Hourly"""
  H

  """Key"""
  K

  """Lag"""
  LAG_

  """Lead"""
  LEAD_

  """Main"""
  MAIN_

  """Non-Half Hourly"""
  N

  """Non-remotely Configurable Automated Meter Reading"""
  NCAMR

  """
  A meter that meets the definition of an ADM but is not compliant with any version of SMETS
  """
  NSS

  """
  Remotely Configurable Automated Meter Reading without remote enable/disable capability
  """
  RCAMR

  """
  Remotely Configurable Automated Meter Reading with remote enable/disable capability
  """
  RCAMY

  """Smartcard Prepayment"""
  S

  """
  A meter that is compliant with the Smart Metering Equipment Technical Specifications 1 (SMETS1)
  """
  S1

  """A single element meter that is compliant with SMETS2"""
  S2A

  """A twin element meter that is compliant with SMETS2"""
  S2B

  """A polyphase meter that is compliant with SMETS2"""
  S2C

  """
  A single element meter with one or more ALCS that is compliant with SMETS2
  """
  S2AD

  """
  A twin element meter with one or more ALCS that is compliant with SMETS2
  """
  S2BD

  """A polyphase meter with one or more ALCS that is compliant with SMETS2"""
  S2CD

  """
  Single element meter with one or more ALCS and Boost Function that is compliant with SMETS2
  """
  S2ADE

  """
  A twin element meter with one or more ALCS and Boost Function that is compliant with SMETS2
  """
  S2BDE

  """
  A polyphase meter with one or more ALCS and Boost Function that is compliant with SMETS2
  """
  S2CDE

  """Special"""
  SPECL

  """Token"""
  T

  """Single Element with APC that is compliant with SMETS2"""
  A_2AF

  """Single Element with ALCS and APC that is compliant with SMETS2"""
  A_2ADF

  """
  Single Element with Boost Function and APC that is compliant with SMETS2
  """
  A_2AEF

  """
  Single Element with ALCS, Boost Function and APC that is compliant with SMETS2
  """
  A_2ADEF

  """Twin Element  with APC that is compliant with SMETS2"""
  A_2BF

  """Twin Element with ALCS and APC that is compliant with SMETS2"""
  A_2BDF

  """Twin Element with Boost Function and APC that is compliant with SMETS2"""
  A_2BEF

  """
  Twin Element with ALCS, Boost Function and APC that is compliant with SMETS2
  """
  A_2BDEF

  """Polyphase with APC that is compliant with SMETS2"""
  A_2CF

  """Polyphase with ALCS and APC that is compliant with SMETS2"""
  A_2CDF

  """Polyphase with Boost Function and APC that is compliant with SMETS2"""
  A_2CEF

  """
  Polyphase with ALCS, Boost Function and APC that is compliant with SMETS2
  """
  A_2CDEF
}

type ElectricityMeterTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ElectricityMeterTypeEdge]!
}

"""A Relay edge containing a `ElectricityMeterType` and its cursor."""
type ElectricityMeterTypeEdge {
  """The item at the end of the edge"""
  node: ElectricityMeterType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
The ledgers associated to a prepayment meter. There are three types: a credit ledger for mirroring the meter's credit balance, a debt ledger for mirroring the meter's debt balance and payment ledger which is the inflight payments that we have not yet managed to resolve on the other two ledgers.
"""
type PrepayLedgersType {
  creditLedger: SupplementaryLedgerType
  debtLedger: SupplementaryLedgerType
  paymentLedger: PrepayPaymentLedgerType
}

"""
The in-flight payment ledger tracks the status of payments made to a prepay meter.
"""
type PrepayPaymentLedgerType implements SupplementaryLedgerInterface {
  id: ID

  """The display name of the ledger."""
  name: String
  ledgerType: String

  """The current final balance of the ledger in pence."""
  currentBalance: Int
  paymentAdequacy: PaymentAdequacyDetailsType

  """Payments made to add credit to a smart prepay meter."""
  payments: [PrepayPaymentType]

  """Transfers of credit from the account ledger to a smart prepay meter."""
  creditTransfers: [PrepayCreditTransferType]
}

type PrepayPaymentType {
  id: ID!

  """Amount of payment in pence"""
  amount: BigInt!

  """The date this payment is scheduled to be debited"""
  paymentDate: Date!
  smartPrepayStatus: SmartPrepayPaymentStatusChoices @deprecated(reason: "The 'smartPrepayStatus' field is deprecated.\n\n\nPlease use the 'smartPrepayProcessStatus' type instead for a more granular status.\n\n\n- Marked as deprecated on 2023-09-05.\n- Will be removed on 2024-01-01.")
  smartPrepayProcessStatus: SmartPrepayProcessStatusChoices
  utrn: String!
  meter: Meter
}

enum SmartPrepayPaymentStatusChoices {
  UTRN_REQUESTED
  UTRN_RECEIVED
  ACCEPTED_BY_METER
  RESOLVED
}

enum SmartPrepayProcessStatusChoices {
  NOT_STARTED
  INITIATED
  PENDING
  COMPLETED
  FAILED
  UTRN_MUST_BE_APPLIED_MANUALLY
}

type PrepayCreditTransferType {
  id: ID!

  """"""
  netAmount: BigInt!
  createdDate: Date!
  smartPrepayStatus: SmartPrepayPaymentStatusChoices @deprecated(reason: "The 'smartPrepayStatus' field is deprecated.\n\n\nPlease use the 'smartPrepayProcessStatus' type instead for a more granular status.\n\n\n- Marked as deprecated on 2023-09-05.\n- Will be removed on 2024-01-01.")
  smartPrepayProcessStatus: SmartPrepayProcessStatusChoices
  utrn: String
}

"\n\nThis field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).\n\n"
type ElectricityMeterReadingConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ElectricityMeterReadingConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `ElectricityMeterReadingConnectionType` and its cursor.
"""
type ElectricityMeterReadingConnectionTypeEdge {
  """The item at the end of the edge"""
  node: ElectricityMeterReadingType

  """A cursor for use in pagination"""
  cursor: String!
}

"""Electricity registers measure consumption."""
type ElectricityMeterRegisterType {
  id: ID!
  identifier: String
  digits: Int
  decimalPlaces: Int
  name: String
  expectedReadingRanges: [[Int]]
  timePatternRegime: String
  unitRateType: String
  eac: Decimal
  multiplier: Float
}

"""
A gas meter has a register which holds readings. We would expect this to be a one-to-one relationship between meter and register.
"""
type GasMeterType implements Node & Meter {
  id: ID!
  serialNumber: String!
  requiresAccess: Boolean
  isDigital: Boolean
  installationDate: Date
  lastInspectionDate: Date
  createdAt: DateTime!
  updatedAt: DateTime
  activeFrom: Date!
  activeTo: Date
  meterPoint: GasMeterPointType!
  manufacturerCode: String!
  modelName: String!
  manufacturedYear: Int
  meterType: String!
  imperial: Boolean
  units: Int!
  location: String!
  mechanism: GasMeterMechanism
  correction: Float
  locationDescription: String!
  readingFactor: Decimal
  instructions: String!
  pulseValue: Decimal
  linkCode: String!
  collarFitted: String!
  bypassFitted: String!
  measuringCapacity: Decimal
  status: GasMeterStatus
  operationalStatusDate: Date
  owner: String!
  currentMeterAssetManager: String!
  prepayLedgers: PrepayLedgersType
  smartGasMeter: SmartMeterDeviceType

  """The units of consumption for a smart meter."""
  consumptionUnits: String

  """Whether this meter requires a final change of tenancy (COT) reading."""
  requiresCotFinalReading: Boolean

  """The type of fuel this meter uses."""
  fuelType: String

  """Energy consumption recorded by the meter."""
  consumption(
    """Earliest consumption reading to return. Must specify a timezone."""
    startAt: DateTime!

    """Aggregate consumption according to this grouping."""
    grouping: ConsumptionGroupings!

    """Timezone to use for grouping."""
    timezone: String!
    before: String
    after: String
    first: Int
    last: Int
  ): ConsumptionConnection

  """
  This lets us get around the fact that we already use the field id as a primary key. We will migrate the id field over to be this id eventually.
  """
  nodeId: ID!
  readings(before: String, after: String, first: Int, last: Int): GasMeterReadingConnectionTypeConnection
  registers: [GasMeterRegisterType]

  """Returns if the meter has and allows half hourly readings"""
  hasAndAllowsHhReadings: Boolean
  smartDevices: [SmartMeterDeviceType]

  """Returns if the meter is a traditional prepay meter."""
  isTradPrepay: Boolean

  """Returns if the meter is ready for top up."""
  isReadyForTopup: Boolean
}

"""
A gas meterpoint is a collection of meters. Meters are changed over time, so it is convenient to keep an invariant reference. We would not expect there to be multiple active meters at a time on a gas meterpoint.
"""
type GasMeterPointType implements MeterPointInterface {
  id: ID!
  supplyEndDate: Date
  mprn: String
  statusUpdatedAt: DateTime
  oldSupplierId: String
  newSupplierId: String
  smartStartDate: Date
  requiresEnrolment: Boolean!
  targetSsd: Date
  requiresWithdrawal: Boolean!
  hasOpenOpeningReadDispute: Boolean!
  hasOpenClosingReadDispute: Boolean!
  marketSectorCode: GasMeterPointMarketSectorCode
  marketCategory: GasMeterPointMarketCategory
  meterOwnershipType: GasMeterPointMeterOwnershipType
  confirmationReference: Int
  nominationType: String!
  supplyClass: Int!
  nominationShipperReference: String!

  """Industry status code"""
  xoserveStatus: String
  exitCapacityChargeRate: Decimal
  ldzCapacityChargeRate: Decimal
  ldzCommodityChargeRate: Decimal
  ldzCustomerChargeRate: Decimal
  ntsExitCommodityChargeRate: Decimal
  mrfType: String!
  meterReadBatchFrequency: String!

  """SOQ fixed for year"""
  formulaYearSmpSoq: Int

  """AQ fixed for year"""
  formulaYearSmpAq: Int

  """Rolling SOQ"""
  currentDmSoq: Int

  """Rolling SOQ"""
  currentNdmSoq: Int
  exitZone: String!

  """Local distribution zone - Distribution charges are based upon this"""
  ldz: String!
  supplyPointCategory: String!
  endUserCategory: Int
  eucIdentifier: String
  igtIdentifier: String!
  igtCheckedAt: DateTime
  meters(id: Int, includeInactive: Boolean): [GasMeterType]
  status: String

  """Details of an ongoing enrolment process."""
  enrolment: EnrolmentType

  """A list of agents responsible for management of the meterpoint."""
  agentContracts(
    """Filter the contracts by status."""
    statuses: [AgentContractStatusType]
  ): [GasAgentContractType]

  """
  A list of gas agreements belonging to an account that is linked to the viewer. Filters out expired agreements by default.
  """
  agreements(
    validAfter: DateTime
    includeInactive: Boolean

    """Exclude agreements starting in the future."""
    excludeFuture: Boolean
  ): [GasAgreementType]

  """A list of unbilled gas readings for the meterpoint."""
  unbilledReadings: [GasMeterReadingType]
}

"""An enumeration."""
enum GasMeterPointMarketSectorCode {
  """Domestic"""
  D

  """Industrial"""
  I
}

"""An enumeration."""
enum GasMeterPointMarketCategory {
  """SSP"""
  SSP

  """LSP"""
  LSP
}

"""An enumeration."""
enum GasMeterPointMeterOwnershipType {
  """Transporter"""
  T

  """Supplier"""
  S

  """Customer"""
  C
}

"""An organization who manages a given meterpoint."""
type GasAgentContractType {
  contractType: GasAgentContactContractType!
  agentId: String
  contractStatus: AgentContractStatusType
  effectiveFrom: Date
}

"""An enumeration."""
enum GasAgentContactContractType {
  """Meter Asset Manager"""
  MAM

  """Meter Reader Agent"""
  MRA
}

type GasAgreementType implements AgreementInterface {
  id: Int
  validFrom: DateTime
  validTo: DateTime
  agreedFrom: DateTime
  agreedTo: DateTime
  account: AccountType!
  meterPoint: GasMeterPointType!
  tariff: GasTariffType
  isRevoked: Boolean

  """A collection of charges and associated consumption data."""
  lineItems(
    startAt: DateTime!

    """
    Aggregate line items according to this grouping. Note that this doesn't guarantee that the returned items will cover a particular length of time, as it will depend on how the items have been stored, whether the period had daylight savings time changes (and therefore potentially 25 hours) etc.
    """
    grouping: LineItemGroupingOptions!
    itemType: LineItemTypeOptions!

    """Timezone used for grouping."""
    timezone: String!
    before: String
    after: String
    first: Int
    last: Int
  ): LineItemConnection

  """
  List of contracted unit rate uplifts applicable during this agreement's duration. This is only applicable to business accounts where we may pay commission to a third-party intermediary.
  """
  unitRateUplifts: [GasContractUnitRateUplift]
}

type GasTariffType implements TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float

  """
  Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  """
  tariffCode: String
  unitRate: Float

  """Is EPG applied to the unit rate."""
  unitRateEpgApplied: Boolean
  preVatUnitRate: Float
}

type GasContractUnitRateUplift {
  """When this contract is valid from."""
  validFrom: DateTime!

  """When this contract is valid until."""
  validTo: DateTime!

  """The amount to add to the unit rate when billing, in pence/kWh."""
  unitRateUplift: Decimal!
}

"""
A gas meter reading. The reading value is under the register collection to be consistent with electricity readings. We expect a single register and reading value for gas.
"""
type GasMeterReadingType implements MeterReading {
  id: ID!
  readAt: DateTime
  readingSource: String
  registers: [RegisterReading]
  source: String
}

"""An enumeration."""
enum GasMeterMechanism {
  """Credit"""
  CR

  """Electronic Token Meter"""
  ET

  """Prepayment"""
  PP

  """Mechanical Token Meter"""
  MT

  """Coin Meter"""
  CM

  """Thrift"""
  TH

  """Non Compliant SMETS Smart Meter"""
  NS

  """SMETS 1 compliant Smart Meter"""
  S1

  """SMETS 2 compliant Smart Meter"""
  S2

  """Unknown"""
  U
}

"""An enumeration."""
enum GasMeterStatus {
  """Live"""
  LI

  """Faulty"""
  FA

  """Inactive"""
  IN

  """Cut off"""
  CU

  """Clamped"""
  CL

  """Capped"""
  CA

  """Spin Cap"""
  SP

  """Removed"""
  RE

  """Other"""
  OT

  """Unknown"""
  UN

  """Not Installed"""
  NI
}

"\n\nThis field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).\n\n"
type GasMeterReadingConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [GasMeterReadingConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `GasMeterReadingConnectionType` and its cursor.
"""
type GasMeterReadingConnectionTypeEdge {
  """The item at the end of the edge"""
  node: GasMeterReadingType

  """A cursor for use in pagination"""
  cursor: String!
}

"""Gas registers measure consumption."""
type GasMeterRegisterType {
  id: ID!
  identifier: String
  digits: Int
  decimalPlaces: Int
  name: String
  expectedReadingRanges: [[Int]]
  unitRateType: String
}

"""An enumeration."""
enum DeviceType {
  """Electricity Smart Meter (ESME)"""
  ESME

  """Gas Smart Meter (GSME)"""
  GSME

  """Gas Proxy Function (GPF)"""
  GPF

  """Communications Hub Function (CHF)"""
  CHF

  """HAN Connected Auxiliary Load Control Switch (HCALCS)"""
  HCALCS

  """Prepayment Interface Device (PPMID)"""
  PPMID

  """In-House Display (IHD)"""
  IHD

  """Consumer Access Device (CAD)"""
  CAD

  """IHD or CAD (a type 2 device)"""
  IHD_OR_CAD
}

"""An enumeration."""
enum DeviceStatus {
  """Pending"""
  PENDING

  """Whitelisted"""
  WHITELISTED

  """Installed but not commissioned"""
  INSTALLED_NOT_COMMISSIONED

  """Commissioned"""
  COMMISSIONED

  """Decommissioned"""
  DECOMMISSIONED

  """Withdrawn"""
  WITHDRAWN

  """Suspended"""
  SUSPENDED

  """In recovery"""
  RECOVERY

  """Recovered"""
  RECOVERED

  """Not Applicable"""
  NOT_APPLICABLE
}

"\n    The mode used by a SMETS2 meter to charge for energy consumed.\n\n    Energy consumption can either be paid for in advance (i.e. prepay / pay-as-you-go)\n    or at some time later (i.e. credit).\n    "
enum PaymentMode {
  """Prepayment."""
  PREPAY

  """Credit."""
  CREDIT
}

"""An enumeration."""
enum DeviceStatuses {
  """Pending"""
  PENDING

  """Device has been whitelisted"""
  WHITELISTED

  """Installed but not commissioned"""
  INSTALLED_NOT_COMMISSIONED

  """Device has been commissioned"""
  COMMISSIONED

  """Device has been decommissioned"""
  DECOMMISSIONED

  """Device has been withdrawn"""
  WITHDRAWN

  """Decice suspended"""
  SUSPENDED

  """Device is in recovery mode"""
  RECOVERY

  """Device recovered"""
  RECOVERED

  """Not applicable"""
  NOT_APPLICABLE
}

"""An enumeration."""
enum WANCoverageStrengths {
  """WAN coverage for this postcode is high quality."""
  HIGH

  """WAN coverage for this postcode is medium quality."""
  MEDIUM

  """WAN coverage for this postcode is low quality."""
  LOW
}

"""
A timeslot for which a property can make an appointment for installation of a smart-meter.
"""
type Smets2InstallationTimeslotType {
  appointmentDate: Date
  startTime: Time
  endTime: Time
}

"""
The `Time` scalar type represents a Time value as
specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Time

type WarmHomeDiscount {
  """
  Get the Warm Home Discount applications against this account. These are ordered to return the most recent first.
  """
  applications(before: String, after: String, first: Int, last: Int): WarmHomeDiscountApplicationConnection

  """
  Get the Warm Home Discount records attached to this account. These are ordered to return the most recent first.
  """
  records(before: String, after: String, first: Int, last: Int): WarmHomeDiscountRecordConnection
}

"\n\nThis field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).\n\n"
type WarmHomeDiscountApplicationConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [WarmHomeDiscountApplicationEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `WarmHomeDiscountApplication` and its cursor.
"""
type WarmHomeDiscountApplicationEdge {
  """The item at the end of the edge"""
  node: WarmHomeDiscountApplication

  """A cursor for use in pagination"""
  cursor: String!
}

"""Get details about a Warm Home Discount application."""
type WarmHomeDiscountApplication {
  """Which criteria was chosen for the Warm Home Discount application"""
  qualifyingCriteria: QualifyingCriteriaOptions

  """
  Which component criteria was chosen for the Warm Home Discount application
  """
  qualifyingComponent: QualifyingComponentOptions
  yearEnding: Int!

  """The status of the Warm Home Discount application"""
  status: Status

  """Reason for rejecting a Warm Home Discount application"""
  rejectionReason: BroaderGroupRejectionReason

  """The tax year for which the application was made."""
  taxYear: String

  """The last date on which this application was updated."""
  updatedAt: Date
}

"""An enumeration."""
enum QualifyingCriteriaOptions {
  """In receipt of the Savings Element of Pension Credit only"""
  SAVINGS_ELEMENT_OF_PENSION_CREDIT

  """
  In receipt of Council Tax Reduction (excludes the 25% single persons discount)
  """
  COUNCIL_TAX_REDUCTION

  """In receipt of Income Support"""
  INCOME_SUPPORT

  """In receipt of Income-based Job Seekers Allowance (JSA)"""
  JOB_SEEKERS_ALLOWANCE

  """In receipt of Income-related Employment & Support Allowance (ESA)"""
  EMPLOYMENT_AND_SUPPORT_ALLOWANCE

  """
  In receipt of Working Tax Credit with a total annual household income of 18,723 or less (before tax and National Insurance)
  """
  WORKING_TAX_CREDIT

  """
  In receipt of Housing Benefit with a total annual household income of 18,723 or less (before tax and National Insurance)
  """
  HOUSING_BENEFIT

  """
  In receipt of Child Tax Credit where the award statement shows a total annual household income of 18,723 or less (before tax and National Insurance)
  """
  CHILD_TAX_CREDIT

  """
  In receipt of universal credit, and has an earned income of between zero and 1,561 in at least one of the twelve preceding assessment periods
  """
  UNIVERSAL_CREDIT

  """
  A total annual household income of 18,723 or less (before tax and National Insurance)
  """
  LOW_INCOME_THRESHOLD
}

"\n    A list of all current and historic WHD qualifying component options.\n\n    All label strings correspond to specific wording of the most recent scheme.\n    "
enum QualifyingComponentOptions {
  """In receipt of Personal Independence Payments (PIP)"""
  PERSONAL_INDEPENDENCE_PAYMENTS

  """
  In receipt of Disability Living Allowance (DLA), any disability premium (all rates) or disabled child element of Universal Credit
  """
  DISABILITY_BENEFITS

  """
  In receipt of any Income-related benefit which includes: Carers Premium and Carers Allowance (for someone within the household) OR Attendance Allowance (for applicant or their partner) OR Industrial Injuries Benefit
  """
  INCOME_RELATED_BENEFITS

  """Hold a Maternity Exemption Certificate (MATEX)"""
  MATERNITY_EXEMPTION_CERTIFICATE

  """Are aged 62 and over (OR in receipt of any pensioner premium)"""
  AGE_THRESHOLD

  """Have a medically dependant illness (disability or mobility issue)"""
  HAS_DISABILITY

  """In receipt of Adult Disability Payment (ADP)"""
  ADULT_DISABILITY_PAYMENT

  """
  Have a dependent child under 5 (dependent child who normally resides with the applicant)
  """
  DEPENDENT_CHILD_UNDER_FIVE

  """
  Have a dependent child aged 5  16 or under 18 if in full time education (dependent child who normally resides with the applicant)
  """
  DEPENDENT_CHILD_OVER_FIVE

  """
  In receipt of the limited capability for work element of Universal Credit
  """
  LIMITED_CAPABILITY_FOR_WORK

  """Hold a Medical Exemption Certificate (MEDEX)"""
  MEDICAL_EXEMPTION_CERTIFICATE

  """
  Are exempt from prescription charges (only for customers in England) or hold a HC2 certificate
  """
  PRESCRIPTION_CHARGES_EXEMPTION

  """
  Hold a valid war pension NHS exemption certificate and the prescription is for your disability
  """
  WAR_PENSION_EXEMPTION_CERTIFICATE
}

"""An enumeration."""
enum Status {
  """Pending"""
  PENDING

  """Awaiting audit"""
  AWAITING_AUDIT

  """Awaiting customer evidence"""
  AWAITING_CUSTOMER_EVIDENCE

  """Approved"""
  APPROVED

  """Rejected"""
  REJECTED

  """Withdrawn"""
  WITHDRAWN

  """Approved (customer service gesture)"""
  APPROVED_CUSTOMER_SERVICE_GESTURE
}

"""An enumeration."""
enum BroaderGroupRejectionReason {
  APPLICATIONS_NOT_OPEN
  ALREADY_RECEIVED_DISCOUNT
  HAS_OPEN_APPLICATION
  HAS_CORE_GROUP_DISCOUNT
  INSUFFICIENT_EVIDENCE_PROVIDED
  NO_LONGER_ON_SUPPLY
  DUPLICATE
  NOT_IN_SCOTLAND
  BUSINESS_ACCOUNT
  NON_DOMESTIC_METER_POINT
}

"\n\nThis field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).\n\n"
type WarmHomeDiscountRecordConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [WarmHomeDiscountRecordEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""A Relay edge containing a `WarmHomeDiscountRecord` and its cursor."""
type WarmHomeDiscountRecordEdge {
  """The item at the end of the edge"""
  node: WarmHomeDiscountRecord

  """A cursor for use in pagination"""
  cursor: String!
}

"""Get details about a Warm Home Discount record."""
type WarmHomeDiscountRecord {
  """
  Type of account receiving the discount. Either credit the account or payment via prepay cards
  """
  accountType: WhdAccountType
  yearEnding: Int!

  """Which criteria was chosen for the Warm Home Discount."""
  qualifyingCriteria: QualifyingCriteriaOptions

  """Which component criteria was chosen for the Warm Home Discount."""
  qualifyingComponent: QualifyingComponentOptions

  """
  Amount in pence that was credited to the account as a result of the discount.
  """
  credit: Int

  """The tax year for which the credit was given."""
  taxYear: String
}

"""An enumeration."""
enum WhdAccountType {
  SMART_PREPAY
  TRADITIONAL_PREPAY
  CREDIT
}

type WarmHomeDiscountEligibility {
  """
  Is the customer eligible to apply for the Warm Home Discount as part of the Scottish Broader Group.
  """
  isEligible: Boolean

  """Reason why the customer is unable to apply."""
  rejectionReason: String
}

type TrackerTariffDailyPricing {
  """URL for tracker demo"""
  demoUrl: String

  """Today's electricity costs (in pence)"""
  electricity: Int

  """Today's gas costs (in pence)"""
  gas: Int
}

type PaymentAdequacyType {
  """
  The suggested monthly payment amount in pence following the payment adequacy review.
  """
  suggestedDirectDebitAmount: Int
}

"""An enumeration."""
enum SmartMeterInterestChoices {
  """
  We have captured that this account is interested in a SMETS2 meter. This does not mean they've booked an appointment.
  """
  INTERESTED

  """
  We have captured that this account could be interested in a SMETS2 meter in the future, so it is appropriate to follow up with them.
  """
  NOT_AT_THE_MOMENT

  """
  We have captured that this account is not interested in a SMETS2 meter. We should use this to avoid advertising SMETS2 meters to them, or contacting them about installing a SMETS2 meter.
  """
  NOT_INTERESTED
}

"""An enumeration."""
enum SMETS2InterestReason {
  """You can't offer me a suitable appointment time."""
  SMETS2_INTEREST_REASON_CANNOT_ATTEND_APPOINTMENT

  """I don't trust my data will be safe."""
  SMETS2_INTEREST_REASON_WORRIED_SECURITY

  """I think a smart meter will harm my health."""
  SMETS2_INTEREST_REASON_WORRIED_HEALTH_SAFETY

  """I think smart meters will cost me more."""
  SMETS2_INTEREST_REASON_WORRIED_ABOUT_USAGE_COST

  """I need to speak to my landlord."""
  SMETS2_INTEREST_REASON_DO_NOT_OWN_HOME

  """I'm waiting for SMETS2 PAYG meters to be available."""
  SMETS2_INTEREST_REASON_WAITING_FOR_SMETS2_PAYG

  """I don't see the benefits in having a smart meter."""
  SMETS2_INTEREST_REASON_CANNOT_SEE_BENEFIT

  """Topping up with smart PAYG isn't suitable for me."""
  SMETS2_INTEREST_REASON_SMART_PAYG_NOT_SUITABLE

  """I don't trust the safety of the installation."""
  SMETS2_INTEREST_REASON_WORRIED_ABOUT_INSTALLATION

  """Long term opt out."""
  SMETS2_INTEREST_REASON_LONG_TERM_OPT_OUT

  """No time to talk."""
  SMETS2_INTEREST_REASON_NO_TIME_TO_TALK

  """Not decision maker/need to speak to someone."""
  SMETS2_INTEREST_REASON_NOT_DECISION_MAKER

  """I'm planning to change to a new supplier."""
  SMETS2_INTEREST_REASON_SWITCH_IMMINENT

  """I'm planning to move to a new property."""
  SMETS2_INTEREST_REASON_HOUSE_MOVE_IMMINENT

  """There's been a recent bereavement in the household."""
  SMETS2_INTEREST_REASON_RECENT_BEREAVEMENT

  """I/my family are currently self-isolating Covid-19."""
  SMETS2_INTEREST_REASON_COVID_SELF_ISOLATING

  """I do not want anyone visiting my property Covid-19."""
  SMETS2_INTEREST_REASON_COVID_DO_NOT_WANT_PROPERTY_VISITORS

  """I am caring for someone vulnerable Covid-19."""
  SMETS2_INTEREST_REASON_COVID_CARING_FOR_VULNERABLE

  """I don't want to change my switching times."""
  SMETS2_INTEREST_REASON_DO_NOT_WANT_TO_CHANGE_SWITCHING_TIMES

  """I want to keep a mix of Credit and Prepayment Meters."""
  SMETS2_INTEREST_REASON_KEEP_MIX_METER_TYPES

  """EX - 3 Phase Meter."""
  SMETS2_INTEREST_REASON_EXCLUSION_THREE_PHASE_METER

  """EX - Alternative HAN Equipment required."""
  SMETS2_INTEREST_REASON_EXCLUSION_ALTERNATIVE_HAN_EQUIPMENT_REQUIRED

  """EX - Asbestos on Site."""
  SMETS2_INTEREST_REASON_EXCLUSION_ASBESTOS_ON_SITE

  """EX - Book as two MT Appointment."""
  SMETS2_INTEREST_REASON_EXCLUSION_BOOK_AS_TWO_MT_APPOINTMENT

  """EX - Communal Cupboard."""
  SMETS2_INTEREST_REASON_EXCLUSION_COMMUNAL_CUPBOARD

  """EX - De-en or Meter Removal."""
  SMETS2_INTEREST_REASON_EXCLUSION_DEEN_OR_METER_REMOVAL

  """EX - Distribution Work Required at Property(category B)."""
  SMETS2_INTEREST_REASON_EXCLUSION_DISTRIBUTION_WORK_AT_PROPERTY_REQUIRED_CAT_B

  """EX - Dual Band Comms Hub Required."""
  SMETS2_INTEREST_REASON_EXCLUSION_DUAL_BAND_COMMS_HUB_REQUIRED

  """EX - Flat or Apartment."""
  SMETS2_INTEREST_REASON_EXCLUSION_FLAT_OR_APARTMENT

  """EX - Flue in Loft, Unable to Inspect."""
  SMETS2_INTEREST_REASON_EXCLUSION_FLUE_IN_LOFT

  """EX - Medium Pressure Gas."""
  SMETS2_INTEREST_REASON_EXCLUSION_MEDIUM_PRESSURE_GAS

  """EX - No Signal HAN."""
  SMETS2_INTEREST_REASON_EXCLUSION_NO_SIGNAL_HAN

  """EX - No Signal WAN."""
  SMETS2_INTEREST_REASON_EXCLUSION_NO_SIGNAL_WAN

  """EX - Permanent Meter Obstruction."""
  SMETS2_INTEREST_REASON_EXCLUSION_PERMANENT_METER_OBSTRUCTION

  """EX - Restricted Meter Space."""
  SMETS2_INTEREST_REASON_EXCLUSION_RESTRICTED_METER_SPACE

  """EX - Shared Fuse."""
  SMETS2_INTEREST_REASON_EXCLUSION_SHARED_FUSE

  """EX - Temporary Meter Obstruction."""
  SMETS2_INTEREST_REASON_EXCLUSION_TEMPORARY_METER_OBSTRUCTION
}

type GreenAccomplishmentsType {
  savedTrees: Int
  savedCo2InKgs: Int
}

"""Represents a print attachment"""
type PrintAttachmentType {
  id: ID!
  filename: String!
  s3Bucket: String!
  s3Key: String!

  """
  Temporary URL at which the attachment is available. This URL will expire after approximately an hour. It is intended for redirection purposes, NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
  """
  temporaryUrl: String
}

input ReplaceAgreementInput {
  """Account number."""
  accountNumber: String!

  """MPxN of the related meter point to the agreement."""
  mpxn: String!

  """Date to replace on, must be in future."""
  replaceOnDate: Date!

  """Product code to replace with."""
  newProductCode: String!
}

type InstallationType {
  """FIT ID of the installation."""
  fitId: String

  """Meter inspection date"""
  inspectionAt: DateTime

  """Details of any meters attached to the installation."""
  meters: [FitMeterType]

  """Address of the property linked to the installation."""
  propertyAddress: PropertyAddressType
}

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

type FitMeterType {
  """Serial number of the meter."""
  serialNumber: String

  """ID of the meter."""
  id: String

  """The type of meter."""
  type: String
  readings(before: String, after: String, first: Int, last: Int): FitReadingConnectionTypeConnection

  """Any installation capacities linked to the meter."""
  installationCapacities: [InstallationCapacityType]

  """
  The maximum read volume expected for the current datetime, including any extra tolerance allowed.
  """
  maxExpectedRead: Decimal

  """MPAN of the meter point linked to the meter."""
  mpan: String
}

type FitReadingConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [FitReadingConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""A Relay edge containing a `FitReadingConnectionType` and its cursor."""
type FitReadingConnectionTypeEdge {
  """The item at the end of the edge"""
  node: FitReadingType

  """A cursor for use in pagination"""
  cursor: String!
}

type FitReadingType {
  value: Decimal!
  readAt: DateTime!
  isBiennial: Boolean
}

"""The `Decimal` scalar type represents a python Decimal."""
scalar Decimal

type InstallationCapacityType {
  declaredNetCapacity: Decimal!
  extensionReference: String!
  installedCapacity: Decimal!
}

type PropertyAddressType {
  addressLine1: String!
  addressLine2: String!
  town: String!
  county: String!
  country: String!
  postcode: String!
}

"""
Mutations are the GraphQL equivalent of POST requests in REST. By convention, they are used when data is mutated on the server. To learn about how to form Mutations in graphql, see [GraphQL's documentation](https://graphql.org/learn/queries/#mutations).

 This interface will autocomplete, so just try typing what you want. You can also search these docs. Some mutations will require authentication. Check the documentation or search `Authentication` for details.
"""
type Mutation {
  """
  DO NOT USE: WIP Create a quote for new meter points for products with passed in tag.
  """
  quoteNewMeterPoints(input: QuoteNewMeterPointsInput!): QuoteNewMeterPoints

  "DO NOT USE: WIP Create a quote for new meter points on passed in products with bespoke rates. This is an acquisition quote mutation only to be used by authenticated third party organisations for bespoke quoting.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4616: Unable to create a quote.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  quoteNewMeterPointsOnBespokeProducts(input: QuoteNewMeterPointsOnBespokeProductsInput!): QuoteNewMeterPointsOnBespokeProducts

  "DO NOT USE: WIP Create a quote for an existing account for the specified meterpoints on the passed in products.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4616: Unable to create a quote.\n- KT-GB-4614: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  quoteAccountOnProducts(input: QuoteAccountOnProductsInput!): QuoteAccountOnProducts

  "Create meter points without enrolment.\n\nThe possible errors that can be raised are:\n\n- KT-GB-5610: Account does not exist.\n- KT-GB-5611: Product must have exactly one context.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createMeterPoints(
    """
    This mutation takes the same input as the `SignUp` mutation. As such `targetStartDate`, `products.code` and `products.context.*.registrationType` are all required and must be given valid values. However they will be ignored, since this mutation doesn't enrol meter points or create agreements.
    """
    input: SignUpInput!
  ): CreateMeterPoints @deprecated(reason: "The 'createMeterPoints' field is deprecated.\n\nThe `createMeterPoints` mutation will be removed once the `SignUp` mutation can defer gas new connections which don't yet have a meter attached.\n\n- Marked as deprecated on 2022-06-25.\n- Will be removed on 2024-01-01.")

  """Create a renewal quote request."""
  createRenewalQuoteRequest(input: CreateRenewalQuoteRequestInput!): CreateRenewalQuoteRequest

  "Create a renewal quote request for specified products without persisting to the database.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4624: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createQuoteRequestForProducts(input: CreateQuoteRequestForProductsInput!): CreateQuoteRequestForProducts

  "Create an acquisition quote request for requested products without persisting to the database.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4625: Unable to create quote request.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  createAcquisitionQuoteRequestForProducts(input: CreateAcquisitionQuoteRequestForProductsInput!): CreateAcquisitionQuoteRequestForProducts

  "Add a refund request to an account.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4127: Unable to send refund request confirmation email.\n- KT-GB-4121: Unable to process refund request.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createRefundRequest(
    """Input fields for creating a refund request."""
    input: RefundRequestInput!
  ): CreateRefundRequest

  "Update smart meter data preferences of an account. Includes updating reading frequency and readings analysis consent.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4023: Unauthorized.\n- KT-GB-4015: Cannot update smart meter reading frequency preferences.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  updateSmartMeterDataPreferences(
    """Input fields for updating smart meter data preferences."""
    input: UpdateSmartMeterDataPreferencesInput!
  ): UpdateSmartMeterDataPreferences

  "Joins a device to a HAN (Home Area Network).\n\nThe possible errors that can be raised are:\n\n- KT-GB-4019: This device type is not currently supported.\n- KT-GB-4020: Error sending the request to join the device to the Home Area Network.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  joinDeviceToNetwork(
    """Device ID of the CHF (Communications Hub Function)."""
    chfDeviceId: String!

    """Code that authorises joining of the device to the HAN."""
    installCode: String

    """MPAN/MPRN of the meter or HCALCS to join to the HAN."""
    mpxn: String

    """Device ID of the device to join to the HAN."""
    newDeviceId: String!

    """Type of device that is being joined to the HAN."""
    newDeviceType: JoinableDeviceType!
  ): JoinDeviceToNetwork

  "Commissions the device after the meter has been physically installed.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4021: Invalid MPxN.\n- KT-GB-4022: MPxN not recognised.\n- KT-GB-4023: Error sending the request to commission the device.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  commissionMeter(
    """Input fields for commission meters."""
    input: CommissionMeterInput!
  ): CommissionMeter

  "Decommissions a device using SmartPear's 'remove device' orchestration.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4024: The provided device ID does not match any devices known by Kraken.\n- KT-GB-4025: Error sending the request to decommission the device.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  decommissionSmartDevice(
    """Input fields for decommission meters."""
    input: DecommissionSmartDeviceInput!
  ): DecommissionSmartDevice

  """Notify Kraken to run the relevant prenotifications for a new device."""
  registerSmartDevice(
    """Specifies device metadata to use for prenotifications."""
    input: RegisterSmartDeviceInput!
  ): RegisterSmartDevice

  "Update the status of the CHF (Communictions Hub).\n\nThe possible errors that can be raised are:\n\n- KT-GB-4026: Either the mpxn or mpan input must be provided.\n- KT-GB-4027: If both mpxn and mpan are provided, they must match.\n- KT-GB-4028: Please input a valid MPxN.\n- KT-GB-4029: Meter point not found for MPAN.\n- KT-GB-4030: Meter point not found for MPRN.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  updateCommsHubStatus(
    """Input fields for updating the status of the communications hub."""
    input: UpdateCommsHubStatusInput!
  ): UpdateCommsHubStatus

  "Triggers the orchestration to join the PPMID, IHD, CAD or Alt HAN device to the ESME, GSME, GPF and/or CHF. This should be called after a meter has been commissioned.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4053: Fuel type should not be specified for Alt HAN device.\n- KT-GB-4031: Error sending the request to join the device to the CHF.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  joinConsumerDevice(
    """Input fields for join device."""
    input: JoinConsumerDeviceInput!
  ): JoinConsumerDevice

  "Triggers the orchestration to remove the CAD device to the ESME, GSME, GPF and CHF.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4012: Unable to find the CAD device.\n- KT-GB-4032: Error sending the request to remove the device.\n- KT-GB-4013: Received invalid device type to remove other than CAD.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  removeConsumerDevice(
    """Input fields for remove device."""
    input: RemoveConsumerDeviceInput!
  ): RemoveConsumerDevice

  """Add credit to a smart prepay meter"""
  addCreditToSmartMeter(
    """Controls which meter to top-up and by how much."""
    input: SmartPrepayMeterAmountInput!
  ): AddCreditToSmartMeter

  "Request an ad hoc read of the meters consumption data, which will arrive asynchronously\n\nThe possible errors that can be raised are:\n\n- KT-GB-4033: No electricity device found matching device ID.\n- KT-GB-4034: Error requesting consumption data.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  requestConsumptionData(
    """Input fields for requesting consumption data."""
    input: RequestConsumptionDataInput!
  ): RequestConsumptionData

  """
  Replace an existing Communications Hub with a new one and move existing devices to the new Hub.
  """
  replaceCommsHub(
    """Input fields for replacing a Communications Hub."""
    input: ReplaceCommsHubInput!
  ): ReplaceCommsHub

  """Create a payment intent."""
  createPaymentIntent(
    """Input fields for creating a payment intent."""
    input: CreatePaymentIntentInput!
  ): CreatePaymentIntent @deprecated(reason: "The 'createPaymentIntent' field is deprecated.\n\nPlease use 'initiateStandalonePayment' instead.\n\n- Marked as deprecated on 2023-01-10.\n- Will be removed on 2024-03-01.")

  "Add details to an existing occupier account.\n\nThe possible errors that can be raised are:\n\n- KT-GB-6622: Account not found.\n- KT-GB-6623: Property not found.\n- KT-CT-3814: Provided meter is not a prepayment meter.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  occupy(input: OccupyInput!): OccupyOutputType

  "Perform a move out of a property for an account.\n\nOptionally provide details of the new tenant and a property to perform a move in to.\n\n\n\nThe possible errors that can be raised are:\n\n- KT-GB-6624: An error occurred when trying to process this house move.\n- KT-GB-6625: An error occurred when trying to process this house move.\n- KT-GB-6626: There was an error processing the PSR data.\n- KT-GB-6627: There are missing agent appointments.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  performMoveOut(input: MoveOutInput!): PerformMoveOut

  """Create a shell/payment account."""
  createShellAccount(input: CreateShellAccountInput!): CreateShellAccountPayload

  "Update account communication delivery preference.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4123: Unauthorized.\n- KT-CT-4136: Cannot set comms preference to email when account has no email.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  updateCommsDeliveryPreference(
    """Input fields for updating comms delivery preferences for an account"""
    input: UpdateCommsDeliveryPreferenceInput!
  ): UpdateCommsDeliveryPreference

  "Update account billing email.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4123: Unauthorized.\n- KT-CT-4122: Invalid email.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  updateAccountBillingEmail(
    """Input fields for updating billing email for an account."""
    input: UpdateAccountBillingEmailInput!
  ): UpdateAccountBillingEmail

  "The possible errors that can be raised are:\n\n- KT-CT-4123: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  addCampaignToAccount(
    """Input variables needed for adding a campaign to an account."""
    input: AddCampaignToAccountInput!
  ): AddCampaignToAccount

  "Update the account billing address.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4145: Invalid address.\n- KT-CT-7123: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  updateAccountBillingAddress(
    """Input variables needed for updating an account billing address."""
    input: AccountBillingAddressInput!
  ): UpdateAccountBillingAddress

  "Add a note to an account.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4123: Unauthorized.\n- KT-CT-4180: Account note must be a valid string.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createAccountNote(
    """Input variables needed for adding a note to an account."""
    input: CreateAccountNoteInput!
  ): CreateAccountNote

  "Renew agreements for an account.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4125: Invalid data.\n- KT-GB-4111: Unable to renew agreements for tariff renewal.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  renewAgreements(input: RenewAgreementsInput): RenewAgreements

  "Renew agreement for a meter point.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4112: Unable to renew agreements for meter point at this time. Please try again later.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  renewAgreementForMeterPoint(input: RenewAgreementForMeterPointInput!): RenewAgreementForMeterPoint

  "Renew a list of agreements for an account.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4113: At least one list of agreements to renew is required.\n- KT-GB-4126: Electricity and gas agreement input is invalid.\n- KT-GB-4114: Unable to renew agreements.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  renewAgreementsForAccount(input: RenewAgreementsForAccountInput): RenewAgreementsForAccount

  "Set stated interest in procuring a smart meter for an account.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4115: Could not create smart meter interest for account.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  smets2Interest(input: UpdateAccountSmartMeterInterestInput): UpdateAccountSmartMeterInterest

  "Start smart onboarding process for an account.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4102: Unable to start smart onboarding process.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  startOnboardingProcess(input: StartSmartOnboardingProcessInput): StartSmartOnboardingProcess

  "Start export onboarding process for an account.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4103: Unable to start export onboarding process.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  startExportOnboardingProcess(input: StartExportOnboardingProcessInput): StartExportOnboardingProcess

  "Update SSD.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4101: Unable to update SSD for account.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  updateSsd(input: UpdateSsdInput): UpdateSsd

  """Create a Siteworks event."""
  createSiteworksEvent(
    """Input fields for creating a new Siteworks event."""
    input: CreateSiteworksEventInput!
  ): CreateSiteworksEvent

  "Allow external parties to create a Siteworks event.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4222: The provided 'siteworksRequestId' is not a valid UUID.\n- KT-GB-4223: Siteworks request not found. Check the provided 'siteworksRequestId' is correct.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createSiteworksEventExternal(
    """Input fields for creating a new Siteworks event."""
    input: CreateSiteworksEventInput!
  ): CreateSiteworksEventExternal

  "Create or update a Siteworks appointment.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1112: 'Authorization' header not provided.\n- KT-CT-4231: Unauthorized.\n- KT-GB-4230: Invalid data.\n- KT-GB-4224: Error processing siteworks appointment.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createOrUpdateSiteworksAppointment(
    """Input fields for creating or updating siteworks appointments."""
    input: CreateOrUpdateSiteworksAppointmentInput!
  ): CreateOrUpdateSiteworksAppointment

  """Cancel a Siteworks appointment."""
  cancelSiteworksAppointment(
    """Input fields for cancelling a siteworks appointment."""
    input: CancelSiteworksAppointmentInput!
  ): CancelSiteworksAppointment

  "Confirm an appointment slot returned by the appointment slots query.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4219: Property does not exist.\n- KT-GB-4220: No account currently active at property.\n- KT-GB-4221: Could not confirm duplicate property.\n- KT-GB-4228: Cannot currently book appointments for legacy prepay meters.\n- KT-GB-4229: A smart meter exchange appointment for this date already exists.\n- KT-GB-4210: Bookings not supported for agent appointed at property.\n- KT-GB-4211: Timeslot no longer available.\n- KT-GB-4212: Missing or invalid data for account or property.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  confirmSiteworksAppointmentSlot(
    """Input fields for booking a siteworks appointment slot"""
    input: ConfirmSiteworksAppointmentSlotInput!
  ): ConfirmSiteworksAppointmentSlot

  "Report details, readings and balances of meters removed during install.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4213: Application not found.\n- KT-GB-4231: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  reportRemovedMeterDetails(
    """Input fields for removed meter details."""
    input: ReportRemovedMeterDetailsInput!
  ): ReportRemovedMeterDetails

  "Update or create special circumstances for the user, which may entitle them to specialist services\n\n\n\nThis field requires the `Authorization` header to be set. \n\n\n\nThe possible errors that can be raised are:\n\n- KT-GB-5411: Failed to update special circumstance record.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  updateSpecialCircumstances(input: UpdateSpecialCircumstancesInput!): UpdateSpecialCircumstances

  "**DEPRECATED: Please use updatePaymentSchedulePaymentDay instead**\n\nUpdate monthly Direct Debit payment day\n\nThis field requires the `Authorization` header to be set. \n\n"
  directDebitPaymentDayUpdate(input: DirectDebitPaymentDayUpdateInput!): DirectDebitPaymentDayUpdate @deprecated(reason: "The 'directDebitPaymentDayUpdate' field is deprecated.\n\n\nPlease use the 'updatePaymentSchedulePaymentDay' mutation instead.\n\n\n- Marked as deprecated on 2020-10-02.\n- Will be removed on 2023-04-06.")

  "Update monthly Direct Debit payment day. Permitted values: 1-28. Not available for business accounts\n\n\n\nThis field requires the `Authorization` header to be set. \n\n\n\nThe possible errors that can be raised are:\n\n- KT-GB-3918: Account not found.\n- KT-GB-3910: This feature is not available to business accounts.\n- KT-GB-3911: Your payment day cannot be changed at this time.\n- KT-GB-3912: Unable to update payment day.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  updatePaymentSchedulePaymentDay(input: UpdatePaymentSchedulePaymentDayInput!): UpdatePaymentSchedulePaymentDay

  "Update monthly Direct Debit payment amount. Enter amount in pence\n\nLower limit: 100p (1), Upper limit: 100,000p (1,000)\n\n\n\nThis field requires the `Authorization` header to be set. \n\n\n\nThe possible errors that can be raised are:\n\n- KT-GB-3919: Invalid payment schedule amount.\n- KT-GB-3920: Cannot update payment schedule amount.\n- KT-CT-3923: Unauthorized.\n- KT-CT-3941: Invalid data.\n- KT-CT-3942: An unexpected error occurred.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  updatePaymentSchedulePaymentAmount(input: UpdatePaymentSchedulePaymentAmountInput!): UpdatePaymentSchedulePaymentAmount

  "Create new direct debit instruction\n\n\n\nThis field requires the `Authorization` header to be set. \n\n\n\nThe possible errors that can be raised are:\n\n- KT-CT-3940: Invalid data.\n- KT-CT-3923: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createDirectDebitInstruction(
    """Input fields for creating a new direct debit instruction"""
    input: CreateDirectDebitInstructionInput!
  ): CreateDirectDebitInstruction

  "Create a monthly payment schedule for a fixed amount.\n\nThis field requires the `Authorization` header to be set. \n\n\n\nThe possible errors that can be raised are:\n\n- KT-GB-3917: No statement in last 60 days.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  createPaymentSchedule(input: PaymentScheduleInput!): CreatePaymentSchedule

  "Create warm home discount application with given qualifying requirements and account.\n\nThis field requires the `Authorization` header to be set. \n\n"
  createWarmHomeDiscountApplication(accountNumber: String, applicationInputs: WarmHomeDiscountApplicationInputType): WarmHomeDiscountApplicationOutputType

  "Create electricity meter reading(s) with the given value(s) for the given meter(s).\n\nThis field requires the `Authorization` header to be set. \n\n"
  createElectricityMeterReading(mpan: String, readAt: Date, readings: [ReadingInputType], serialNumber: String): CreateMeterReadingOutputType

  "Create gas meter reading with the given value for the given meter.\n\nThis field requires the `Authorization` header to be set. \n\n"
  createGasMeterReading(mprn: String, readAt: Date, reading: Int, serialNumber: String): CreateMeterReadingOutputType

  """Amend unbilled electricity readings."""
  amendUnbilledElectricityReading(
    """Input fields for amending unbilled electricity reading."""
    input: AmendUnbilledReadingInput!
  ): AmendUnbilledElectricityReading

  """
  Create a quote for the given set of meter points for the supplied consumption.
  """
  createQuote(input: CreateQuoteInput!): CreateQuoteOutputType

  "Refresh quote with updated products for a quote code.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4612: Unable to refresh quote - quote not found.\n- KT-GB-4613: Error generating quote.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  refreshQuote(input: RefreshQuoteInput!): RefreshQuote

  """Requote for an account property."""
  requote(input: RequoteInput!): Requote

  """Bill to latest smart meter snapshot."""
  billToLatestSmartMeterSnapshot(
    """Input fields for billing to latest smart meter snapshot."""
    input: BillToLatestSmartMeterSnapshotInput!
  ): BillToLatestSmartMeterSnapshot

  "DO NOT USE: WIP. Switch the specified meter points to the chosen product.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4116: Invalid data.\n- KT-GB-4617: Quoted product not found.\n- KT-CT-4623: Unauthorized.\n- KT-GB-4117: Unable to process product switch.\n- KT-GB-4119: Meter point already on another account.\n- KT-GB-4120: MPxN has no active agreement.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  switchMeterPointProducts(input: SwitchMeterPointProductsInput): SwitchMeterPointProducts

  "Submit meter readings for any FIT installations associated with a particular account.\n\nThe possible errors that can be raised are:\n\n- KT-GB-6812: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  fitCreateMeterReadings(input: FitMeterReadingInput!): FitCreateMeterReadings

  """Create a quote for a campaign offer."""
  quoteCampaignOffer(input: QuoteCampaignOfferInput): QuoteCampaignOffer

  """Replace an agreement for an account with a new product."""
  replaceAgreement(input: ReplaceAgreementInput): ReplaceAgreement

  "Generate PAN for a smart prepay meter\n\nThe possible errors that can be raised are:\n\n- KT-GB-4045: Meter is not in prepayment mode.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  generatePaymentAllocationNumber(
    """Identifies the meter to generate a PAN for."""
    input: SmartMeterDeviceInput!
  ): GeneratePaymentAllocationNumber

  """
  Sign up an account against a list of products. This is currently only implemented for clients that have the APISITE_SIGN_UP_MUTATION_ENABLED set to True in settings.
  """
  signUp(
    """
    The input objects required to sign up an account against the supplied product(s).
    """
    input: SignUpInput!
  ): SignUp

  "Publish a trigger within the transactional messaging service.\n\nThe possible errors that can be raised are:\n\n- KT-CT-9901: Invalid trigger type code.\n- KT-CT-9902: Invalid trigger type params.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  publishTransactionalMessagingTrigger(
    """Input fields to publish a transactional messaging trigger."""
    input: PublishTransactionalMessagingTriggerInput!
  ): PublishTransactionalMessagingTrigger

  "Create a contribution agreement for an account.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4123: Unauthorized.\n- KT-CT-9601: Invalid data.\n- KT-CT-9602: Unable to create contribution agreement.\n- KT-CT-9605: Contribution amount cannot be 0 or negative.\n- KT-CT-9606: Scheme is not accepting contributions at this time.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createContributionAgreement(
    """
    Input variables needed for creating a contribution agreement on an account.
    """
    input: CreateContributionAgreementInput!
  ): CreateContributionAgreement

  "End a contribution agreement for an account.\n\nThe possible errors that can be raised are:\n\n- KT-CT-9603: Unable to find contribution agreement.\n- KT-CT-4123: Unauthorized.\n- KT-CT-9604: Unable to end contribution agreement.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  endContributionAgreement(
    """
    Input variables needed for ending a contribution agreement on an account.
    """
    input: EndContributionAgreementInput!
  ): EndContributionAgreement

  "Redeem the passed number of Loyalty Points as account credit.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4178: No account found with given account number.\n- KT-CT-9201: No Loyalty Point ledger found for the user.\n- KT-CT-9202: Loyalty Points adapter not configured.\n- KT-CT-9203: No ledger entries for the ledger.\n- KT-CT-9205: Insufficient Loyalty Points.\n- KT-CT-9206: Indivisible points.\n- KT-CT-9204: Negative or zero points set.\n- KT-CT-9208: Invalid posted at datetime.\n- KT-CT-9209: Negative Loyalty Points balance.\n- KT-CT-9210: Unhandled Loyalty Points exception.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  redeemLoyaltyPointsForAccountCredit(
    """Input fields for redeeming Loyalty Points."""
    input: RedeemLoyaltyPointsInput!
  ): RedeemLoyaltyPointsForAccountCredit

  "Transfer Loyalty Point from one account user to another.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1111: Unauthorized.\n- KT-CT-4181: The user is not associated with the account.\n- KT-CT-9205: Insufficient Loyalty Points.\n- KT-CT-9204: Negative or zero points set.\n- KT-CT-9208: Invalid posted at datetime.\n- KT-CT-9209: Negative Loyalty Points balance.\n- KT-CT-9210: Unhandled Loyalty Points exception.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  transferLoyaltyPointsBetweenUsers(
    """Input fields for transferring Loyalty Points."""
    input: TransferLoyaltyPointsBetweenUsersInput!
  ): TransferLoyaltyPointsBetweenUsers

  "Set the Loyalty Point user for the account.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1111: Unauthorized.\n- KT-CT-4181: The user is not associated with the account.\n- KT-CT-9210: Unhandled Loyalty Points exception.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  setLoyaltyPointsUser(
    """Input fields for setting the Loyalty Points user."""
    input: SetLoyaltyPointsUserInput!
  ): SetLoyaltyPointsUser

  "Create a referral using an email address, personal link or code.\n\nThe possible errors that can be raised are:\n\n- KT-CT-6723: Unauthorized.\n- KT-CT-6710: Unable to create referral.\n- KT-CT-6711: Accounts may not self-refer.\n- KT-CT-6713: Referring and referred account brands do not match.\n- KT-CT-6712: Invalid reference.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createReferral(
    """Input fields for creating a referral."""
    input: CreateReferralInput!
  ): CreateReferral

  "Mutation to create a new portfolio user role. This will effectively link the user to the portfolio giving them all the permissions enabled for the specific role.\n\nThe possible errors that can be raised are:\n\n- KT-CT-9403: Received an invalid portfolioId.\n- KT-CT-9404: Received an invalid accountUserId.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createPortfolioUserRole(
    """Input fields for connecting a user to a portfolio."""
    input: CreatePortfolioUserRoleInput
  ): CreatePortfolioUserRole

  "Mutation to create a new Portfolio instance.\n\nThe possible errors that can be raised are:\n\n- KT-CT-9402: Received an invalid brandCode.\n- KT-CT-9401: Received an invalid operationsTeamId.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createPortfolio(
    """Input fields for creating a portfolio."""
    input: CreatePortfolioInput
  ): CreatePortfolio

  "Close the Open Print Batch if any.\n\nThe possible errors that can be raised are:\n\n- KT-CT-9010: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  closeOpenPrintBatch: CloseOpenPrintBatch!

  "Mark the print batch as processed.\n\nThe possible errors that can be raised are:\n\n- KT-CT-9011: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  markPrintBatchAsProcessed(printBatchId: ID!): MarkPrintBatchAsProcessed!

  "Create or update a loyalty card for the given account user.\n\nThe possible errors that can be raised are:\n\n- KT-CT-5412: No account user exists with the given id.\n- KT-CT-8610: Invalid data.\n- KT-CT-8611: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createOrUpdateLoyaltyCard(
    """Input fields for creating or updating a loyalty card."""
    input: CreateOrUpdateLoyaltyCardInput!
  ): CreateOrUpdateLoyaltyCardMutation

  """Link an account user and line user together."""
  linkUserToLine(
    """Input fields to link an account user with LINE."""
    input: LinkUserToLineInput!
  ): LinkUserToLineResponse!

  """Unlink an account user and line together."""
  unlinkUserFromLine: UnlinkUserFromLineResponse!

  "Create an affiliate link for a new sales agent.\n\nThe possible errors that can be raised are:\n\n- KT-CT-7711: Invalid data.\n- KT-CT-7713: Invalid data.\n- KT-CT-7714: Invalid data.\n- KT-CT-7715: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createAffiliateLink(
    """Input fields for creating an affiliate link for an organisation"""
    input: CreateAffiliateLinkInputType!
  ): CreateAffiliateLink!

  "Update an existing affiliate link.\n\nThe possible errors that can be raised are:\n\n- KT-CT-7711: Invalid data.\n- KT-CT-7713: Invalid data.\n- KT-CT-7714: Invalid data.\n- KT-CT-7715: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  updateAffiliateLink(
    """Input fields for Updating an existing affiliate link"""
    input: UpdateAffiliateLinkInputType!
  ): UpdateAffiliateLink!

  "Create an affiliate organisation.\n\nThe possible errors that can be raised are:\n\n- KT-CT-7716: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createAffiliateOrganisation(
    """Input fields for creating an affiliate organisation"""
    input: CreateAffiliateOrganisationInputType!
  ): CreateAffiliateOrganisation!

  "Update an existing affiliate organisation.\n\nThe possible errors that can be raised are:\n\n- KT-CT-7717: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  updateAffiliateOrganisation(
    """Input fields for Updating an existing affiliate organisation"""
    input: UpdateAffiliateOrganisationInputType!
  ): UpdateAffiliateOrganisation!

  """Create a session for an affiliate link."""
  createAffiliateSession(
    """Input fields for creating a session for an affiliate link"""
    input: CreateAffiliateSessionInputType!
  ): CreateAffiliateSession!

  """Validate user's email address."""
  validateEmail(input: ValidateEmailInput!): ValidateEmail

  """Validate user's phone number."""
  validatePhone(input: ValidatePhoneNumberInput!): ValidatePhone

  "Look up an event to perform from its event_id, and return the next action to perform.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1111: Unauthorized.\n- KT-CT-8002: No event found.\n- KT-CT-8003: Event has no execute function.\n- KT-CT-8004: Error executing event in the backend.\n- KT-CT-8007: Incorrect or missing parameters for backend screen event.\n- KT-GB-9310: Account ineligible for joining Octoplus.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  backendScreenEvent(
    """Input fields for performing a backend action."""
    input: BackendScreenEventInput!
  ): BackendScreenEvent

  "Create metadata on an object.\n\nThe possible errors that can be raised are:\n\n- KT-CT-8412: Invalid data.\n- KT-CT-8414: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createMetadata(
    """Input fields for creating metadata."""
    input: MetadataInput!
  ): CreateMetadata

  "Update metadata on an object.\n\nThe possible errors that can be raised are:\n\n- KT-CT-8413: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  updateMetadata(
    """Input fields for updating metadata."""
    input: MetadataInput!
  ): UpdateMetadata

  "Submit customer feedback.\n\nThe possible errors that can be raised are:\n\n- KT-CT-5514: Unable to submit feedback.\n- KT-CT-5511: The feedback_id should be provided for feedback source.\n- KT-CT-5512: The feedback doesn't match the account.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  submitCustomerFeedback(input: CustomerFeedbackInputType!): SubmitCustomerFeedback

  "Submit a repayment request.\n\nThe possible errors that can be raised are:\n\n- KT-CT-3927: Invalid Amount.\n- KT-CT-3928: Idempotency key used for another repayment request.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  submitRepaymentRequest(
    """Input fields for requesting a repayment."""
    input: RequestRepaymentInputType!
  ): SubmitRepaymentRequest

  "Cancel a repayment or refund request.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4231: Unauthorized.\n- KT-CT-3930: The repayment or refund request does not exist.\n- KT-CT-3931: This repayment or refund request cannot be cancelled.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  cancelRepaymentRequest(
    """Input fields for cancelling a repayment request."""
    input: CancelRepaymentRequestInputType!
  ): CancelRepaymentRequest

  "Allow a repayment to be submitted.\n\nThe possible errors that can be raised are:\n\n- KT-CT-3944: Account repayment does not exist.\n- KT-CT-3945: Unable to allow a repayment to be submitted.\n- KT-CT-3950: The provided reason text is too long.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  allowRepaymentSubmission(
    """Input variable needed for allowing repayment submission."""
    input: RepaymentInput!
  ): AllowRepaymentSubmission

  "Block a repayment from being submitted.\n\nThe possible errors that can be raised are:\n\n- KT-CT-3944: Account repayment does not exist.\n- KT-CT-3946: Unable to block a repayment from being submitted.\n- KT-CT-3950: The provided reason text is too long.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  blockRepaymentSubmission(
    """Input variable needed for blocking repayment submission."""
    input: RepaymentInput!
  ): BlockRepaymentSubmission

  "Collect deposit for the given account.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4177: Unauthorized.\n- KT-CT-5711: No collection is required.\n- KT-CT-5712: Deposit agreement does not exist or has not been accepted.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  collectDeposit(input: CollectDepositInput!): CollectDeposit

  "Record the customer's acceptance of a deposit agreement.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4177: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  recordDepositAgreementAccepted(input: DepositAgreementInput!): RecordDepositAgreementAccepted

  "Create a new deposit agreement for the account if it needs one.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4177: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createDepositAgreement(input: CreateDepositAgreementInput!): CreateDepositAgreement

  "Initiate a standalone payment and return the client secret required to complete it.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4177: Unauthorized.\n- KT-CT-3943: Invalid ledger.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  initiateStandalonePayment(
    """Input fields for initiating a standalone payment."""
    input: InitiateStandalonePaymentInput!
  ): InitiateStandalonePayment

  "Get the client secret needed to create a new payment instruction using an embedded form.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4177: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  getEmbeddedSecretForNewPaymentInstruction(
    """
    Input fields for getting the client secret for an embedded new card payment method form.
    """
    input: GetEmbeddedSecretForNewPaymentInstructionInput!
  ): GetEmbeddedSecretForNewPaymentInstruction

  "Store a new payment instruction created through the embedded process.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4177: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  storePaymentInstruction(
    """
    Input fields for storing a new payment instruction created through the embedded process.
    """
    input: StorePaymentInstructionInput!
  ): StorePaymentInstruction

  "Invalidate an existing instruction.\n\nThe possible errors that can be raised are:\n\n- KT-CT-3926: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  invalidatePaymentInstruction(
    """
    Input fields for invalidating a payment instruction from an embedded form.
    """
    input: InvalidatePaymentInstructionInput!
  ): InvalidatePaymentInstruction

  "Set up a new direct debit instruction.\n\nThe possible errors that can be raised are:\n\n- KT-CT-3940: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  setUpDirectDebitInstruction(
    """Input fields for creating a new direct debit instruction"""
    input: SetUpDirectDebitInstructionInput!
  ): SetUpDirectDebitInstruction

  "Attempt to collect a one-off payment. If an instruction type is provided and there is an existing payment instruction, the payment can be collected immediately. A request to collect a payment at a future date can also be made, in which case the instruction input type is not necessary, but an instruction must exist at the specified collection date for the payment to be collected successfully.\n\nThe possible errors that can be raised are:\n\n- KT-CT-3932: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  collectPayment(
    """Input fields for collecting a payment."""
    input: CollectPaymentInput!
  ): CollectPayment

  "Amend an existing payment.\n\nThe possible errors that can be raised are:\n\n- KT-CT-3924: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  amendPayment(
    """Input fields for amending an existing payment."""
    input: AmendPaymentInput!
  ): AmendPayment
  assignInkBucket(input: AssignInkBucketInput!): AssignInkBucketPayload
  updateMessageTags(input: UpdateMessageTagsInput!): UpdateMessageTagsPayload

  """Register an Ink inbound message."""
  createInkInboundMessage(input: CreateInkInboundMessageInput!): CreateInkInboundMessagePayload

  "The possible errors that can be raised are:\n\n- KT-CT-7620: Channel not supported.\n- KT-CT-7618: Unable to process message.\n- KT-CT-7624: Error when generating the presigned URL.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  generateInkPresignedUrl(input: GenerateInkPresignedUrlInput): GenerateInkPresignedUrl

  "Create a goods quote.\n\nThe possible errors that can be raised are:\n\n- KT-CT-8202: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createGoodsQuote(
    """Input fields for creating a goods quote."""
    input: CreateGoodsQuoteInput!
  ): CreateGoodsQuote

  "Create a goods quote without an account.\n\nThe possible errors that can be raised are:\n\n- KT-CT-8202: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createGoodsQuoteWithoutAccount(
    """Input fields for creating a goods quote without an existing account."""
    input: CreateGoodsQuoteWithoutAccountInput!
  ): CreateGoodsQuoteWithoutAccount

  "Accept a goods quote.\n\nThe possible errors that can be raised are:\n\n- KT-CT-8223: Unauthorized.\n- KT-CT-8201: Received an invalid quoteId.\n- KT-CT-8224: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  acceptGoodsQuote(
    """Input fields for accepting a quote."""
    input: AcceptGoodsQuoteInput!
  ): AcceptGoodsQuote

  "Share a goods quote.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4122: Invalid email.\n- KT-CT-8203: Received an invalid quote code.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  shareGoodsQuote(
    """Input fields for sharing a quote."""
    input: ShareGoodsQuoteInput!
  ): ShareGoodsQuote

  "Create a goods purchase.\n\nThe possible errors that can be raised are:\n\n- KT-CT-8206: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createGoodsPurchase(
    """Input fields for creating a purchase without a quote."""
    input: CreatePurchaseInput!
  ): CreateGoodsPurchase

  "Create an account reminder.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1401: Invalid data.\n- KT-CT-1402: Unable to create account reminder.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createAccountReminder(
    """Input variables needed for creating an account reminder."""
    input: CreateAccountReminderInput!
  ): CreateAccountReminder

  "Create an account reference.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4123: Unauthorized.\n- KT-CT-8310: Invalid data.\n- KT-CT-8311: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createAccountReference(
    """Input fields for creating an account reference."""
    input: AccountReferenceInput!
  ): CreateAccountReference

  "Update an account reference.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4123: Unauthorized.\n- KT-CT-8310: Invalid data.\n- KT-CT-8311: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  updateAccountReference(
    """Input fields for updating an account reference."""
    input: AccountReferenceInput!
  ): UpdateAccountReference

  "Delete an account reference.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4123: Unauthorized.\n- KT-CT-8310: Invalid data.\n- KT-CT-8312: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  deleteAccountReference(
    """Input fields for removing an account reference."""
    input: DeleteAccountReferenceInput!
  ): DeleteAccountReference

  "Create an external account event.\n\nThe possible errors that can be raised are:\n\n- KT-CT-7123: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createExternalAccountEvent(
    """Input fields for creating an external account event."""
    input: CreateExternalAccountEventInput!
  ): CreateExternalAccountEvent

  "Add credit to an account.\n\nThe possible errors that can be raised are:\n\n- KT-CT-5315: Invalid data.\n- KT-CT-5314: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createAccountCredit(
    """Input fields for creating an account credit."""
    input: CreateAccountCreditInput!
  ): CreateAccountCredit @deprecated(reason: "The 'createAccountCredit' field is deprecated.\n\nUse postCredit mutation as it is ledger aware.\n\n- Marked as deprecated on 2022-07-04.\n- Will be removed on 2024-01-01.")

  "Post credit to a ledger.\n\nThe possible errors that can be raised are:\n\n- KT-CT-5316: Invalid data.\n- KT-CT-5311: The credit reason with the requested code is deprecated.\n- KT-CT-5312: The credit reason with the requested code does not exist.\n- KT-CT-5313: An error occurred whilst posting the credit.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  postCredit(
    """Input fields for posting a credit."""
    input: PostCreditInput!
  ): PostCredit

  "Add charge to an account.\n\nThe possible errors that can be raised are:\n\n- KT-CT-5211: The charge reason with the requested code is deprecated.\n- KT-CT-5212: The charge reason with the requested code does not exist.\n- KT-CT-5213: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createAccountCharge(
    """Input fields for creating an account charge."""
    input: CreateAccountChargeInput!
  ): CreateAccountCharge

  "Transfer value from a source ledger to a destination ledger. This decreases the balance of the source ledger by the given amount and increases the balance of the destination ledger by the same amount. If the amount is negative, the effect is reversed (the source ledger's balance increases and the destination ledger's balance decreases).\n\n\n\nThis field requires the `Authorization` header to be set. \n\n\n\nThe possible errors that can be raised are:\n\n- KT-CT-3810: Received an invalid ledger id.\n- KT-CT-3822: Unauthorized.\n- KT-CT-3823: Unauthorized.\n- KT-CT-9701: Balance transfer to same account is not allowed.\n- KT-CT-9702: Balance transfer is not support for debit account with Zero balance.\n- KT-CT-9703: Balance transfer is not supported for debit account.\n- KT-CT-9704: Balance transfer amount should be non-zero.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  transferLedgerBalance(
    """Input fields for processing an account balance transfer."""
    input: TransferLedgerBalanceInputType!
  ): TransferLedgerBalance

  "Create a \"form submission\" entity. This is only meant to be used as a quick way of putting together a form and submit data for it, in the form of JSON - it is not expected that all form submissions will come through this path.\n\nThis field requires the `Authorization` header to be set. \n\n"
  createFormSubmission(input: FormSubmissionInput!): FormSubmissionOuput

  """
  Provide username and password to receive a token. The token should be used as the `Authorization` header for any authenticated requests.
  """
  emailAuthentication(email: String!, password: String!): EmailAuthentication @deprecated(reason: "The 'emailAuthentication' field is deprecated.\n\nPlease use obtainKrakenToken instead of this mutation.\n\n- Marked as deprecated on 2021-09-03.\n- Will be removed on 2024-01-01.")

  """
  You probably want email authentication instead of this. Provide user's API Key to receive a token. The token should be used as the `Authorization` header for any authenticated requests. This form of authentication is used when the interface in question already has the API Key and it would be inappropriate to show the user a login screen.
  """
  apiKeyAuthentication(apiKey: String!): APIKeyAuthentication @deprecated(reason: "The 'apiKeyAuthentication' field is deprecated.\n\nPlease use obtainKrakenToken instead of this mutation.\n\n- Marked as deprecated on 2021-09-03.\n- Will be removed on 2024-01-01.")

  """
  Provide a temporary token to get an auth token. This is intended to allow support users to view customer data through the brand interface.
  """
  masqueradeAuthentication(
    """The masquerade token issued by the support site."""
    masqueradeToken: String!

    """The ID of the AccountUser to masquerade as."""
    userId: String!
  ): MasqueradeAuthentication

  "Generate a pre-signed token with a set expiry time.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1128: Unauthorized.\n- KT-CT-1120: The Kraken Token has expired.\n- KT-CT-1131: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  generatePreSignedToken(
    email: String!

    """
    The number of days that the token will be available for authentication (From now on).
    """
    numberOfDaysAllowed: Int!

    """Define (and limit) the scope of the token."""
    scope: PreSignedTokenScope!
  ): GeneratePreSignedToken

  "Invalidate a previously-issued pre-signed token.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1129: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  invalidatePreSignedToken(input: InvalidatePreSignedTokenInput!): InvalidatePreSignedToken

  "Invalidate pre-signed tokens issued to a particular user.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1129: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  invalidatePreSignedTokensForUser(input: InvalidatePreSignedTokensForUserInput!): InvalidatePreSignedTokensForUser

  """Deactivate the auth token used to authenticate the current request."""
  disableToken: DisableToken

  """
  Provide the email address of an account user to generate an email (to be sent to their address). The email will contain instructions on how to reset their password.
  """
  requestResetPassword(input: RequestResetPasswordMutationInput!): RequestResetPasswordMutationPayload @deprecated(reason: "The 'requestResetPassword' field is deprecated.\n\n\nPlease use 'requestPasswordReset' instead.\n\n\n- Marked as deprecated on 2023-04-20.\n- Will be removed on 2024-04-30.\n\nYou can read more about this deprecation on:\nhttps://announcements.kraken.tech/announcements/public/57/")

  "Provide the email address of an account user to send them an email with instructions on how to reset their password.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1133: Unable to request password reset email.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  requestPasswordReset(
    """Input fields for requesting a password reset email."""
    input: RequestPasswordResetInput!
  ): RequestPasswordResetOutputType

  """
  Reset the password of an account user indicated by the userId to the value supplied.
  """
  resetPassword(input: ResetPasswordMutationInput!): ResetPasswordMutationPayload

  "Create a Kraken Token (JWT) for authentication.  \n\nProvide the required input fields to obtain the token. \n\nThe token should be used as the `Authorization` header for any authenticated requests.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1135: Invalid data.\n- KT-CT-1134: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
  obtainKrakenToken(
    """
    Input fields that can be used to obtain a Json Web Token (JWT) for authentication to the API.
    """
    input: ObtainJSONWebTokenInput!
  ): ObtainKrakenJSONWebToken

  """
  Force users of Kraken Tokens and refresh tokens issued to the viewer to reauthenticate.
  
  Calling this mutation will cause all Kraken Tokens and refresh tokens issued to the authenticated viewer before the mutation was called to become invalid.
  """
  forceReauthentication(
    """Input object argument to the force-reauthentication mutation."""
    input: ForceReauthenticationInput!
  ): ForceReauthentication

  "For authorized third-party organizations only.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1120: The Kraken Token has expired.\n- KT-CT-1121: Please use Kraken Token to issue long-lived refresh tokens.\n- KT-CT-1132: Unauthorized.\n- KT-CT-1122: Long-lived refresh tokens can only be issued for account users.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  obtainLongLivedRefreshToken(
    """
    Input fields for obtaining a long-lived refresh token to extend the expiry claim of a Kraken token.
    """
    input: ObtainLongLivedRefreshTokenInput!
  ): ObtainLongLivedRefreshToken

  "Invalidate a previously-issued refresh token.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1130: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  invalidateRefreshToken(input: InvalidateRefreshTokenInput!): InvalidateRefreshToken

  "Invalidate refresh tokens issued to a particular user.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1128: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  invalidateRefreshTokensForUser(input: InvalidateRefreshTokensForUserInput!): InvalidateRefreshTokensForUser

  "Mutation to create a new APIException instance.\n\nThe possible errors that can be raised are:\n\n- KT-CT-7801: Received an invalid operationsTeamId.\n- KT-CT-7802: The external identifier already exists.\n- KT-CT-7805: Too many tags associated with this API Exception.\n- KT-CT-7806: Cannot create duplicate tags for the same API exception.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createApiException(
    """Input fields for creating an API exception."""
    input: CreateAPIExceptionInput!
  ): CreateAPIException

  "Mutation to update an existing APIException instance.\n\nThe possible errors that can be raised are:\n\n- KT-CT-7804: No fields present in the input for updating the APIException.\n- KT-CT-7803: Received an invalid apiExceptionId.\n- KT-CT-7809: Update results in no changes to API Exception.\n- KT-CT-7805: Too many tags associated with this API Exception.\n- KT-CT-7806: Cannot create duplicate tags for the same API exception.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  updateApiException(
    """Input fields for updating an API exception."""
    input: UpdateAPIExceptionInput!
  ): UpdateAPIException

  "Mutation to create a new APICall instance.\n\nThe possible errors that can be raised are:\n\n- KT-CT-7803: Received an invalid apiExceptionId.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createApiCall(
    """Input fields for creating an API call."""
    input: CreateAPICallInput!
  ): CreateAPICall

  "Mutation to create a new APIExceptionEvent instance.\n\nThe possible errors that can be raised are:\n\n- KT-CT-7803: Received an invalid apiExceptionId.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createApiExceptionEvent(
    """Input fields for creating an API exception event."""
    input: CreateAPIExceptionEventInput!
  ): CreateAPIExceptionEvent

  "Mutation to create a new APIExceptionNote instance.\n\nThe possible errors that can be raised are:\n\n- KT-CT-7803: Received an invalid apiExceptionId.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  createApiExceptionNote(
    """Input fields for creating an API exception note."""
    input: CreateAPIExceptionNoteInput!
  ): CreateAPIExceptionNote

  "Mutation to update an existing APIExceptionNote instance.\n\nThe possible errors that can be raised are:\n\n- KT-CT-7807: Received an invalid apiExceptionNoteId.\n- KT-CT-7808: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  updateApiExceptionNote(
    """Input fields for creating an API exception note."""
    input: UpdateAPIExceptionNoteInput!
  ): UpdateAPIExceptionNote

  """
  **DEPRECATED: Please use updateUser instead**
  
  Update the account user details of the authenticated user. Only one field can be updated per day. This prevents users from switching accounts to someone else (usually when moving homes) All account changes should be handled by operations or the move out journey. New customers are exempt from this rule for the first 31 days.
  """
  updateUserDetails(input: UpdateAccountUserMutationInput!): UpdateAccountUserMutationPayload @deprecated(reason: "The 'updateUserDetails' field is deprecated.\n\n\nPlease use the 'updateUser' mutation instead.\n\n\n- Marked as deprecated on 2020-10-02.\n- Will be removed on 2023-04-06.")

  """
  Update the comms preferences of the account user (the authenticated user).
  """
  updateCommsPreferences(input: UpdateAccountUserCommsPreferencesMutationInput!): UpdateAccountUserCommsPreferencesMutationPayload

  "Update password of the authenticated user.\n\n\n\nThis field requires the `Authorization` header to be set. \n\n"
  updatePassword(input: UpdatePasswordInput): UpdatePassword

  """Regenerate the live secret key for the authenticated user."""
  regenerateSecretKey: RegenerateSecretKey

  "Update the account user details of the authenticated user. Only one field can be updated per day. This prevents users from switching accounts to someone else (usually when moving homes) All account changes should be handled by operations or the move out journey. New customers are exempt from this rule for the first 31 days.\n\n\n\nThis field requires the `Authorization` header to be set. \n\n\n\nThe possible errors that can be raised are:\n\n- KT-CT-5413: Invalid data.\n- KT-CT-5414: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  updateUser(
    """Input fields for updating user."""
    input: UpdateUserInput!
  ): UpdateUserMutation

  "Register a device token to be used for push notifications for an app.\n\n\n\nThis field requires the `Authorization` header to be set. \n\n"
  registerPushNotificationBinding(
    """Input fields for creating an push notification binding."""
    input: RegisterPushNotificationBindingInput!
  ): RegisterPushNotificationBinding

  "Delete a device token used for push notifications. \n\n\n\nThis field requires the `Authorization` header to be set. \n\n\n\nThe possible errors that can be raised are:\n\n- KT-CT-5411: Invalid token or no push notification binding found for the given account user.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
  deletePushNotificationBinding(
    """Input fields for deleting a push notification binding."""
    input: DeletePushNotificationBindingInput!
  ): DeletePushNotificationBinding
}

type QuoteNewMeterPoints {
  """The generated quote."""
  quoteRequest: QuoteRequest
}

type QuoteRequest {
  """List of electricity supply points and their quoted products."""
  electricitySupplyPoints: [ElectricitySupplyPoint]

  """List of gas supply points and their quoted products."""
  gasSupplyPoints: [GasSupplyPoint]
  createdAt: DateTime

  """The code of the created quote."""
  code: String!
}

type ElectricitySupplyPoint {
  """The Mpan of the suply point."""
  mpan: String

  """Current active agreement on this supply point."""
  agreement: ElectricityAgreementType

  """
  Annual consumption of the supply point. The type of ElectricityConsumption depends on the rateType.
  """
  annualConsumption: ElectricityConsumption!

  """A list of quoted products and the corresponding tariff information."""
  quotedProducts: [ElectricityQuotedProduct]!

  """Rate type."""
  rateType: RateTypeChoices!
}

union ElectricityConsumption = ElectricityConsumptionStandard | ElectricityConsumptionLabelEco7 | ElectricityConsumptionThreeRate

type ElectricityConsumptionStandard {
  consumption: Int
  isEstimate: Boolean
}

type ElectricityConsumptionLabelEco7 {
  day: Int
  night: Int
  isEstimate: Boolean
}

type ElectricityConsumptionThreeRate {
  day: Int
  night: Int
  offPeak: Int
  isEstimate: Boolean
}

type ElectricityQuotedProduct {
  """The ID of the quoted product."""
  id: Int
  label: String

  """Energy product quoted."""
  product: EnergyProductType!

  """
  Estimated cost in pence of the product over a year based on the quoted usage. 
  """
  annualAmount: Int!

  """
  Estimated cost in pence of the product per month based on the quoted usage.
  """
  monthlyAmount: Int!

  """
  Electricity tariff information label (TIL) provides standardised information between suppliers about a tariff.  The type of ElectricityProductTariffInformationLabel depends on the rateType of the ElectricitySupplyPoint.
  """
  electricityTariffInformationLabel: ElectricityProductTariffInformationLabel!
}

"""
An EnergyProduct models a group of tariffs for both electricity and gas.
"""
type EnergyProductType {
  id: ID!
  fullName: String!

  """This name will be shown to customers during sign-up"""
  displayName: String!

  """This will be shown to customers during sign-up"""
  description: String!
  availableFrom: DateTime!
  availableTo: DateTime

  """Whether to hide this product from the direct registration journey"""
  isHidden: Boolean!
  code: String!

  """Whether the product is an import or export product."""
  direction: EnergyProductDirection

  """These are internal notes to explain why this product exists"""
  notes: String!
  isVariable: Boolean!
  isGreen: Boolean!
  isBusiness: Boolean!
  isChargedHalfHourly: Boolean!
  isPrepay: Boolean!
  isDefault: Boolean
  isOccupier: Boolean

  """Duration of agreements using this product in months"""
  term: Int

  """A list of tariffs per product for a given postcode."""
  tariffs(
    postcode: String!

    """
    Optional parameter to filter for a tariff's unit rates with a specific payment method.
    """
    paymentMethod: PaymentMethodChoices = DIRECT_DEBIT
    before: String
    after: String
    first: Int
    last: Int
  ): EnergyTariffConnectionTypeConnection
  isAvailable: Boolean
  isUnavailable: Boolean
  isFixed: Boolean
  isDomestic: Boolean

  """Does the product have EPG applied on the unit rates."""
  includesEpgReduction: Boolean

  """
  The exit fee applied per fuel if the agreement is ended early. Total value is determined by exit fee type, i.e. this value is either a flat cost or cost per year/month remaining on the agreement.
  """
  exitFees: Int

  """Determines how the exit fee is calculated."""
  exitFeesType: String

  """Tags associated with the product."""
  tags: [String]
}

enum EnergyProductDirection {
  IMPORT
  EXPORT
}

"\n\nThis field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).\n\n"
type EnergyTariffConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [EnergyTariffConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""A Relay edge containing a `EnergyTariffConnectionType` and its cursor."""
type EnergyTariffConnectionTypeEdge {
  """The item at the end of the edge"""
  node: EnergyTariffType

  """A cursor for use in pagination"""
  cursor: String!
}

union EnergyTariffType = StandardTariff | DayNightTariff | ThreeRateTariff | GasTariffType

enum PaymentMethodChoices {
  DIRECT_DEBIT
  NON_DIRECT_DEBIT
  PREPAYMENT
}

union ElectricityProductTariffInformationLabel = ProductTariffInformationLabelStandard | ProductTariffInformationLabelEco7 | ProductTariffInformationThreeRate

type ProductTariffInformationLabelStandard {
  supplier: String!
  tariffFullName: String!
  tariffDisplayName: String!
  tariffType: String!
  tariffCode: String!
  tariffEndsOn: String!
  paymentMethod: PaymentMethods!
  priceGuaranteedUntil: String!
  exitFees: Int
  exitFeesType: String
  additionals: String
  tariffComparisonRate: Decimal
  estimatedAnnualCost: Int
  annualStandingCharge: Decimal!
  standingCharge: Decimal!
  unitRate: Decimal!
  assumedAnnualConsumption: Int!
}

"""An enumeration."""
enum PaymentMethods {
  DIRECT_DEBIT
  CREDIT_CARD
  PAY_ON_RECEIPT
}

type ProductTariffInformationLabelEco7 {
  supplier: String!
  tariffFullName: String!
  tariffDisplayName: String!
  tariffType: String!
  tariffCode: String!
  tariffEndsOn: String!
  paymentMethod: PaymentMethods!
  priceGuaranteedUntil: String!
  exitFees: Int
  exitFeesType: String
  additionals: String
  tariffComparisonRate: Decimal
  estimatedAnnualCost: Int
  annualStandingCharge: Decimal!
  standingCharge: Decimal!
  unitRateDay: Decimal!
  unitRateNight: Decimal!
  assumedAnnualConsumptionDay: Int!
  assumedAnnualConsumptionNight: Int!

  """
  Some tariffs expect customers to alter their usage patterns (e.g. EV tariffs) so will redistribute total consumption accordingly.
  """
  consumptionDistributionCoefficients: ConsumptionDistributionCoefficients
}

type ConsumptionDistributionCoefficients {
  day: Decimal!
  night: Decimal!
}

type ProductTariffInformationThreeRate {
  supplier: String!
  tariffFullName: String!
  tariffDisplayName: String!
  tariffType: String!
  tariffCode: String!
  tariffEndsOn: String!
  paymentMethod: PaymentMethods!
  priceGuaranteedUntil: String!
  exitFees: Int
  exitFeesType: String
  additionals: String
  tariffComparisonRate: Decimal
  estimatedAnnualCost: Int
  annualStandingCharge: Decimal!
  standingCharge: Decimal!
  unitRateDay: Decimal!
  unitRateNight: Decimal!
  unitRateOffPeak: Decimal!
  assumedAnnualConsumptionDay: Int!
  assumedAnnualConsumptionNight: Int!
  assumedAnnualConsumptionOffPeak: Int!
}

"""An enumeration."""
enum RateTypeChoices {
  """Standard."""
  STANDARD

  """Economy7."""
  ECONOMY7

  """Three-rate."""
  THREE_RATE
}

type GasSupplyPoint {
  """The Mprn of the suply point."""
  mprn: String

  """Current active agreement on this supply point."""
  agreement: GasAgreementType

  """Annual consumption of the supply point"""
  annualConsumption: GasConsumption!

  """A list of quoted products and the corresponding tariff information."""
  quotedProducts: [GasQuotedProduct]!

  """Gas has only STANDARD rate type."""
  rateType: String!
}

type GasConsumption {
  consumption: Int
  isEstimate: Boolean
}

type GasQuotedProduct {
  """The ID of the quoted product."""
  id: Int
  label: String

  """Energy product quoted."""
  product: EnergyProductType!

  """
  Estimated cost in pence of the product over a year based on the quoted usage. 
  """
  annualAmount: Int!

  """
  Estimated cost in pence of the product per month based on the quoted usage.
  """
  monthlyAmount: Int!

  """
  Gas tariff information label (TIL) provides standardised information between suppliers about a tariff.
  """
  gasTariffInformationLabel: ProductTariffInformationLabelStandard!
}

input QuoteNewMeterPointsInput {
  """A list of electricity meterpoints to create this quote for."""
  electricityMeterPointsInput: [ElectricityMeterPointInput!]

  """A list of gas meterpoints to create this quote for."""
  gasMeterPointsInput: [GasMeterPointInput!]

  """
  Additional context about the future account which is required to create the quote.
  """
  newAccountInput: NewAccountInput!

  """
  Only quote on products with these tags. If not provided, quote against all available products.
  """
  productTags: [String!]
}

input ElectricityMeterPointInput {
  """Must be provided if no custom consumption input is provided."""
  mpan: String

  """
  Annual consumption values for this meter point. Must be provided if no MPAN is provided.
  """
  consumption: ElectricityConsumptionInput

  """
  The meter type on this meter point. Must be provided if no MPAN is provided.
  """
  meterType: MeterType

  """The grid supply point ID of this meter point."""
  gspId: String

  """Should the meter point be quoted on a flat rate."""
  flatRate: Boolean
}

input ElectricityConsumptionInput {
  """Amount of electricity consumed."""
  standard: Int

  """Daily electricity consumption."""
  day: Int

  """Nightly electricity consumption."""
  night: Int

  """Off peak hours electricity consumption."""
  offPeak: Int

  """If the consumption values are estimated, set this to 'True'."""
  isEstimate: Boolean
}

enum MeterType {
  STANDARD
  ECONOMY7
  SMART
  SMART_ECONOMY7
  SMART_FLAT_ECONOMY7
  FLAT_ECONOMY7
  THREE_RATE
  FLAT_THREE_RATE
}

input GasMeterPointInput {
  """Must be provided if no custom consumption input is provided."""
  mprn: String

  """Annual consumption values for this meter point."""
  consumption: GasConsumptionInput

  """The grid supply point ID of this meter point."""
  gspId: String
}

input GasConsumptionInput {
  """Amount of gas consumed."""
  value: Int!

  """If the consumption values are estimated, set this to 'True'."""
  isEstimate: Boolean
}

input NewAccountInput {
  """Account type to quote for (e.g. Business or Domestic)."""
  accountType: AccountTypeChoices!

  """Company brand to quote for."""
  brandCode: String!

  """
  Optional parameter for the payment method to quote for. Defaults to Direct Debit.
  """
  paymentMethod: PaymentMethodChoices

  """Optional ID of the affiliate session active when creating this quote."""
  affiliateSessionId: String
}

"The possible errors that can be raised are:\n\n- KT-CT-4616: Unable to create a quote.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type QuoteNewMeterPointsOnBespokeProducts {
  possibleErrors: [PossibleErrorType]

  """The generated quote."""
  quoteRequest: QuoteRequest
}

input QuoteNewMeterPointsOnBespokeProductsInput {
  """A list of electricity meterpoints to create this quote for."""
  electricityMeterPointsInput: [ElectricityMeterPointProductsInput!]

  """A list of gas meterpoints to create this quote for."""
  gasMeterPointsInput: [GasMeterPointProductsInput!]

  """Data for creating a new account."""
  newAccountInput: NewAccountInput!
}

input ElectricityMeterPointProductsInput {
  """Must be provided if no custom consumption input is provided."""
  mpan: String

  """
  Annual consumption values for this meter point. Must be provided if no MPAN is provided.
  """
  consumption: ElectricityConsumptionInput

  """
  The meter type on this meter point. Must be provided if no MPAN is provided.
  """
  meterType: MeterType

  """The grid supply point ID of this meter point."""
  gspId: String

  """Should the meter point be quoted on a flat rate."""
  flatRate: Boolean

  """A list of products and optional product parameters to quote for."""
  productsInput: [ElectricityProductInput!]!
}

input ElectricityProductInput {
  """Code specifying the product to quote for."""
  code: String

  """Optional payment method to quote for."""
  paymentMethod: PaymentMethodChoices

  """Bespoke rates to override default electricity unit rates."""
  bespokeRates: ElectricityBespokeRates
}

input ElectricityBespokeRates {
  """Standard bespoke rate for electricity."""
  standard: Decimal

  """Daily bespoke rate for electricity."""
  day: Decimal

  """Nightly bespoke rate for electricity."""
  night: Decimal

  """Off peak rate for electricity."""
  offPeak: Decimal

  """Standing charge for electricity."""
  standingCharge: Decimal!
}

input GasMeterPointProductsInput {
  """Must be provided if no custom consumption input is provided."""
  mprn: String

  """Annual consumption values for this meter point."""
  consumption: GasConsumptionInput

  """The grid supply point ID of this meter point."""
  gspId: String

  """A list of products and optional product parameters to quote for."""
  productsInput: [GasProductInput!]!
}

input GasProductInput {
  """Code specifying the product to quote for."""
  code: String

  """Optional payment method to quote for."""
  paymentMethod: PaymentMethodChoices

  """Bespoke rates to override default gas unit rates."""
  bespokeRates: GasBespokeRates
}

input GasBespokeRates {
  """Standard bespoke rate for gas."""
  value: Decimal!

  """Standing charge for gas."""
  standingCharge: Decimal!
}

"The possible errors that can be raised are:\n\n- KT-CT-4616: Unable to create a quote.\n- KT-GB-4614: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type QuoteAccountOnProducts {
  possibleErrors: [PossibleErrorType]

  """The generated quote."""
  quoteRequest: QuoteRequest
}

input QuoteAccountOnProductsInput {
  """A list of electricity meterpoints to create this quote for."""
  electricityMeterPointsInput: [ElectricityMeterPointProductsInput!]

  """A list of gas meterpoints to create this quote for."""
  gasMeterPointsInput: [GasMeterPointProductsInput!]

  """Account number to create this quote for."""
  accountNumber: String!

  """Date at which the product switch takes effect."""
  at: DateTime!
}

"Create meter points without enrolment.\n\nThis mutation will create the MeterPoint and Property DB objects like the SignUp mutation, but\nunlike the SignUp mutation it will not start an enrolment.\n\nThe possible errors that can be raised are:\n\n- KT-GB-5610: Account does not exist.\n- KT-GB-5611: Product must have exactly one context.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateMeterPoints {
  possibleErrors: [PossibleErrorType]

  """Boolean indicating if the sign up was successful."""
  success: Boolean!
}

type CreateRenewalQuoteRequest {
  quoteRequest: QuoteRequest
}

input CreateRenewalQuoteRequestInput {
  """The account number."""
  accountNumber: String!

  """The property id to create a quote request for."""
  propertyId: Int!

  """The date at which the agreements would be renewed."""
  renewalAt: DateTime!
}

"The possible errors that can be raised are:\n\n- KT-GB-4624: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateQuoteRequestForProducts {
  possibleErrors: [PossibleErrorType]

  """
  Returns a quote request for the requested product codes. Does not persist the quote.
  """
  quoteRequest: QuoteRequestBase
}

type QuoteRequestBase {
  """List of electricity supply points and their quoted products."""
  electricitySupplyPoints: [ElectricitySupplyPoint]

  """List of gas supply points and their quoted products."""
  gasSupplyPoints: [GasSupplyPoint]
  createdAt: DateTime
}

input CreateQuoteRequestForProductsInput {
  """The account number."""
  accountNumber: String!

  """The property id to create a quote request for."""
  propertyId: Int!

  """The product codes of products to quote for."""
  productCodes: [String]!

  """The date at which the agreements would be renewed."""
  renewalAt: DateTime!

  """
  If the customer is currently on a flat rate tariff, create a flat rate quote.
  """
  persistFlatRate: Boolean

  """
  Optional parameter to override the payment method on the current agreement.
  """
  paymentMethod: PaymentMethodChoices
}

"The possible errors that can be raised are:\n\n- KT-GB-4625: Unable to create quote request.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
type CreateAcquisitionQuoteRequestForProducts {
  possibleErrors: [PossibleErrorType]

  """
  Returns a quote request for the requested product codes. Does not persist the quote.
  """
  quoteRequest: QuoteRequestBase
}

input CreateAcquisitionQuoteRequestForProductsInput {
  """The electricity meter points to create a quote request for."""
  electricityMeterPoints: [ElectricityMeterPointConsumptionInput]

  """The gas meter points to create a quote request for."""
  gasMeterPoints: [GasMeterPointConsumptionInput]

  """The postcode of the meter points being quoted."""
  postcode: String!

  """The product codes of products to quote for."""
  productCodes: [String]!

  """
  Optional parameter for the payment method to quote for. Defaults to Direct Debit.
  """
  paymentMethod: PaymentMethodChoices = DIRECT_DEBIT
}

input ElectricityMeterPointConsumptionInput {
  profileClass: Int
  mpan: String
  isEstimate: Boolean!
  annualConsumptionStandard: Int
  annualConsumptionDay: Int
  annualConsumptionNight: Int
}

input GasMeterPointConsumptionInput {
  mprn: String
  isEstimate: Boolean!
  annualConsumption: Int
}

"Mutation for creating an refund request for an account.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4127: Unable to send refund request confirmation email.\n- KT-GB-4121: Unable to process refund request.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateRefundRequest {
  possibleErrors: [PossibleErrorType]
  refundRequest: RefundRequestType
}

type RefundRequestType {
  """The requested refund amount which was submitted in the repayment."""
  requestedAmountToReturn: Int
}

"""The input type for the refund request."""
input RefundRequestInput {
  """The account number."""
  accountNumber: String!

  """The requested refund amount."""
  requestedAmount: Int!
}

"Update smart meter data preferences of an account.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4023: Unauthorized.\n- KT-GB-4015: Cannot update smart meter reading frequency preferences.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type UpdateSmartMeterDataPreferences {
  possibleErrors: [PossibleErrorType]
  preferencesUpdated: Boolean
  smartMeterDataPreferences: SmartMeterDataPreferencesType
}

type SmartMeterDataPreferencesType {
  """The reading frequency for the smart meter."""
  readingFrequency: SmartMeterReadingFrequencyChoices

  """
  Has the user given consent that their readings can be used for further analysis?
  """
  readingsAnalysisConsentProvided: Boolean

  """
  The datetime when the user gave consent that their readings can be used for further analysis.
  """
  readingsAnalysisConsentUpdatedDatetime: DateTime
}

"\n    Meter reading frequency choices for smart meters.\n\n    Please note: these labels are exposed in the API documentation.\n    "
enum SmartMeterReadingFrequencyChoices {
  """Daily"""
  DAILY

  """Monthly"""
  MONTHLY

  """Half hourly"""
  HALF_HOURLY
}

input UpdateSmartMeterDataPreferencesInput {
  accountNumber: String!

  """The desired reading frequency for the smart meter."""
  readingFrequency: SmartMeterReadingFrequencyChoices!

  """The consent that smart meter readings can be used for further analysis"""
  allowReadingsAnalysis: Boolean
}

"Send a request to the DCC to join a smart device to a HAN (Home Area Network).\n\nThe possible errors that can be raised are:\n\n- KT-GB-4019: This device type is not currently supported.\n- KT-GB-4020: Error sending the request to join the device to the Home Area Network.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type JoinDeviceToNetwork {
  possibleErrors: [PossibleErrorType]
  requestReference: String
}

"\n    Types of devices that can be joined to a HAN (Home Area Network).\n    "
enum JoinableDeviceType {
  """Electricity meter."""
  ELECTRICITY_METER

  """Gas meter."""
  GAS_METER

  """HAN Connected Auxiliary Load Control Switch (HCALCS)."""
  AUX_SWITCH

  """Pre-Payment Meter Interface Device."""
  PPMID

  """In-Home Display."""
  IHD
}

"The possible errors that can be raised are:\n\n- KT-GB-4021: Invalid MPxN.\n- KT-GB-4022: MPxN not recognised.\n- KT-GB-4023: Error sending the request to commission the device.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CommissionMeter {
  possibleErrors: [PossibleErrorType]

  """The id of the SMETS Commission Request in Kraken."""
  requestReference: String
}

input CommissionMeterInput {
  mpxn: String

  """Device ID of the CHF (Communications Hub Function)."""
  chfDeviceId: String!

  """Device ID (ESME or GSME) of the device being commissioned."""
  meterDeviceId: String!

  """
  Code provided by manufacturer as part of ASN data, and included as part of device pre-notification, which is required to authorise device commissioning.
  """
  installationCode: String!

  """Type of meter being commissioned"""
  meterType: MeterTypeChoices!

  """Serial number for ESME or GSME devices."""
  serialNumber: String
}

"""An enumeration."""
enum MeterTypeChoices {
  """Electricity meter."""
  ELECTRICITY_METER

  """Gas meter."""
  GAS_METER
}

"The possible errors that can be raised are:\n\n- KT-GB-4024: The provided device ID does not match any devices known by Kraken.\n- KT-GB-4025: Error sending the request to decommission the device.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type DecommissionSmartDevice {
  possibleErrors: [PossibleErrorType]

  """The reference of the Decommission Request in Kraken."""
  requestReference: String
}

input DecommissionSmartDeviceInput {
  """Device ID for the device being decommissioned."""
  deviceId: String!
}

"""
A request sent to notify Kraken of a new device, which will be prenotified to the adapter.
"""
type RegisterSmartDevice {
  """The reference for the associated request in Kraken."""
  requestReference: String
}

"""This type is used by agent services to notify Kraken of a new device."""
input RegisterSmartDeviceInput {
  """The ID of the device to register."""
  deviceId: String!

  """
  MPID of the Meter Asset Provider for the device. Used with ESME or GSME devices.
  """
  mapMpid: String

  """Supplier associated with the device."""
  supplierMpid: String!

  """The 4-letter manufacturer code for the device."""
  deviceManufacturer: String!

  """Model of the device."""
  deviceModel: String!

  """Type of the device, e.g. ESME or GSME."""
  deviceType: String!

  """SMETS CHTS version number."""
  smetsChtsVersion: String

  """Installation code of the device."""
  installCode: String!

  """ESME variant for an ESME device."""
  esmeVariant: String

  """Serial number for ESME or GSME devices."""
  serialNumber: String

  """Firmware version number."""
  firmwareVersion: String
}

"Update the status of the communications hub.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4026: Either the mpxn or mpan input must be provided.\n- KT-GB-4027: If both mpxn and mpan are provided, they must match.\n- KT-GB-4028: Please input a valid MPxN.\n- KT-GB-4029: Meter point not found for MPAN.\n- KT-GB-4030: Meter point not found for MPRN.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type UpdateCommsHubStatus {
  possibleErrors: [PossibleErrorType]

  """The id of the Request object in Kraken."""
  requestReference: String
}

input UpdateCommsHubStatusInput {
  """Device ID of the CHF (Communications Hub Function)."""
  chfDeviceId: String!

  """The type of status update to be sent."""
  updateType: CommsHubStatusUpdateType!

  """MPxN of a meter point linked to the CHF."""
  mpxn: String

  """Is it a new or replacement CHF?"""
  chfInstallType: CHFInstallType

  """Was an external aerial installed?"""
  hasAerialInstalled: Boolean

  """Location of the CHF."""
  chfLocation: CHFLocation

  """Type of the premise in which the CHF is located."""
  premiseType: PremiseType

  """
  In the case of NO_SM_WAN, was the issue a local metal obstruction (as defined in CHSM)?
  """
  hasMetalObstruction: Boolean

  """
  In the case of NO_SM_WAN, was the issue a thick stone wall obstruction (as defined in CHSM)?
  """
  hasConnectivityObstruction: Boolean

  """
  In the case of NO_SM_WAN, was the CHF in a shared/communal area (as defined in CHSM)?
  """
  hasSharedObstruction: Boolean

  """The engineer's description of the fault."""
  faultReason: CHFFaultReason

  """Whether a fault was identified before or after the installation."""
  faultReturnType: CHFFaultReturnType

  """
  How the CHF was installed and connected to the rest of the Smart Metering System.
  """
  chfConnectionMethod: CHFConnectionMethod

  """
  In the case of NO_FAULT_RETURN, the reason for the meter not being installed.
  """
  noFaultReturnType: CHFNoFaultReturnType
}

"\n    The type of comms hub status update request to be sent.\n    "
enum CommsHubStatusUpdateType {
  """Success."""
  SUCCESS

  """No SM Wide Area Network."""
  NO_SM_WAN

  """Returning CHF due to technical fault."""
  FAULT_RETURN

  """Returning CHF for non-technical reason."""
  NO_FAULT_RETURN
}

"\n    Whether it is a new or replacement CHF.\n    "
enum CHFInstallType {
  """New."""
  NEW

  """Replacement."""
  REPLACEMENT
}

"\n    Location of the CHF.\n    "
enum CHFLocation {
  """Outside of the premises."""
  OUTSIDE

  """Indoors On External Wall."""
  INDOORS_ON_EXTERNAL_WALL

  """Indoors, NOT on an external wall."""
  DEEP_INDOORS

  """In the basement/cellar."""
  BASEMENT_OR_CELLAR
}

"\n    The type of premise in which the CHF is located.\n    "
enum PremiseType {
  """Detached / Semi-detached."""
  DETACHED_OR_SEMI

  """Terraced."""
  TERRACED

  """An apartment block with 5 floors or less."""
  LOW_RISE_APARTMENT

  """An apartment block with more than 5 floors."""
  HIGH_RISE_APARTMENT
}

"\n    The user's description of the fault, if the meter was not installed due to a technical problem.\n    "
enum CHFFaultReason {
  """Damaged Case."""
  DAMAGED_CASE

  """Damaged connector."""
  DAMAGED_CONNECTOR

  """Illegal Interference Or Missing Seals."""
  ILLEGAL_INTERFERENCE_OR_MISSING_SEALS

  """Environmental Conditions Exceeded."""
  ENVIRONMENTAL_CONDITIONS_EXCEEDED

  """Fault with SM WAN."""
  SM_WAN_FAULT

  """Fault with SM HAN interface."""
  SM_HAN_FAULT

  """Fault with LED."""
  LED_FAULT

  """Fault with aerial."""
  AERIAL_FAULT

  """Manufacturing Defect."""
  MANUFACTURING_DEFECT
}

"\n    Whether the fault was identified before or after the installation.\n    "
enum CHFFaultReturnType {
  """Prior To Installation."""
  PRIOR_TO_INSTALLATION

  """Post Installation."""
  POST_INSTALLATION
}

"\n    How the CHF was installed and connected to the rest of the Smart Metering System.\n    "
enum CHFConnectionMethod {
  """Hot Shoe."""
  HOT_SHOE

  """Cradle."""
  CRADLE

  """Esme."""
  ESME
}

"\n    The reason for the meter not being installed if there was no technical issue.\n    "
enum CHFNoFaultReturnType {
  """General."""
  GENERAL

  """Non-domestic opt-out."""
  NON_DOMESTIC_OPT_OUT

  """Dual supplier HAN variant replacement."""
  DUAL_SUPPLIER_HAN_VARIANT_REPLACEMENT

  """SM WAN variant replacement requested by DCC."""
  SM_WAN_VARIANT_REPLACEMENT

  """Lost or stolen hub."""
  LOST_OR_STOLEN_HUB
}

"The possible errors that can be raised are:\n\n- KT-GB-4053: Fuel type should not be specified for Alt HAN device.\n- KT-GB-4031: Error sending the request to join the device to the CHF.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type JoinConsumerDevice {
  possibleErrors: [PossibleErrorType]

  """
  The reference of the join PPMID, IHD, CAD or Alt HAN request in Kraken.
  """
  requestReference: String
}

input JoinConsumerDeviceInput {
  """The fuel type of the device, electricity, gas or dual fuel"""
  fuelType: FuelTypeChoices

  """Device ID of the CHF (Communications Hub Function)."""
  chfDeviceId: String!

  """
  Device ID (IHD, PPMID, CAD or Alt HAN) of the device being added to the CHF.
  """
  consumerDeviceId: String!

  """
  Code provided by manufacturer as part of ASN data, and included as part of device pre-notification, which can be required to authorise the joined device.
  """
  installationCode: String

  """The device type being joined to the CHF."""
  consumerDeviceType: JoinConsumerDeviceChoices!
}

"""An enumeration."""
enum FuelTypeChoices {
  """Electricity."""
  ELECTRICITY

  """Gas."""
  GAS

  """Dual Fuel."""
  DUAL_FUEL
}

"""An enumeration."""
enum JoinConsumerDeviceChoices {
  """Pre-Payment Meter Interface Device."""
  PPMID

  """In-Home Display."""
  IHD

  """Consumer Access Device."""
  CAD

  """Alternative Home Area Network."""
  ALT_HAN
}

"Remove a consumer device from the CHF/HAN. Currently limited to only CAD devices.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4012: Unable to find the CAD device.\n- KT-GB-4032: Error sending the request to remove the device.\n- KT-GB-4013: Received invalid device type to remove other than CAD.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type RemoveConsumerDevice {
  possibleErrors: [PossibleErrorType]

  """The reference of the remove consumer device request in Kraken."""
  requestReference: String
}

input RemoveConsumerDeviceInput {
  """Device ID of the CAD being removed from the CHF/HAN."""
  consumerDeviceId: String!

  """The device type being joined, currently limited to CAD only."""
  consumerDeviceType: RemoveConsumerDeviceChoices!
}

"""An enumeration."""
enum RemoveConsumerDeviceChoices {
  """Consumer Access Device."""
  CAD
}

"""Add credit to a smart prepayment meter."""
type AddCreditToSmartMeter {
  """Top-up amount in pence to add to smart meter"""
  amount: Int!
}

"""This type is used by clients to top-up a smart prepay meter"""
input SmartPrepayMeterAmountInput {
  """Account number of customer."""
  accountNumber: String!

  """Electricity or gas meter device ID."""
  deviceId: String!

  """Amount of credit to add to the meter, in pence."""
  amount: Int!

  """The top-up will wait for this payment to clear before proceeding."""
  paymentIntentId: ID

  """Apply as temporary credit."""
  isTemporaryCredit: Boolean

  """Reason for top-up."""
  reason: String
}

"The possible errors that can be raised are:\n\n- KT-GB-4033: No electricity device found matching device ID.\n- KT-GB-4034: Error requesting consumption data.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
type RequestConsumptionData {
  possibleErrors: [PossibleErrorType]

  """The reference for the associated request in Kraken."""
  requestReference: String
}

input RequestConsumptionDataInput {
  """Device ID for the meter."""
  deviceId: String!

  """The first half hourly period start (inclusive) to retrieve."""
  startAt: DateTime

  """The last half hourly end time (inclusive) to retrieve."""
  endAt: DateTime
}

type ReplaceCommsHub {
  """The reference for the associated request in Kraken."""
  requestReference: String
}

"""
Specify a new SMETS2 Communications Hub to replace an existing Communications Hub.
"""
input ReplaceCommsHubInput {
  """The device id of the old Communications Hub."""
  oldCommsHubDeviceId: String!

  """The device id of the new Communications Hub."""
  newCommsHubDeviceId: String!
}

"""Create a payment intent for paying with external payment providers."""
type CreatePaymentIntent {
  paymentIntent: PaymentIntentType
}

type PaymentIntentType {
  id: ID!

  """A unique identifier for this payment intent."""
  reference: String!
  accountNumber: String
  amount: Int
  date: Date
}

"""The input type for the payment intent."""
input CreatePaymentIntentInput {
  """The account number."""
  accountNumber: String!

  """The amount of the payment intent to be created."""
  amount: Int!
  date: Date!
}

type OccupyOutputType {
  account: AccountInterface
}

input OccupyInput {
  accountNumber: String!
  propertyId: String!
  quoteCode: String!
  productCode: String!

  """
  The day of the month that payments should be taken from the account. Should be between 1 and 28.
  """
  paymentDay: Int
  directDebitInstruction: DirectDebitInstructionLocalBankDetailsInput = null
  users: [AccountUserInput]
  moveInDate: Date
}

input DirectDebitInstructionLocalBankDetailsInput {
  accountNumber: String!
  accountHolder: String!
  sortCode: String!
}

input AccountUserInput {
  givenName: String!
  familyName: String!
  email: String!
  mobile: String!
  optedInForMarketing: Boolean!
  creditScoreData: CreditScoreData = null
  creditScoreFetchedAt: DateTime
  dateOfBirth: Date
  psrData: UpdateSpecialCircumstancesInput = null
}

input CreditScoreData {
  riskBracket: String!
  score: Int!
}

input UpdateSpecialCircumstancesInput {
  """Additional presence preferred"""
  additionalPresencePreferred: Boolean

  """Blind"""
  blind: Boolean

  """Careline/telecare system"""
  carelineTelecareSystem: Boolean

  """Chronic/serious illness"""
  chronicSeriousIllness: Boolean

  """Dementia"""
  dementia: Boolean

  """Developmental condition"""
  developmentalCondition: Boolean

  """Pensionable age"""
  elderly: Boolean
  hearingImpairment: Boolean

  """Heart, lung & ventilator"""
  heartLungMachine: Boolean

  """Dialysis, feeding pump and automated medication"""
  kidneyDialysis: Boolean

  """MDE electric showering"""
  mdeElectricShowering: Boolean

  """Medicine refrigeration"""
  medicineRefrigeration: Boolean

  """Mental health"""
  mentalHealth: Boolean

  """Nebuliser and apnoea monitor"""
  nebuliser: Boolean

  """Oxygen concentrator"""
  oxygenConcentrator: Boolean

  """Oxygen Use"""
  oxygenUse: Boolean
  partialSighted: Boolean
  physicalImpairment: Boolean
  poorSenseOfSmell: Boolean
  restrictedHandMovement: Boolean
  restrictedMovement: Boolean
  speechImpairment: Boolean
  stairLift: Boolean
  waterDependent: Boolean
  familiesWithYoungChildren5OrUnder: Boolean
  familiesWithYoungChildren5OrUnderEndDate: String
  temporaryLifeChanges: Boolean
  temporaryLifeChangesEndDate: String
  temporaryPostHospitalRecovery: Boolean
  temporaryPostHospitalRecoveryEndDate: String
  temporaryYoungAdultHouseholder: Boolean
  temporaryYoungAdultHouseholderEndDate: String
  foreignLanguageSpeaker: Boolean

  """Preferred language"""
  language: String

  """Use a unique password to identify our staff and partners"""
  usePasswordToIdentify: Boolean
  partnerPassword: String

  """
  Consent required to allow priority service request information to be shared. You will only need to provide this once
  """
  userConsent: Boolean
}

"The possible errors that can be raised are:\n\n- KT-GB-6624: An error occurred when trying to process this house move.\n- KT-GB-6625: An error occurred when trying to process this house move.\n- KT-GB-6626: There was an error processing the PSR data.\n- KT-GB-6627: There are missing agent appointments.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
type PerformMoveOut {
  possibleErrors: [PossibleErrorType]
  account: AccountInterface
}

input MoveOutInput {
  accountNumber: String!
  propertyId: String!
  moveOutDate: Date!

  """The property to perform a move in for."""
  newProperty: MoveInNewProperty = null

  """The details of the next occupant of the property."""
  newTenant: MoveOutNewTenant = null
}

input MoveInNewProperty {
  """Street address of the new property. Should not contain the postcode."""
  address: String!

  """Postcode of new property."""
  postcode: String!

  """Date of moving into the new property."""
  moveInDate: String

  """MPANs of the electricity meter points at the new property."""
  mpans: [String]

  """MPRNs of the gas meter points at the new property."""
  mprns: [String]

  """
  The product to use when creating agreements for the new property. If not provided, the current product for each meter point is used if available, or else the default SVT product. If provided, quote_code must also be provided.
  """
  productCode: String

  """
  A quote that contains the product provided in product_code. Should be provided only if product_code is also provided.
  """
  quoteCode: String

  """
  If True, this will trigger the move in flow at the new property for the account.
  """
  moveInNewProperty: Boolean
}

input MoveOutNewTenant {
  givenName: String
  familyName: String
  email: String
  mobile: String
  role: String
}

"""
Create a shell account (a billable account with no property/energy supply).
"""
type CreateShellAccountPayload {
  givenName: String!
  familyName: String!
  billingName: String
  email: String!
  mobile: String
  landline: String
  brand: String
  dateOfBirth: Date
  billingAddressLine1: String!
  billingAddressLine2: String!
  billingAddressLine3: String
  billingAddressLine4: String
  billingAddressLine5: String
  billingPostcode: String!

  """
  For fixed billing accounts only, the length of their billing period. Can be MONTHLY or QUARTERLY.
  """
  billingPeriodLength: String

  """
  For fixed billing accounts only, the number the period length is to be multiplied by to get the total period length, i.e. for billing every second month, select 2 combined with a billing period length MONTHLY. Can't be > 1 for quarterly billing.
  """
  billingPeriodMultiplier: Int

  """Day to fixed bill on if billing_period_length set."""
  billingPeriodDay: Int

  """
  Month to start billing from if billing_period_length set to QUARTERLY or the multiplier is > 1.
  """
  billingPeriodMonth: Int
  isBusinessAccount: Boolean
  companyName: String
  companyNumber: String
  businessType: String
  password: String
  passwordUpdateToken: String
  urn: String
  errors: [ErrorType]
  account: AccountInterface
  clientMutationId: String
}

input CreateShellAccountInput {
  givenName: String!
  familyName: String!
  billingName: String
  email: String!
  mobile: String
  landline: String
  brand: String
  dateOfBirth: Date
  billingAddressLine1: String!
  billingAddressLine2: String!
  billingAddressLine3: String
  billingAddressLine4: String
  billingAddressLine5: String
  billingPostcode: String!

  """
  For fixed billing accounts only, the length of their billing period. Can be MONTHLY or QUARTERLY.
  """
  billingPeriodLength: String

  """
  For fixed billing accounts only, the number the period length is to be multiplied by to get the total period length, i.e. for billing every second month, select 2 combined with a billing period length MONTHLY. Can't be > 1 for quarterly billing.
  """
  billingPeriodMultiplier: Int

  """Day to fixed bill on if billing_period_length set."""
  billingPeriodDay: Int

  """
  Month to start billing from if billing_period_length set to QUARTERLY or the multiplier is > 1.
  """
  billingPeriodMonth: Int
  isBusinessAccount: Boolean
  companyName: String
  companyNumber: String
  businessType: String
  password: String
  passwordUpdateToken: String
  urn: String
  clientMutationId: String
}

"Update the comms delivery preference for the input account number to the\nreceived commsDeliveryPreference value.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4123: Unauthorized.\n- KT-CT-4136: Cannot set comms preference to email when account has no email.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type UpdateCommsDeliveryPreference {
  possibleErrors: [PossibleErrorType]
  account: AccountInterface
}

"""Input fields for updating comms delivery preferences for an account"""
input UpdateCommsDeliveryPreferenceInput {
  accountNumber: String!
  commsDeliveryPreference: CommsDeliveryPreference!
}

"Update the billing email for the input account number to the\nreceived email value.\n\nThe possible errors that can be raised are:\n\n- KT-CT-4123: Unauthorized.\n- KT-CT-4122: Invalid email.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type UpdateAccountBillingEmail {
  possibleErrors: [PossibleErrorType]

  """Account that was changed."""
  account: AccountInterface
}

"""Input fields for updating billing email for an account."""
input UpdateAccountBillingEmailInput {
  """Account number for account."""
  accountNumber: String!

  """
  The billing_email which can be up to 512 characters. Use null to unset billing_email.
  """
  billingEmail: String
}

"The possible errors that can be raised are:\n\n- KT-CT-4123: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
type AddCampaignToAccount {
  possibleErrors: [PossibleErrorType]

  """Whether the campaign was successfully added."""
  campaignAdded: Boolean
}

input AddCampaignToAccountInput {
  """The account number."""
  accountNumber: String!

  """The slug of the campaign we want to assign."""
  campaign: String!
}

"The possible errors that can be raised are:\n\n- KT-CT-4145: Invalid address.\n- KT-CT-7123: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type UpdateAccountBillingAddress {
  possibleErrors: [PossibleErrorType]

  """The updated account."""
  account: AccountType
}

input AccountBillingAddressInput {
  """The account number of the account to update."""
  accountNumber: String

  """Billing address details."""
  billingAddress: BillingAddressDetailsInput = null
}

input BillingAddressDetailsInput {
  """Billing street address."""
  streetAddress: String

  """Billing structured street address."""
  structuredStreetAddress: GenericScalar

  """Billing dependent locality."""
  dependentLocality: String

  """Billing locality."""
  locality: String

  """Billing postal code."""
  postalCode: String

  """Billing sorting code."""
  sortingCode: String

  """Billing delivery point identifier."""
  deliveryPointIdentifier: String

  """Administrative area."""
  administrativeArea: String

  """Billing country."""
  country: String
}

"The possible errors that can be raised are:\n\n- KT-CT-4123: Unauthorized.\n- KT-CT-4180: Account note must be a valid string.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateAccountNote {
  possibleErrors: [PossibleErrorType]

  """Account, which has the added note."""
  account: AccountType
}

input CreateAccountNoteInput {
  """The account number."""
  accountNumber: String!

  """The note to add."""
  note: String!

  """Pin the note to account."""
  isPinned: Boolean!
}

"Renew agreements for an account.\n\nThis mutation calls tariff renewal use-case both\nfor electricity and gas agreements.\n\nThis mutation renews agreements from midnight the day it is invoked in the case of flexible\ntariffs and fixed tariffs ending in more than 90 days. For fixed tariffs that end in less\nthan 90 days, it creates follow on agreements that start when the fixed agreements end (or\nminimum of when they end in the case of misaligned agreements).\n\nThe possible errors that can be raised are:\n\n- KT-GB-4125: Invalid data.\n- KT-GB-4111: Unable to renew agreements for tariff renewal.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
type RenewAgreements {
  possibleErrors: [PossibleErrorType]
  account: AccountType
}

input RenewAgreementsInput {
  """Account number."""
  accountNumber: String!

  """
  The ID if the quoted product we wish to use to create new agreements. Part of the tariff renewal journey involves re-quoting to ensure this is available.
  """
  quotedProductId: ID!

  """The ID of the property that agreements should be renewed for."""
  propertyId: ID!

  """
  Where the account's current payment schedule has a debt repayment element, we let the user choose whether to continue making catch-up payments, or to repay the full debt in addition to their next payment.
  """
  makeFullDebtRepayment: Boolean!

  """
  If the customer is currently on a flat rate tariff, persist this into the new agreement.
  """
  persistFlatRate: Boolean

  """
  The date the new agreement takes effect. This can be no more than 90 days in the future.
  """
  changeOn: Date
}

"Renew agreement for a given meter point.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4112: Unable to renew agreements for meter point at this time. Please try again later.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type RenewAgreementForMeterPoint {
  possibleErrors: [PossibleErrorType]
  electricityAgreement: RestrictedElectricityAgreement
  gasAgreement: RestrictedGasAgreement
}

type RestrictedElectricityAgreement implements Node {
  validFrom: DateTime!
  validTo: DateTime

  """The ID of the object"""
  id: ID!
  tariffCode: String
}

type RestrictedGasAgreement implements Node {
  validFrom: DateTime!
  validTo: DateTime

  """The ID of the object"""
  id: ID!
  tariffCode: String
}

input RenewAgreementForMeterPointInput {
  """MPxN to renew the agreement for."""
  mpxn: String!

  """Tariff code for the new agreement."""
  tariffCode: String!

  """The start date of the new agreement (inclusive)."""
  validFromDate: Date!

  """The end date of the new agreement (exclusive)."""
  validToDate: Date

  """
  The date the agreement was agreed from (inclusive, if different to valid_from).
  """
  agreedFromDate: Date

  """Bespoke rates overriding those of the associated tariff."""
  bespokeTariffRates: BespokeTariffRatesInput = null

  """Information on the commission that's associated with this agreement."""
  commission: CommissionInput = null
}

input BespokeTariffRatesInput {
  """Bespoke standing charge."""
  standingCharge: Decimal

  """Gas bespoke unit rate."""
  unitRate: Decimal

  """Electricity bespoke unit rates with their associated rate type."""
  unitRates: [BespokeElectricityUnitRatesInput] = null
}

input BespokeElectricityUnitRatesInput {
  """
  Electricity bespoke unit rate to override the unit rate associated with the tariff.
  """
  unitRate: Decimal!

  """Rate type associated with the given unit rate."""
  rateType: NonBespokeElectricityRateTypeChoices!
}

"""An enumeration."""
enum NonBespokeElectricityRateTypeChoices {
  STANDARD
  ECO7_DAY
  ECO7_NIGHT
  OFF_PEAK
}

input CommissionInput {
  """The third-party intermediary who sold this renewal to the customer."""
  organizationName: String!

  """
  The amount to add to the unit rate when billing, in pence/kWh, which is paid to the third-party intermediary.
  """
  unitRateUplift: Decimal!

  """
  The fixed comission fee, in pence, which is paid to the third-party intermediary.
  """
  fixedTpiFee: Int
}

"Renew agreements provided for an account.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4113: At least one list of agreements to renew is required.\n- KT-GB-4126: Electricity and gas agreement input is invalid.\n- KT-GB-4114: Unable to renew agreements.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type RenewAgreementsForAccount {
  possibleErrors: [PossibleErrorType]
  account: AccountType
}

input RenewAgreementsForAccountInput {
  """Account number"""
  accountNumber: String!

  """
  A list of electricity agreements and the code of the product they will be renewed to.
  """
  electricityAgreements: [AgreementRenewalProductInput]

  """
  A list of gas agreements and the code of the product they will be renewed to.
  """
  gasAgreements: [AgreementRenewalProductInput]

  """
  The date the new agreement takes effect. This can be no more than 90 days in the future.
  """
  changeOn: Date
}

input AgreementRenewalProductInput {
  """
  The Kraken ID of the agreement to be renewed. The agreement must be currently active.
  """
  agreementId: ID!

  """The code of the product the agreement will be renewed to."""
  productCode: String!
}

"Set stated interest in acquiring a smart meter of an account.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4115: Could not create smart meter interest for account.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type UpdateAccountSmartMeterInterest {
  possibleErrors: [PossibleErrorType]
  interestUpdated: Boolean

  """The interest of an account in procuring smart meters."""
  smets2Interest: SmartMeterInterestChoices

  """The source category of the smart meter interest update."""
  smets2InterestSource: SmartMeterInterestSourceChoices

  """
  The reason why the account holder is not interested in having a smart meter installed.
  """
  smets2RefusalReason: SMETS2InterestReason
}

"""An enumeration."""
enum SmartMeterInterestSourceChoices {
  WEBSITE
  AFFILIATE
}

input UpdateAccountSmartMeterInterestInput {
  accountNumber: String!

  """Input field for setting smart meter interest."""
  smets2Interest: SmartMeterInterestChoices!

  """The source category of the smart meter interest update."""
  smets2InterestSource: SmartMeterInterestSourceChoices = WEBSITE

  """
  Input field for setting the reason for why a customer is not interested in a smart meter.
  """
  smets2RefusalReason: SMETS2InterestReason
}

"Onboarding for smart tariffs.\n\nThis mutation kicks off the smart onboarding for electricity.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4102: Unable to start smart onboarding process.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
type StartSmartOnboardingProcess {
  possibleErrors: [PossibleErrorType]
  onboardingProcess: SmartOnboardingProcessType

  """The product enrolment process created."""
  productEnrolment: ProductEnrolmentType
}

type SmartOnboardingProcessType {
  id: ID!
  account: AccountType!
  meterPoint: ElectricityMeterPointType
  product: EnergyProductType!
}

type ProductEnrolmentType {
  id: ID!
  account: AccountType!
  status: EnrolmentStatus!

  """The product associated with the enrolment."""
  product: EnergyProductType

  """The electricity meter point associated with the enrolment."""
  electricityMeterPoint: ElectricityMeterPointType

  """The gas meter point associated with the enrolment."""
  gasMeterPoint: GasMeterPointType

  """The stages that are part of the enrolment."""
  stages: [ProductEnrolmentStageType]
}

"""An enumeration."""
enum EnrolmentStatus {
  """Not started"""
  NOT_STARTED

  """In progress"""
  IN_PROGRESS

  """Completed"""
  COMPLETED

  """Cancelled"""
  CANCELLED

  """Failed"""
  FAILED

  """Errored"""
  ERRORED
}

type ProductEnrolmentStageType {
  """The name of the stage."""
  name: String

  """The current status of the stage."""
  status: EnrolmentStepStatus

  """The steps that are part of the enrolment stage."""
  steps: [ProductEnrolmentStepType]
}

"""An enumeration."""
enum EnrolmentStepStatus {
  SKIPPED
  COMPLETED
  PENDING
  IN_PROGRESS
  STALLED
  CANCELLED
  FAILED
  ERRORED
}

type ProductEnrolmentStepType {
  """The name of the step."""
  displayName: String

  """The current status of the step."""
  status: EnrolmentStepStatus

  """The date time that the step was last updated."""
  updatedAt: DateTime
}

input StartSmartOnboardingProcessInput {
  """Account number."""
  accountNumber: String!

  """The MPAN to switch."""
  mpan: String

  """The MPRN to switch."""
  mprn: String

  """The product code to switch to."""
  productCode: String!
  isNewAccount: Boolean = false
  termsAndConditions: TermsAndConditions = null

  """
  A target start date for the new agreement. Must be today or later. Will be ignored if date is in the past at time of creating the new agreement.
  """
  targetAgreementChangeDate: Date
}

input TermsAndConditions {
  """The version of the terms and conditions the user was presented with."""
  version: String!
  accepted: Boolean!
}

"Onboarding for export tariffs.\n\nThis mutation kicks off the export onboarding for electricity.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4103: Unable to start export onboarding process.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
type StartExportOnboardingProcess {
  possibleErrors: [PossibleErrorType]
  onboardingProcess: SmartOnboardingProcessType

  """The product enrolment process created."""
  productEnrolment: ProductEnrolmentType
}

input StartExportOnboardingProcessInput {
  """Account number."""
  accountNumber: String!

  """The import MPAN."""
  importMpan: String

  """The export MPAN."""
  exportMpan: String

  """The export product code."""
  productCode: String!

  """The export technology type."""
  technologyType: ExportTechnologyType!

  """The FiT ownership status."""
  fitStatus: FITStatus!

  """Whether to take over the FiT generation payments."""
  includeFitGeneration: Boolean = false

  """The FiT ID."""
  fitId: String

  """The export certificate object."""
  certificate: Certificate = null

  """The DNO status."""
  dnoStatus: DNOStatus!

  """
  Have the terms and conditions for this product been accepted? To be deprecated.
  """
  termsAndConditionsAccepted: Boolean!

  """Version of the terms and conditions that have been accepted."""
  acceptedTermsAndConditionsVersion: String
}

"""The type of generator technology used for export."""
enum ExportTechnologyType {
  """Hydro"""
  HYDRO

  """Photovoltaic"""
  SOLAR

  """Storage"""
  STORAGE

  """Wind"""
  WIND

  """Photovoltaic and Storage"""
  SOLAR_AND_STORAGE

  """Wind and Storage"""
  WIND_AND_STORAGE
}

"""The ownership status of FiT for this property."""
enum FITStatus {
  """Notified"""
  OWNER

  """Previous owner"""
  PREVIOUS_OWNER

  """Third party owned"""
  THIRD_PARTY_OWNED

  """Unknown"""
  UNKNOWN

  """None"""
  NONE
}

input Certificate {
  """The export certificate number."""
  number: String!

  """The export certificate type."""
  type: CertificateType!
}

"""The export certificate type."""
enum CertificateType {
  MCS
  FLEXI_ORB
}

"""The status of DNO being notified of this export request."""
enum DNOStatus {
  """Notified"""
  NOTIFIED

  """Not Notified"""
  NOT_NOTIFIED

  """Unknown"""
  UNKNOWN
}

"Mutation to update the Supply Start Date (SSD) of an account.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4101: Unable to update SSD for account.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type UpdateSsd {
  possibleErrors: [PossibleErrorType]
  ssdUpdated: Boolean
  estimatedSsd: Date
}

input UpdateSsdInput {
  """The account number."""
  accountNumber: String!

  """The desired Supply Start Date (SSD)."""
  desiredSsd: Date!
}

"""
Create a Siteworks event.

Currently, only events for reporting are enabled.
"""
type CreateSiteworksEvent {
  eventCreated: Boolean
}

input CreateSiteworksEventInput {
  """The Siteworks request id."""
  siteworksRequestId: String!

  """The type of Siteworks event that will be created."""
  eventType: SiteworksEventType!

  """The content that might be submitted as field servies data."""
  fieldServicesData: JSONString

  """The references that are related to jobs, appointments etc."""
  references: JSONString

  """The notes that are associated with the Siteworks event."""
  eventNotes: String
}

"\n    Please note: these labels are exposed in the API documentation.\n    "
enum SiteworksEventType {
  """SMICOP compliance report submitted"""
  SMICOP_COMPLIANCE_REPORT_SUBMITTED
}

"Makes it possible to create Sitework events by external third parties.\n\nThis mutation uses the external JWT authorization method.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4222: The provided 'siteworksRequestId' is not a valid UUID.\n- KT-GB-4223: Siteworks request not found. Check the provided 'siteworksRequestId' is correct.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateSiteworksEventExternal {
  possibleErrors: [PossibleErrorType]
  eventCreated: Boolean
}

"Create a new job or update the status of an existing one.\n\nThe possible errors that can be raised are:\n\n- KT-CT-1112: 'Authorization' header not provided.\n- KT-CT-4231: Unauthorized.\n- KT-GB-4230: Invalid data.\n- KT-GB-4224: Error processing siteworks appointment.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateOrUpdateSiteworksAppointment {
  possibleErrors: [PossibleErrorType]
  result: CreateOrUpdateSiteworksAppointmentOutput
}

type CreateOrUpdateSiteworksAppointmentOutput {
  appointmentCreated: Boolean
  appointmentUpdated: Boolean
}

input CreateOrUpdateSiteworksAppointmentInput {
  """
  The market ID of the agent that carried out the work. This should be an electricity market participant ID or gas market code.
  """
  agentId: String!

  """The unique appointment reference of the agent."""
  appointmentReference: String!

  """
  The scheduled date of the appointment. Required if the appointment is not already booked.
  """
  appointmentDate: Date!

  """The status of the appointment."""
  status: AppointmentStatus!

  """The type of work the appointment has been booked for."""
  workType: String

  """The categories of meter the work applies to."""
  fuelType: FuelType!

  """Required if `fuel_type` is `ELECTRICITY` or `DUAL_FUEL`."""
  mpan: String

  """Required if `fuel_type` is `GAS` or `DUAL_FUEL`."""
  mprn: String
  electricitySupplyType: ElectricitySupplyType = null
  gasSupplyType: GasSupplyType = null

  """
  The start time of the slot during which the engineer is scheduled at the property.
  """
  timeSlotStart: Time!

  """
  The end time of the slot during which the engineer is scheduled at the property.
  """
  timeSlotEnd: Time

  """Address of the property where the appointment is taking place."""
  address: AddressInput = null

  """Boolean flag to indicate an emergency appointment."""
  isEmergency: Boolean

  """Name of engineer currently assigned to the appointment."""
  engineerName: String

  """
  Extra context to a change in status such as abort or cancellation reason.
  """
  statusReason: String

  """Free text comments about the appointment."""
  jobNotes: String

  """If applicable, the category of new meters installed."""
  newMeterCategory: NewMeterCategory = null

  """A list of electricity meters that the work applies to."""
  electricityMeters: [MeterInput] = null

  """A list of electricity meters that the work applies to."""
  gasMeters: [MeterInput] = null
}

"""An enumeration."""
enum AppointmentStatus {
  """The appointment has been booked."""
  BOOKED

  """The appointment was cancelled either by the customer or the agent."""
  CANCELLED

  """
  The appointment was aborted. Choose this option for partially completed work (e.g. on a dual fuel meter exchange where one meter was exchanged successfully but the other exchange could not be completed.
  """
  ABORTED

  """The appointment has been completed successfully."""
  COMPLETED
}

"""An enumeration."""
enum FuelType {
  """Electricity."""
  ELECTRICITY

  """Gas."""
  GAS

  """Dual Fuel."""
  DUAL_FUEL
}

"""An enumeration."""
enum ElectricitySupplyType {
  """Single phase meter point."""
  SINGLE_PHASE

  """Three phase meter point."""
  THREE_PHASE
}

"""An enumeration."""
enum GasSupplyType {
  """Standard pressure gas supply."""
  STANDARD

  """Medium pressure gas supply."""
  MEDIUM
}

input AddressInput {
  addressLine1: String
  addressLine2: String
  addressLine3: String
  addressLine4: String
  addressLine5: String

  """Postcode of the property where the appointment took place."""
  postcode: String!
}

"""An enumeration."""
enum NewMeterCategory {
  """SMETS1 (first generation smart meter)."""
  SMETS1

  """SMETS2 (second generation smart meter)."""
  SMETS2

  """Traditional meter."""
  TRADITIONAL

  """Check Meter."""
  CHECK_METER
}

input MeterInput {
  """Serial number of the meter involved in the appointments"""
  serialNumber: String!

  """
  Whether the meter details refer to a meter that is currently installed at the site or one that has been removed or replaced.
  """
  status: MeterStatus = null

  """
  The type of meter. This field is not required but should be supplied whenever possible.
  """
  meterType: String
}

"""An enumeration."""
enum MeterStatus {
  """The meter was removed."""
  REMOVED

  """The meter was installed or work was done on an existing meter."""
  ON_SITE
}

"""
Allows account users and organisations to cancel siteworks appointment.
"""
type CancelSiteworksAppointment {
  siteworksAppointment: ActiveAppointmentType
}

type ActiveAppointmentType {
  id: UUID!
  agent: SiteworksAppointmentAgent

  """The current status of the Siteworks application."""
  status: SiteworksAppointmentStatus
  appointmentDate: Date!
  timeSlotStart: Time
  timeSlotEnd: Time
  createdAt: DateTime!

  """The category of work the appointment has been booked for."""
  workCategory: WorkCategory
  date: Date
  requestId: String
  agentReference: String
}

"""
Leverages the internal Python implementation of UUID (uuid.UUID) to provide native UUID objects
in fields, resolvers and input.
"""
scalar UUID

"""An enumeration."""
enum SiteworksAppointmentAgent {
  """Smart Metering Systems"""
  SMS

  """AES Smart Metering"""
  AES

  """Octopus Energy Services"""
  OES

  """Providor Ltd"""
  PROVIDOR

  """Morrison Data Services"""
  MDS

  """E.on Metering"""
  EON_METERING

  """Lowri Beck Services Ltd"""
  LOWRI_BECK

  """MeterPlus"""
  METERPLUS

  """Enterprise Managed Services Ltd"""
  ENTERPRISE_MANAGED

  """Midlands Electricity plc"""
  MIDS_ELEC

  """Northern Powergrid"""
  N_POWERGRID

  """Electricity North West Limited"""
  ELEC_NW

  """National Grid"""
  NATIONAL_GRID

  """SGN Metering Services"""
  SGN

  """Energy Assets Ltd"""
  ENERGY_ASSETS

  """Siemens Metering Services"""
  SIEMENS

  """EDF Energy Customers Ltd"""
  LONDON

  """EDF Energy Customers PLC"""
  ECM

  """Octopus Energy Services Ltd"""
  OESL
}

"""An enumeration."""
enum SiteworksAppointmentStatus {
  """The Siteworks appointment that has been booked."""
  BOOKED

  """The Siteworks work that has been completed."""
  COMPLETED

  """The Siteworks appointment that has been aborted."""
  ABORTED

  """The Siteworks appointment that has been cancelled."""
  CANCELLED
}

"\n    Categories of work that a Siteworks appointment is booked for.\n    "
enum WorkCategory {
  """Exchange."""
  EXCHANGE

  """Move."""
  MOVE

  """New Connection."""
  NEW_CONNECTION

  """Remove."""
  REMOVE

  """Reinstall."""
  REINSTALL

  """Investigate Fault."""
  INVESTIGATE_FAULT

  """Ihd Install."""
  IHD_INSTALL

  """Commission."""
  COMMISSION

  """Comms Hub Power Cycle."""
  COMMS_HUB_POWER_CYCLE

  """Comms Hub Replacement."""
  COMMS_HUB_REPLACEMENT

  """Meter Tails Upgrade."""
  METER_TAILS_UPGRADE

  """Isolator Switch Install."""
  ISOLATOR_SWITCH_INSTALL

  """Accuracy Test."""
  ACCURACY_TEST

  """Bracket Installation."""
  BRACKET_INSTALLATION

  """Confirm Meter Details."""
  CONFIRM_METER_DETAILS

  """Replace Seals."""
  REPLACE_SEALS

  """Energise."""
  ENERGISE

  """De Energise."""
  DE_ENERGISE
}

input CancelSiteworksAppointmentInput {
  """The siteworks appointment Kraken unique ID."""
  appointmentId: ID

  """The siteworks appointment agent reference code."""
  agentReference: String
}

"The possible errors that can be raised are:\n\n- KT-GB-4219: Property does not exist.\n- KT-GB-4220: No account currently active at property.\n- KT-GB-4221: Could not confirm duplicate property.\n- KT-GB-4228: Cannot currently book appointments for legacy prepay meters.\n- KT-GB-4229: A smart meter exchange appointment for this date already exists.\n- KT-GB-4210: Bookings not supported for agent appointed at property.\n- KT-GB-4211: Timeslot no longer available.\n- KT-GB-4212: Missing or invalid data for account or property.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type ConfirmSiteworksAppointmentSlot {
  possibleErrors: [PossibleErrorType]
  siteworksAppointment: ActiveAppointmentType
}

input ConfirmSiteworksAppointmentSlotInput {
  propertyId: ID!
  appointmentDate: Date!
  startTime: Time!
  endTime: Time!
  additionalInformation: String
  agentReference: String
  siteId: String
  slotId: String
  calculationId: String
  promiseId: String

  """
  Determines which communications will be sent to customers for the appointment. The default is to send all available messages (e.g. appointment confirmed, job completed).
  """
  commsStrategy: CommsStrategyType = SEND_ALL
}

enum CommsStrategyType {
  SEND_ALL
  SEND_ONLY_JOB_COMPLETED
  SUPPRESS_ALL
}

"The possible errors that can be raised are:\n\n- KT-GB-4213: Application not found.\n- KT-GB-4231: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type ReportRemovedMeterDetails {
  possibleErrors: [PossibleErrorType]
  result: ReportRemovedMeterDetailsOutput
}

type ReportRemovedMeterDetailsOutput {
  appointment: SiteworksAppointmentType
  electricityMeterPoint: SiteworksBookingElectricityMeterPointType
  gasMeterPoint: SiteworksBookingGasMeterPointType
}

type SiteworksAppointmentType {
  activeAppointment: ActiveAppointmentType
  account: AccountType
  property: PropertyType
}

"""
This type holds information about an electricity meter point that is used by partner organisations to book siteworks.
"""
type SiteworksBookingElectricityMeterPointType implements SiteworksBookingMeterPointInterface {
  id: ID!
  supplyEndDate: Date
  mpan: String!

  """Standard settlement configuration"""
  ssc: String!
  energisationStatus: String!
  dccServiceFlag: String!
  status: String!
  isOnSupply: Boolean!

  """The latest supply period of the meterpoint."""
  latestSupplyPeriod: SupplyPeriodType

  """Whether this meter point has a meter which is due a reading."""
  isMeterReadingDue(maxReadingAge: Int): Boolean!
  meters(id: Int, includeInactive: Boolean): [ElectricityMeterType]

  """The distribution network the grid supply point falls under"""
  gspGroupId: String

  """A list of agents responsible for management of the meterpoint."""
  agentContracts(
    """Filter the contracts by status."""
    statuses: [AgentContractStatusType]
  ): [ElectricityAgentContractType]
}

"""Interface for common fields for SiteworksBookingMeterpoints."""
interface SiteworksBookingMeterPointInterface {
  status: String!
  isOnSupply: Boolean!

  """The latest supply period of the meterpoint."""
  latestSupplyPeriod: SupplyPeriodType

  """Whether this meter point has a meter which is due a reading."""
  isMeterReadingDue(maxReadingAge: Int): Boolean!
}

type SupplyPeriodType {
  """The start date of the supply period."""
  supplyStartAt: DateTime

  """The end date of the supply period."""
  supplyEndAt: DateTime
}

"""
This type holds information about a gas meter point that is used by partner organisations to book siteworks.
"""
type SiteworksBookingGasMeterPointType implements SiteworksBookingMeterPointInterface {
  id: ID!
  supplyEndDate: Date
  mprn: String
  status: String!
  isOnSupply: Boolean!

  """The latest supply period of the meterpoint."""
  latestSupplyPeriod: SupplyPeriodType

  """Whether this meter point has a meter which is due a reading."""
  isMeterReadingDue(maxReadingAge: Int): Boolean!
  meters(id: Int, includeInactive: Boolean): [GasMeterType]

  """A list of agents responsible for management of the meterpoint."""
  agentContracts(
    """Filter the contracts by status."""
    statuses: [AgentContractStatusType]
  ): [GasAgentContractType]
}

input ReportRemovedMeterDetailsInput {
  """
  The installer/agents own booking reference for the appointment to remove these meters.
  """
  appointmentId: String
  electricityMeterPoint: RemovedElectricityMeterPointInput = null
  gasMeterPoint: RemovedGasMeterPointInput = null
}

input RemovedElectricityMeterPointInput {
  mpan: String
  meters: [RemovedElectricityMeterInput] = null
}

input RemovedElectricityMeterInput {
  serialNumber: String!
  meterType: ElectricityMeterTypes = null
  registers: [RemovedElectricityMeterRegisterInput]!
  readAt: DateTime
  prepayData: RemovedMeterPrepayDataInput = null
}

"""An enumeration."""
enum ElectricityMeterTypes {
  """Key."""
  K

  """Smartcard."""
  S

  """Token."""
  T
}

input RemovedElectricityMeterRegisterInput {
  """Identifier string/label for the register."""
  id: String!
  finalReading: Float!
}

input RemovedMeterPrepayDataInput {
  """The credit balance of the meter in millipence."""
  balance: Int

  """The total of all debt left on the removed meter in millipence."""
  cumulativeDebtBalance: Int

  """Amount of emergency credit remaining on the meter in millipence."""
  emergencyCreditBalance: Int
}

input RemovedGasMeterPointInput {
  mprn: String
  meters: [RemovedGasMeterInput] = null
}

input RemovedGasMeterInput {
  serialNumber: String!
  meterType: GasMeterTypes = null
  finalReading: Float!
  readAt: DateTime
  prepayData: RemovedMeterPrepayDataInput = null
}

"""An enumeration."""
enum GasMeterTypes {
  """Prepayment."""
  PP

  """Electronic token."""
  ET
}

"The possible errors that can be raised are:\n\n- KT-GB-5411: Failed to update special circumstance record.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type UpdateSpecialCircumstances {
  possibleErrors: [PossibleErrorType]
  specialCircumstances: SpecialCircumstancesType
}

type DirectDebitPaymentDayUpdate {
  paymentSchedule: PaymentScheduleType
  errors: [ErrorType]
}

input DirectDebitPaymentDayUpdateInput {
  accountNumber: String!
  paymentDay: Int!
}

"The possible errors that can be raised are:\n\n- KT-GB-3918: Account not found.\n- KT-GB-3910: This feature is not available to business accounts.\n- KT-GB-3911: Your payment day cannot be changed at this time.\n- KT-GB-3912: Unable to update payment day.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
type UpdatePaymentSchedulePaymentDay {
  possibleErrors: [PossibleErrorType]
  paymentSchedule: PaymentScheduleType
}

input UpdatePaymentSchedulePaymentDayInput {
  accountNumber: String!
  paymentDay: Int!
}

"The possible errors that can be raised are:\n\n- KT-GB-3919: Invalid payment schedule amount.\n- KT-GB-3920: Cannot update payment schedule amount.\n- KT-CT-3923: Unauthorized.\n- KT-CT-3941: Invalid data.\n- KT-CT-3942: An unexpected error occurred.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type UpdatePaymentSchedulePaymentAmount {
  possibleErrors: [PossibleErrorType]
  paymentSchedule: PaymentScheduleType
}

input UpdatePaymentSchedulePaymentAmountInput {
  accountNumber: String!

  """Amount in pence"""
  amount: Int!
}

"The possible errors that can be raised are:\n\n- KT-CT-3940: Invalid data.\n- KT-CT-3923: Unauthorized.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type CreateDirectDebitInstruction {
  possibleErrors: [PossibleErrorType]
  directDebitInstruction: DirectDebitInstructionType
}

input CreateDirectDebitInstructionInput {
  accountNumber: String!
  directDebitInstruction: DirectDebitInstructionLocalBankDetailsInput!
}

"Mutation for creating an Payment Schedule instance using the authenticated user.\n\nThe possible errors that can be raised are:\n\n- KT-GB-3917: No statement in last 60 days.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
type CreatePaymentSchedule {
  possibleErrors: [PossibleErrorType]
  paymentSchedule: PaymentScheduleType
}

input PaymentScheduleInput {
  """Input a customer account number."""
  accountNumber: String!

  """Payment amount must be inputted as pence."""
  paymentAmount: Int!

  """Input a direct debit payment day."""
  paymentDay: Int!
}

type WarmHomeDiscountApplicationOutputType {
  errors: [SerializerFieldErrorsType]
  id: String
}

input WarmHomeDiscountApplicationInputType {
  """
  A set of criteria under which someone is eligible for the Warm Home Discount. The applicant must meet at least one of these criteria, as well as at least one qualifying component criteria.
  """
  qualifyingCriteria: QualifyingCriteriaOptions = null

  """
  A set of criteria under which someone is eligible for the Warm Home Discount. The applicant must meet at least one of these criteria, as well as at least one qualifying component criteria.
  """
  qualifyingComponent: CurrentQualifyingComponentOptions = null
}

"""An enumeration."""
enum CurrentQualifyingComponentOptions {
  PERSONAL_INDEPENDENCE_PAYMENTS
  DISABILITY_BENEFITS
  INCOME_RELATED_BENEFITS
  MATERNITY_EXEMPTION_CERTIFICATE
  AGE_THRESHOLD
  HAS_DISABILITY
  ADULT_DISABILITY_PAYMENT
  DEPENDENT_CHILD_UNDER_FIVE
  DEPENDENT_CHILD_OVER_FIVE
  LIMITED_CAPABILITY_FOR_WORK
}

type CreateMeterReadingOutputType {
  readingErrors: [SerializerFieldErrorsType]
  id: String @deprecated(reason: "The 'id' field is deprecated.\n\nThe `ID` field is depreciated.\n\n- Marked as deprecated on 2022-10-03.\n- Will be removed on 2024-01-01.")
}

input ReadingInputType {
  registerId: ID
  reading: Int
}

"""Amend unbilled electricity reading."""
type AmendUnbilledElectricityReading {
  readingAmended: Boolean
}

input AmendUnbilledReadingInput {
  """The ID of the reading that will be amended."""
  readingId: Int!

  """The new value of reading."""
  readingValue: Int!

  """The new datetime of reading."""
  readingDatetime: DateTime!
}

type CreateQuoteOutputType {
  errors: [SerializerFieldErrorsType]
  quote: QuoteType
}

type QuoteType {
  code: String
  postcode: String!
  gspGroupId: String
  includesElectricity: Boolean!
  includesGas: Boolean!
  isBusiness: Boolean!

  """The meter type for the quote."""
  meterType: MeterTypes
  mpan: String!
  paymentMethod: QuotePaymentMethod!

  """In kWh"""
  elecAnnualConsumptionStandard: Int

  """In kWh"""
  elecAnnualConsumptionDay: Int

  """In kWh"""
  elecAnnualConsumptionNight: Int
  elecEstimate: Boolean!

  """In kWh"""
  gasAnnualConsumption: Int
  gasEstimate: Boolean!
  partnerProductId: Int
  latitude: Float
  longitude: Float
  address: QuoteAddressType
  consumptionEstimates: ConsumptionEstimates

  """
  A list of the products that have been quoted for the usage provided at the time the quote was created.
  """
  quotedProducts(id: String): [QuotedProductType]
  termsAndConditions: TermsAndConditionsType
  mprn: String
}

"""An enumeration."""
enum MeterTypes {
  NO_METER
  STANDARD
  ECONOMY7
  SMART
  SMART_ECONOMY7
  SMART_FLAT_ECONOMY7
  FLAT_ECONOMY7
  THREE_RATE
  FLAT_THREE_RATE
  OTHER
}

"""An enumeration."""
enum QuotePaymentMethod {
  """Direct Debit"""
  DIRECTDEBIT

  """Credit card"""
  CREDITCARD

  """Pay on receipt of bill"""
  ONRECEIPT

  """Prepayment"""
  PREPAYMENT
}

type QuoteAddressType {
  addressLine1: String
  addressLine2: String
  addressLine3: String
}

type ConsumptionEstimates {
  low: ConsumptionEstimate
  medium: ConsumptionEstimate
  high: ConsumptionEstimate
}

type ConsumptionEstimate {
  elecAnnualConsumptionStandard: Int
  elecAnnualConsumptionDay: Int
  elecAnnualConsumptionNight: Int
  gasAnnualConsumption: Int
}

type QuotedProductType {
  id: ID!
  name: String!
  description: String!
  product: EnergyProductType
  recommended: Boolean!

  """
  Estimated cost in pence of the product per month based on the quoted usage.
  """
  monthlyAmount: Int

  """
  Estimated cost in pence of the product over a year based on the quoted usage. 
  """
  annualAmount: Int

  """
  Estimated saving in pence vs the 'Big 6' of the product over a year based on the quoted usage.
  """
  annualSaving: Int
  elecTariffCode: String!
  gasTariffCode: String!

  """
  Electricity tariff information label (TIL) provides standardised information between suppliers about a tariff.
  """
  electricityTariffInformationLabel: TariffInformationLabelType

  """
  Gas tariff information label (TIL) provides standardised information between suppliers about a tariff.
  """
  gasTariffInformationLabel: TariffInformationLabelStandard

  """Whether or not this is a variable product."""
  isVariable: Boolean

  """A list of dates allowable to start supply of the quoted product."""
  allowedSupplyStartDates: [Date]

  """The amount of co2 saved per year when this product is chosen"""
  co2SavingInKg: Int

  """
  The number of trees it would take to offset the amount of co2 that is saved per year when this product is chosen
  """
  treesSaving: Int
  includesCarbonOffsetting: Boolean
}

union TariffInformationLabelType = TariffInformationLabelStandard | TariffInformationLabelEco7 | TariffInformationLabelThreeRate

type TariffInformationLabelStandard {
  supplier: String
  tariffName: String
  tariffType: String
  tariffCode: String
  paymentMethod: String
  tariffEndsOn: String
  priceGuaranteedUntil: String
  exitFees: Int
  exitFeesType: String
  additionals: String
  tariffComparisonRate: Float
  standingCharge: Float
  estimatedAnnualCost: Int
  annualStandingCharge: Float
  unitRate: Float
  assumedAnnualConsumption: Int
}

type TariffInformationLabelEco7 {
  supplier: String
  tariffName: String
  tariffType: String
  tariffCode: String
  paymentMethod: String
  tariffEndsOn: String
  priceGuaranteedUntil: String
  exitFees: Int
  exitFeesType: String
  additionals: String
  tariffComparisonRate: Float
  standingCharge: Float
  estimatedAnnualCost: Int
  annualStandingCharge: Float
  unitRateDay: Float
  unitRateNight: Float
  assumedAnnualConsumptionDay: Int
  assumedAnnualConsumptionNight: Int
}

type TariffInformationLabelThreeRate {
  supplier: String
  tariffName: String
  tariffType: String
  tariffCode: String
  paymentMethod: String
  tariffEndsOn: String
  priceGuaranteedUntil: String
  exitFees: Int
  exitFeesType: String
  additionals: String
  tariffComparisonRate: Float
  standingCharge: Float
  estimatedAnnualCost: Int
  annualStandingCharge: Float
  unitRateDay: Float
  unitRateNight: Float
  unitRateOffPeak: Float
  assumedAnnualConsumptionDay: Int
  assumedAnnualConsumptionNight: Int
  assumedAnnualConsumptionOffPeak: Int
}

input CreateQuoteInput {
  postcode: String!
  electricityMeterPoints: [ElectricityMeterPointConsumptionInput]
  gasMeterPoints: [GasMeterPointConsumptionInput]

  """
  Used to verify the position that field sales agents generate quotes from
  """
  position: PositionInput
  gspGroupId: String = ""
  affiliateSessionId: String = ""
  brandCode: String!

  """Optional address information about the customer"""
  address: QuoteAddressInput
  isBusiness: Boolean = false

  """
  Whether the user has consented to their energy consumption estimates being retrieved from the industry vendors. This currently applies to business accounts only.
  """
  hasConsentedToIndustryDataSearch: Boolean = false

  """
  Optional parameter to select the payment method for the quote, default is direct debit.
  """
  paymentMethod: QuotePaymentMethodChoices = DIRECTDEBIT
}

input PositionInput {
  latitude: Float
  longitude: Float
}

input QuoteAddressInput {
  addressLine1: String = ""
  addressLine2: String = ""
  addressLine3: String = ""
}

"""An enumeration."""
enum QuotePaymentMethodChoices {
  DIRECTDEBIT
  CREDITCARD
  ONRECEIPT
  PREPAYMENT
}

"The possible errors that can be raised are:\n\n- KT-GB-4612: Unable to refresh quote - quote not found.\n- KT-GB-4613: Error generating quote.\n- KT-CT-1113: Disabled GraphQL field requested.\n"
type RefreshQuote {
  possibleErrors: [PossibleErrorType]
  quote: QuoteType
}

input RefreshQuoteInput {
  code: String!
}

type Requote {
  quote: QuoteType
}

input RequoteInput {
  accountNumber: String!
  propertyId: ID!
  productAvailableAt: DateTime
  includeHiddenProducts: Boolean
  persistFlatRate: Boolean

  """
  Optional parameter to select the payment method for the quote, default is direct debit.
  """
  paymentMethod: QuotePaymentMethodChoices = DIRECTDEBIT
}

"""
Bill an account with a smart meter to the most recent midnight snapshot reading.
"""
type BillToLatestSmartMeterSnapshot {
  """The date that has been billed up to."""
  billedToDate: Date

  """The balance after attempting to bill."""
  currentBalance: Decimal
}

input BillToLatestSmartMeterSnapshotInput {
  """The account number."""
  accountNumber: String!

  """The mpan number."""
  mpan: String!
}

"Switch the provided meter points to the specified product.\n\nThe possible errors that can be raised are:\n\n- KT-GB-4116: Invalid data.\n- KT-GB-4617: Quoted product not found.\n- KT-CT-4623: Unauthorized.\n- KT-GB-4117: Unable to process product switch.\n- KT-GB-4119: Meter point already on another account.\n- KT-GB-4120: MPxN has no active agreement.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type SwitchMeterPointProducts {
  possibleErrors: [PossibleErrorType]

  """
  The account associated with the meter points whose products were switched.
  """
  account: AccountType
}

input SwitchMeterPointProductsInput {
  """Account number."""
  accountNumber: String!

  """
  The information required to switch each meter point onto the specified product.
  """
  meterPointSwitchContexts: [MeterPointSwitchContext!]!

  """
  Runs payment adequacy and checks if the amount - the customer is paying each month - should be updated.
  """
  updatePaymentAmount: Boolean
}

input MeterPointSwitchContext {
  """The MPxN of the meter point."""
  mpxn: String!

  """The ID of the selected quoted product."""
  quotedProductId: ID!

  """
  The date the product switch should take effect. Defaults to the current agreement end date, or tomorrow if the agreement is open-ended.
  """
  changeOn: Date

  """Information on the commission that's associated with this agreement."""
  commission: CommissionInput = null

  """Should the meter point be on a flat rate."""
  flatRate: Boolean
}

"The possible errors that can be raised are:\n\n- KT-GB-6812: Invalid data.\n- KT-CT-1113: Disabled GraphQL field requested.\n- KT-CT-1111: Unauthorized.\n- KT-CT-1112: 'Authorization' header not provided.\n"
type FitCreateMeterReadings {
  possibleErrors: [PossibleErrorType]
  readingsSubmitted: Boolean
}

"""
The GraphQL error type for displaying information about
GraphQL errors that might be raised from the API.
"""
type PossibleErrorType {
  """The error message that might be returned from the query/mutation."""
  message: String

  """The error code that might be returned from the query/mutation."""
  code: String

  """The error type that might be returned from the query/mutation."""
  type: String

  """The error description that might be returned from the query/mutation."""
  description: String
}

input FitMeterReadingInput {
  installations: [FitInstallationInput]!
}

input FitInstallationInput {
  fitId: String!
  meters: [FitMeterInput]!
}

input FitMeterInput {
  id: Int!
  reading: FitReadingInput!
}

input FitReadingInput {
  value: Decimal!
  readAt: DateTime!
  isBiennial: Boolean
}

type LivePaymentAdequacyQuery {
  """
  The suggested monthly payment amount in pence following the payment adequacy review.
  """
  recommendedPayment: PaymentBreakdown

  """How much balance we expect the account to have at this time of year."""
  currentBalance: Int

  """How much balance we expect the account to have at this time of year."""
  targetBalance: Int

  """Breakdown of customer's usage per source and per month."""
  estimatedConsumption: [ConsumptionBreakdown]

  """The date that we used to calculate the review of the account."""
  reviewedOn: Date
}

type PaymentBreakdown {
  """Total to pay: ongoing + adjustment."""
  total: Int

  """Amount which covers ongoing usage."""
  ongoing: Int

  """Temporary amount to cover debt."""
  adjustment: Int
}

type ConsumptionBreakdown {
  """Human readable name of what the usage is for."""
  sourceName: String

  """Unique identifier of the source of the usage."""
  sourceId: String

  """Monthly usage in pence. First month is January."""
  usage: [Int]
}

type SEGInstallationType {
  """Whether the SEG installation is valid according to MCS."""
  isValid: Boolean!
}

"""
Queries are the GraphQL equivalent of GET requests in REST. By convention, they do not mutate data. To learn about how to form Queries in graphql, see [GraphQL's documentation](https://graphql.org/learn/queries/).

 This interface will autocomplete, so just try typing what you want. You can also search these docs. Some queries will require authentication. Check the documentation or search `Authentication` for details.
"""
type Query {
  """Get a meter point via it's associated mpan or mprn."""
  meterPoints(
    """The MPAN for the electricity meterpoint to return."""
    mpan: ID

    """The MPRN for the gas meterpoint to return."""
    mprn: ID
  ): MeterPointInterface
  applicableRates(accountNumber: String!, mpxn: String!, startAt: DateTime!, endAt: DateTime!, before: String, after: String, first: Int, last: Int): ApplicableRateConnectionTypeConnection

  """This is a work in progress and not in use yet."""
  quoteRequest(
    """Code of the quote request."""
    quoteCode: String!
  ): QuoteRequest

  """Follow on product."""
  followOnProduct(
    """Kraken account number."""
    accountNumber: String!

    """Electricity agreement Kraken ID."""
    electricityAgreementId: ID

    """Gas agreement Kraken ID."""
    gasAgreementId: ID
    validAt: DateTime!
  ): FollowOnProductType

  """Available energy product, whose display name has the given prefix."""
  availableProductFromDisplayName(
    """Display name of the product."""
    displayName: String!
  ): EnergyProductType

  """
  A list of product codes that are the currently available products for a meter point.
  """
  availableProductsForMeterPoint(
    """Kraken account number."""
    accountNumber: String!

    """A list of MPxNs."""
    mpxns: [String]!
    availableAt: DateTime!
  ): [MPxNProductType]

  """Get an energy product that matches the given code."""
  energyProduct(
    """Code for the energy product."""
    code: String!
  ): EnergyProductType

  """
  Get all products for a given brand and postcode. The supplied postcode will ensure that there are tariffs available on the product for the GSP.
  """
  energyProducts(
    """Postcode to search energy products for."""
    postcode: String!

    """Filter by a specific energy brand."""
    brand: String

    """Filter by these brands."""
    brands: [String]

    """Filter for available or unavailable products only."""
    availability: EnergyProductAvailability

    """Filter by the type of energy product."""
    filterBy: [EnergyProductFilters]
    before: String
    after: String
    first: Int
    last: Int
  ): EnergyProductConnectionTypeConnection
  electricityPrepayLedgers(accountNumber: String!, mpan: String!, serialNumber: String!): PrepayLedgersType
  gasPrepayLedgers(accountNumber: String!, mprn: String!, serialNumber: String!): PrepayLedgersType

  """Payments made to add credit to the account's smart prepay meters."""
  prepayPayments(accountNumber: String!, before: String, after: String, first: Int, last: Int): PrepayPaymentConnectionTypeConnection

  " Get an electricity agreement. \n\n \n\nThis field requires the `Authorization` header to be set. \n\n"
  electricityAgreement(id: ID!): AgreementInterface

  " Get an gas agreement. \n\n \n\nThis field requires the `Authorization` header to be set. \n\n"
  gasAgreement(id: ID!): AgreementInterface

  """Get the details of a product enrolment."""
  productEnrolment(
    """The account to which the enrolment belongs."""
    accountNumber: String!

    """The ID for the enrolment."""
    enrolmentId: ID!
  ): ProductEnrolmentType

  """Get all of the enrolments for an account."""
  productEnrolments(
    """The account to find all the enrolments for."""
    accountNumber: String!
  ): [ProductEnrolmentType]

  """Validate a bank account."""
  validateBankAccount(accountNumber: String!, sortCode: String!, vendor: PaymentsVendorChoices = SMARTDEBIT): ValidateBankAccount

  """
  Earliest possible payment date from today for which the first direct debit payment can be made.
  """
  earliestPossibleDirectDebitPaymentDate: EarliestPossibleDirectDebitPaymentDate

  """The annual electricity consumption data for an MPAN."""
  annualElectricityConsumption(
    """The MPAN of the meterpoint to return."""
    mpan: String!
  ): ElectricityConsumptionType!

  """The annual gas consumption data for an MPRN."""
  annualGasConsumption(
    """The MPRN of the meterpoint to return."""
    mprn: String!
  ): GasConsumptionType!

  """The validity of a SEG installation via the MCS installation database."""
  segInstallation(
    """The MCS certificate number."""
    mcsCertificateNumber: String!
  ): SEGInstallationType!

  """Get up to date payment adequacy data."""
  livePaymentAdequacy(
    """Kraken account number."""
    accountNumber: String!
  ): LivePaymentAdequacyQuery

  """
  Get details about FIT installations attached to an account, including any meters and previous readings.
  """
  fitInstallations(
    """Account to query for FIT installations."""
    accountNumber: String!
  ): [InstallationType]

  """All active campaigns with offers for the given account."""
  activeCampaignOffers(accountNumber: String!): [CampaignType]

  """Get contribution schemes."""
  contributionSchemes: [ContributionSchemeType]

  """Get the Loyalty Point ledger entries for the passed user."""
  loyaltyPointLedgers: [LoyaltyPointLedgerEntryType]

  """Get the Ink conversation for a given account."""
  inkConversation(
    """The account number."""
    accountNumber: String

    """The conversation's relay id."""
    conversationRelayId: String
  ): InkConversation!

  """Get the content for a given message."""
  inkMessage(
    """The message's relay id."""
    messageRelayId: String!
  ): InkMessage!

  " A property with the given ID. Usually associated with supply points. \n\n \n\nThis field requires the `Authorization` header to be set. \n\n"
  property(id: ID!): PropertyType

  """
  Search for properties that are already in Kraken and match the search term.
  """
  propertiesSearch(
    """The search term. It can be an address or a meter point identifier."""
    searchTerm: String!
  ): [PropertySearchResult!]!

  """
  Search for properties that are already in Kraken and match the search term.
  """
  propertySearch(
    """The search term. It can be an address or a meter point identifier."""
    searchTerm: String!
  ): [PropertyType] @deprecated(reason: "The 'propertySearch' field is deprecated.\n\nThis query is being deprecated in favour of `propertiesSearch`. The latter returns not only the matched properties but the level of confidence in the results through the `score` field.\n\n- Marked as deprecated on 2023-05-23.\n- Will be removed on 2024-01-01.")

  """Get all loyalty cards for the given account user."""
  loyaltyCards(
    """Account user id."""
    accountUserId: String!
  ): [LoyaltyCardType]

  """Get print batch details, including messages in the batch."""
  printBatch(
    """The print batch ID."""
    batchId: ID
  ): PrintBatchType!

  """Get details about an embedded network."""
  embeddedNetwork(id: ID!): EmbeddedNetworkType

  """Link object for an affiliate organization."""
  affiliateLink(
    """The affiliate link subdomain."""
    subdomain: String!
  ): AffiliateLinkType!

  """Return the details of a given affiliate organization, if any exists."""
  affiliateOrganisation(
    """The affiliate organisation ID."""
    id: Int!
  ): AffiliateOrganisationType

  """
  Return the current active referral reward scheme of a given affiliate organisation, if any exists.
  """
  activeAffiliateReferralScheme(
    """The affiliate link subdomain."""
    subdomain: String!
  ): ReferralSchemeType

  """The current version of kraken."""
  krakenVersion: KrakenVersionType

  """Get the active terms and conditions for a product."""
  termsAndConditionsForProduct(productCode: String!): TermsAndConditionsType

  """
  Return a signup referral reward scheme with the given code, if it's active.
  """
  domesticSignupRewardScheme(
    """Reward code for the scheme."""
    code: String!
  ): ReferralSchemeType

  """
  Return a joining reward scheme with the given code, if it's active. A joining reward can be a signup reward or a promotional reward.
  """
  domesticJoiningRewardScheme(
    """Reward code for the scheme."""
    code: String!
  ): ReferralSchemeType

  """Return a referral reward scheme for the given account referral code."""
  domesticAccountReferralRewardScheme(
    """Friend referral code."""
    code: String!
  ): ReferralSchemeType

  """
  Return the current active signup referral reward scheme with the given code, if any exists.
  """
  activeDomesticSignupRewardScheme: ReferralSchemeType

  """Information about rate limit for viewer."""
  rateLimit: RateLimitInformation

  """Get deposit agreements for a given account."""
  depositAgreements(accountNumber: String!): [DepositAgreementOutput]

  """Get the default payment instruction for the account's main ledger."""
  defaultPaymentInstruction(
    """The account number."""
    accountNumber: String!

    """Provide an option to get either a CARD or DIRECT_DEBIT instruction."""
    instructionType: PaymentType
  ): PaymentInstructionType
  smartMeterDataPreferences(accountNumber: String!): SmartMeterDataPreferencesType

  """Retrieve smartmeter devices connected to the same Home Area Network."""
  smartDeviceNetwork(
    """The deviceId of one of the devices on the Home Area Network."""
    deviceId: String!
  ): SmartMeterDeviceNetworkType

  "\nQuery telemetry data collected by the CAD associated with the provided\nESME or GSME device ID.\n\nIf only the smart meter device ID is provided, the latest data\navailable will be returned.\n\nAdditionally including the range options (start, end, and grouping) will\nreturn the data for that time period, at the desired granularity.\n"
  smartMeterTelemetry(
    """The ESME or GSME's EUI64 ID, e.g. '12-34-5A-FF-FF-6B-C7-89'"""
    deviceId: String!

    """
    The start time of the range of readings (inclusive), e.g. '2022-01-28T16:33:22+00:00'. If no UTC timezone offset is included, UTC (+00:00) will be assumed.
    """
    start: DateTime

    """
    The end time of the range of readings (exclusive), e.g. '2022-01-28T16:34:42+00:00'. If no UTC timezone offset is included, UTC (+00:00) will be assumed.
    """
    end: DateTime

    """
    The granularity of the returned data. The representative data item (e.g. consumption) for each group (e.g. every 5 minutes) will be the mean value over that period.
    """
    grouping: TelemetryGrouping
  ): [SmartMeterTelemetryType]

  """Retrieve a snapshot of a prepay device balance at a moment in time."""
  prepayBalanceSnapshot(
    """The ESME or GSME's EUI64 ID, e.g. '12-34-5A-FF-FF-6B-C7-89'."""
    deviceId: String!
  ): PrepayBalanceSnapshotType

  """Links (urls) for the affiliate organizations."""
  affiliateLinks(
    """Email address of the affiliate agent."""
    agentContactEmail: String!
  ): [AffiliateLinkType!]!

  " The currently authenticated third party. \n\n \n\nThis field requires the `Authorization` header to be set. \n\n"
  thirdPartyViewer: ThirdPartyOrganizationType

  """Get account status information given its number."""
  accountStatusSearchByNumber(
    """The account number to search for."""
    accountNumber: String!
  ): AccountWithStatusInfoType

  """Verify eligibility for a smart product."""
  smartProductEligibility(
    """Product code of the smart product to verify eligibility for."""
    productCode: String!

    """Vehicle to verify eligibility for."""
    vehicle: VehicleEligibilityInputType!
  ): SmartProductEligibilityType

  """Get siteworks booking information for an account given its number."""
  siteworksBookingAccountSearchByNumber(
    """The account number to search for."""
    accountNumber: String!
  ): SiteworksBookingAccountType

  """Get siteworks booking information for an account given an MPAN."""
  siteworksBookingAccountSearchByMpan(
    """The MPAN to search for."""
    mpan: String!
  ): SiteworksBookingAccountType

  """Get siteworks booking information for an account given an MPRN."""
  siteworksBookingAccountSearchByMprn(
    """The MPRN to search for."""
    mprn: String!
  ): SiteworksBookingAccountType

  """Get siteworks booking information for accounts at a given postcode."""
  siteworksBookingAccountSearchByPostcode(
    """The postcode to search for."""
    postcode: String!

    """Filter the accounts by status."""
    statuses: [AccountStatusChoices]
    before: String
    after: String
    first: Int
    last: Int
  ): SiteworksBookingAccountConnectionTypeConnection

  """Siteworks appointments for the provided postcode."""
  siteworksAppointments(
    postcode: String!

    """Filter the Siteworks appointments by status."""
    statuses: [SiteworksAppointmentStatus]!
    before: String
    after: String
    first: Int
    last: Int
  ): SiteworksAppointmentConnectionTypeConnection

  """Siteworks appointments for the provided postcode."""
  externalSiteworksAppointments(
    postcode: String!

    """Filter the Siteworks appointments by status."""
    statuses: [SiteworksAppointmentStatus]!
    before: String
    after: String
    first: Int
    last: Int
  ): SiteworksAppointmentConnectionTypeConnection

  """
  Likelihood that a smart meter at the given postcode will get a stable network connection.
  """
  wanCoverage(postcode: String!): WANCoverageStrengths

  """
  Detailed WAN coverage report for a given post code and optional address identifier
  """
  wanCoverageDetail(postcode: String!, addressIdentifier: String): [WanCoverageDetail]

  """
  Returns set of available siteworks appointment slots for the given property.
  """
  siteworksAppointmentSlots(propertyId: ID!, calculationId: String, fromDate: Date, agentReference: String): SiteworksAppointmentSlotsType

  """
  Setting to determine delay in first poll when fetching async timeslots (in ms).
  """
  siteworksCoconutAppointmentPollDelay: Int

  """Setting to determine interval when fetching async timeslots (in ms)."""
  siteworksCoconutAppointmentPollInterval: Int

  """Setting to determine how many times at most to fetch async timeslots."""
  siteworksCoconutAppointmentPollMaxCount: Int

  """
  If a quote code and product id are supplied, this returns that quote. Otherwise it returns an empty quote. This is a convenient way to expose both existing quotes, as well as the OFGEM consumption profiles are creating a quote.
  """
  quote(code: String): QuoteType

  """Consumption estimates based on ofgem statistics."""
  consumptionEstimates: ConsumptionEstimates

  " Fetch electricity meter readings for a given account and meter \n\n \n\nThis field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).\n\n \n\n \n\nThis field requires the `Authorization` header to be set. \n\n"
  electricityMeterReadings(accountNumber: String!, meterId: String!, eventTypes: [MeterReadingEventType], before: String, after: String, first: Int, last: Int): ElectricityMeterReadingConnectionTypeConnection

  " Fetch gas meter readings for a given account and meter \n\n \n\nThis field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).\n\n \n\n \n\nThis field requires the `Authorization` header to be set. \n\n"
  gasMeterReadings(accountNumber: String!, meterId: String!, eventTypes: [MeterReadingEventType], before: String, after: String, first: Int, last: Int): GasMeterReadingConnectionTypeConnection

  """
  Looks up an occupier account based on postcode and last 4 digits of the account number
  """
  occupierAccount(postcode: String!, shortcode: String!): OccupierAccount

  "The properties attached to the given account.\n\nThis field requires the `Authorization` header to be set. \n\n"
  properties(accountNumber: String!, active: Boolean): [PropertyType]
  addresses(postcode: String!, searchDomesticOnly: Boolean, useDes: Boolean, before: String, after: String, first: Int, last: Int): AddressConnectionTypeConnection
  multipleElectricityMeterPointsForAddress(address: AddressSearchType, searchDomesticOnly: Boolean, useDes: Boolean): ElectricityMeterPointForAddressType

  """Cost of usage recorded by the meter."""
  costOfUsage(
    """Account number."""
    accountNumber: String

    """The electricity or gas meter ID."""
    meterId: String

    """The energy type, i.e. ELECTRICITY or GAS."""
    fuelType: FuelType

    """Datetime the data should be queried from."""
    startAt: DateTime

    """Aggregate cost according to this grouping."""
    grouping: ConsumptionGroupings!

    """Timezone to use for grouping."""
    timezone: String
  ): CostOfUsageType

  """Get mobile screen details to render."""
  backendScreen(
    """The ID of the screen to return."""
    screenId: ID!

    """List of key-value pairs (strings) to pass as parameters to the screen."""
    params: [BackendScreenParamInputType]

    """The maximum version of backend screens supported by the client."""
    maxVersionSupported: Int = 1
  ): BackendScreenType

  """Get all registered backend screen IDs."""
  backendScreenIds: [String]

  """Get all registered backend screen event IDs."""
  backendScreenEventIds: [String]

  """Metadata for a linked object."""
  metadata(linkedObjectType: LinkedObjectType, identifier: String!): [Metadata]

  """Metadata for a linked object with key."""
  metadataForKey(linkedObjectType: LinkedObjectType, identifier: String!, key: String!): Metadata

  """
  List quotes given an account number or retrieve a Goods quote given a quote code.
  """
  goodsQuotes(
    """The account number."""
    accountNumber: String

    """The quote code."""
    quoteCode: String
  ): [GoodsQuote]

  """List Goods products given a market."""
  goodsProducts(
    """Market name of the products to list."""
    marketName: String!

    """Types of the products to filter by."""
    productType: [String]

    """Code of the products to filter by."""
    code: [String]
    before: String
    after: String
    first: Int
    last: Int
  ): GoodsProductConnectionTypeConnection

  """List purchases for an account."""
  goodsPurchases(
    """The account number."""
    accountNumber: String!
  ): [GoodsPurchase]

  """The current energy generation mix."""
  energyMixData: EnergyMixDataType

  """Get the customer feedback survey question."""
  question(formId: Int!): String

  """Get default raw score for a customer feedback form."""
  defaultRawScore(formId: Int!): Int

  """Get a connection containing API Exceptions."""
  apiExceptions(
    """Fields to filter for. Otherwise don't filter at all."""
    input: APIExceptionQueryInput
    before: String
    after: String
    first: Int
    last: Int
  ): APIExceptionConnectionTypeConnection

  """Check validity of a password reset token."""
  isPasswordResetTokenValid(
    """Base64 encoded user id."""
    userId: String!

    """Password reset token to check."""
    token: String!
  ): Boolean

  """
  The help text of all configured password validators as plain-text or html. Defaults to plain-text.
  """
  passwordValidatorHelpTexts(
    """Return the results as html instead of plain-text. Defaults to False."""
    asHtml: Boolean = false
  ): [String]

  """List of matching account references."""
  accountReference(value: String): [AccountReferenceType]

  " The currently authenticated user. \n\n \n\nThis field requires the `Authorization` header to be set. \n\n"
  viewer: AccountUserType

  """Available reasons for use in account credit mutations."""
  accountCreditReasons: [CreditReasonType]

  """Available reasons for use in account charge mutations."""
  accountChargeReasons: [ChargeReasonType]

  """Get details about an account."""
  account(accountNumber: String!): AccountType

  """Get details about multiple accounts."""
  accounts(
    """A phone number to find accounts associated with."""
    phoneNumber: String

    """A portfolio number to find accounts associated with."""
    portfolioNumber: String
  ): [AccountType]

  """
  Search for account that are already in Kraken and match the search terms.
  """
  accountsSearch(
    """Search operators."""
    searchTerms: AccountSearchInputType

    """The maximum number of results to return."""
    maxResults: Int = 20
  ): [AccountSearchItemType]
  node(
    """The ID of the object"""
    id: ID!
  ): Node
}

"""
Dovetailing rates applicable for an account / meter point combination over a given time period.
"""
type ApplicableRateConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ApplicableRateConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `ApplicableRateConnectionType` and its cursor.
"""
type ApplicableRateConnectionTypeEdge {
  """The item at the end of the edge"""
  node: ApplicableRate

  """A cursor for use in pagination"""
  cursor: String!
}

type ApplicableRate {
  value: Decimal
  validFrom: DateTime
  validTo: DateTime
}

type FollowOnProductType {
  activeFrom: DateTime!
  activeTo: DateTime

  """The type of account."""
  accountType: AccountTypeChoices

  """The payment method for the product."""
  paymentMethod: PaymentMethods
  renewalProducts: [RenewalProductType]
  createdAt: DateTime!
}

type RenewalProductType {
  slug: String!
  product: EnergyProductType
}

type MPxNProductType {
  """Identifier for meter point."""
  mpxn: String!

  """List of available products for the meter point."""
  products: [EnergyProductType]
}

"\n\nThis field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).\n\n"
type EnergyProductConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [EnergyProductConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `EnergyProductConnectionType` and its cursor.
"""
type EnergyProductConnectionTypeEdge {
  """The item at the end of the edge"""
  node: EnergyProductType

  """A cursor for use in pagination"""
  cursor: String!
}

enum EnergyProductAvailability {
  AVAILABLE
  UNAVAILABLE
}

"""An enumeration."""
enum EnergyProductFilters {
  """Display our prepayment products."""
  PREPAY

  """Display our business products."""
  BUSINESS

  """Display our domestic products."""
  DOMESTIC

  """Display our variable-term products."""
  VARIABLE

  """Display our fixed-term products."""
  FIXED

  """Display our smart (charged half-hourly) products."""
  SMART

  """Display our greenest products."""
  GREEN
}

type PrepayPaymentConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PrepayPaymentConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `PrepayPaymentConnectionType` and its cursor.
"""
type PrepayPaymentConnectionTypeEdge {
  """The item at the end of the edge"""
  node: PrepayPaymentType

  """A cursor for use in pagination"""
  cursor: String!
}

type ValidateBankAccount {
  bankName: String
  branch: String
  county: String
  line1: String
  line2: String
  line3: String
  line4: String
  town: String
  postcode: String
}

enum PaymentsVendorChoices {
  SMARTDEBIT
  GOCARDLESS
  STRIPE
  WESTPAC
  BOTTOMLINE_PTX
}

type EarliestPossibleDirectDebitPaymentDate {
  earliestPossibleDirectDebitPaymentDate: Date
}

type SmartMeterTelemetryType {
  """The time this reading was taken."""
  readAt: DateTime

  """Total energy consumed by the meter measured in Wh."""
  consumption: Decimal

  """Energy being demanded by the meter measured in W."""
  demand: Decimal

  """Energy consumption intervals measured in Wh."""
  consumptionDelta: Decimal

  """Energy cost for the consumption delta in pence."""
  costDelta: Decimal

  """Energy cost including VAT for the consumption delta in pence."""
  costDeltaWithTax: Decimal
}

enum TelemetryGrouping {
  TEN_SECONDS
  ONE_MINUTE
  FIVE_MINUTES
  HALF_HOURLY
  HOURLY
}

"""
A snapshot of a prepay meter's credit and debt balance at a given point in time.
"""
type PrepayBalanceSnapshotType {
  creditInPence: Int!
  debtInPence: Int!
  emergencyCreditInPence: Int
  asAt: DateTime!
}

"""Type for the third party organization."""
type ThirdPartyOrganizationType {
  name: String!
}

"""An object holding a subset of account."""
type AccountWithStatusInfoType {
  number: String!

  """The current status of the account."""
  status: AccountStatus

  """The current balance of the account."""
  balance: Int

  """The active payment method for the account."""
  activePaymentMethod: String
}

"""Verify whether vehicle is eligibile for smart product."""
type SmartProductEligibilityType {
  """Whether vehicle is eligibile for smart product."""
  isEligible: Boolean
}

input VehicleEligibilityInputType {
  """Registration number of a car."""
  registrationNumber: String
}

"""
An object holding information about an account and its associated users, properties and meter points, used for administering siteworks bookings.
"""
type SiteworksBookingAccountType {
  number: String!

  """The current status of the account."""
  status: AccountStatus
  users: [AccountUserType!]!

  """
  Name for this account. If one exists, the billing name of the portfolio will prepend this.
  """
  billingName: String!
  accountType: String!

  """Properties linked to the account now and in the future."""
  properties: [SiteworksBookingPropertyType]

  """Siteworks requests associated to an account."""
  siteworksRequests: [SiteworksRequestType]

  """Active campaigns for the account."""
  activeCampaigns: [SiteworksCampaignType]

  """The interest of an account in procuring smart meters."""
  smets2Interest: SmartMeterInterestChoices

  """The brand of the account."""
  brand: String!
}

"""
This type is used by partner organisations to retrieve information about a property and its meter points that is used to book siteworks.
"""
type SiteworksBookingPropertyType {
  id: ID!
  postcode: String!

  """Retrieve any smartmeter devices connected to the property."""
  smartDeviceNetworks: [SmartMeterDeviceNetworkType]
  isChangeOfTenancyOngoing: Boolean

  """Indicates if the property meets smart meter install preconditions."""
  isSmets2InstallationAllowed: Boolean

  """Retrieve the details of an electricity meter-point."""
  electricityMeterPoints: [SiteworksBookingElectricityMeterPointType]

  """Retrieve the details of a gas meter-point."""
  gasMeterPoints: [SiteworksBookingGasMeterPointType]

  """List of address lines."""
  splitAddress: [String]
}

type SiteworksRequestType {
  """Siteworks appointments associated to a request."""
  appointments: [ActiveAppointmentType]
}

type SiteworksCampaignType {
  name: String!
  slug: String!
}

type SiteworksBookingAccountConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SiteworksBookingAccountConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `SiteworksBookingAccountConnectionType` and its cursor.
"""
type SiteworksBookingAccountConnectionTypeEdge {
  """The item at the end of the edge"""
  node: SiteworksBookingAccountType

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum AccountStatusChoices {
  """
  A pending account is one that has been created but no registrations have started.
  """
  PENDING

  """Account requires processes to be completed before supply can be set up"""
  INCOMPLETE

  """Withdrawn before supply started"""
  WITHDRAWN

  """Supply could have started, be ongoing or ended."""
  ACTIVE

  """
  An error occurred when we tried to enroll a meter point. This may be deprecated in future in favour of exposing this through enrollment property of a meter point.
  """
  ENROLMENT_ERROR

  """
  Meter point enrollment was rejected. This may be deprecated in future in favour of exposing this through enrollment property of a meter point.
  """
  ENROLMENT_REJECTED

  """Dormant. Users should not be able to log into dormant accounts."""
  DORMANT
}

type SiteworksAppointmentConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SiteworksAppointmentConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""
A Relay edge containing a `SiteworksAppointmentConnectionType` and its cursor.
"""
type SiteworksAppointmentConnectionTypeEdge {
  """The item at the end of the edge"""
  node: SiteworksAppointmentType

  """A cursor for use in pagination"""
  cursor: String!
}

type WanCoverageDetail {
  postcode: String
  addressIdentifier: String
  isCoverageAvailable: Boolean
  anticipatedCoverageAt: String
  wanTechnology: String
  auxiliaryEquipment: String
  connectivityLikelihood: String
  additionalInformation: String
}

type SiteworksAppointmentSlotsType {
  calculationId: String
  slots: [SiteworksAppointmentSlotType]
  expectedJobDurationMinutes: Int
}

type SiteworksAppointmentSlotType {
  appointmentDate: Date
  startTime: Time
  endTime: Time
  agentReference: String
  siteId: String
  slotId: String
  calculationId: String
  promiseId: String
}

"""
Represents groupings of meter reading events Meter readings can be filtered by these event types.
"""
enum MeterReadingEventType {
  CUSTOMER
  SMART_METER
  ESTIMATE
  CHANGE_OF_SUPPLY
  METER_EXCHANGE
  PREPAY
  PRE_SUPPLIER
  DATA_COLLECTOR
}

type OccupierAccount {
  account: String!
  address: String!
  date: String!
  propertyId: Int!

  """
  A Kraken Token that can be used to call the 'occupy' mutation for the account.
  """
  occupyToken: String!
}

"\n\nThis field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).\n\n"
type AddressConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AddressConnectionTypeEdge]!

  """Total number of nodes."""
  totalCount: Int!

  """Number of nodes in the edge."""
  edgeCount: Int!
}

"""A Relay edge containing a `AddressConnectionType` and its cursor."""
type AddressConnectionTypeEdge {
  """The item at the end of the edge"""
  node: AddressType

  """A cursor for use in pagination"""
  cursor: String!
}

type AddressType {
  """A unique ID per address using part of the address with spaces removed."""
  addressKey: String!

  """The type of address (domestic, business or unknown)."""
  addressType: AddressTypeEnum

  """The complete and human-legible address in a single string."""
  display: String!

  """The ID of the Grid Supply Point Group that the address belongs to."""
  gspGroupId: String!

  """
  Line 1 of the address. This is generally the house number and street name. 
  """
  line1: String!

  """Line 2 of the address. This is generally the area or village. """
  line2: String!

  """Line 3 of the address. This is generally the area or village. """
  line3: String!

  """Line 4 of the address. This is generally the city. """
  line4: String!

  """Line 5 of the address. This is generally the county. """
  line5: String!
  postcode: String!

  """
  The identifier for a property. The house number consists of the part of line 1 of the address that is not the street name. This includes sub-building names, building names, deliver point aliases and building numbers. For example, the house number for the property 'Flat 12 100 Example St' would be 'Flat 12 100'.
  """
  houseNumber: String

  """
  The street name for a property. The street name consists of the part of line 1 of the address that is not the house number. For example, the house number for the property 'Flat 12 100 Example St' would be 'Example St'.
  """
  streetName: String
  hasPrepaidMeters: Boolean!
  gasMeterPoints: [AddressAPIGasMeterPointType]
  electricityMeterPoints: [AddressAPIElectricityMeterPointType]
}

"""An enumeration."""
enum AddressTypeEnum {
  DOMESTIC
  BUSINESS
  UNKNOWN
}

type AddressAPIGasMeterPointType {
  mprn: String
}

type AddressAPIElectricityMeterPointType {
  mpan: String
  profileClass: String
}

type ElectricityMeterPointForAddressType {
  addressHasMoreThanOneElectricityMeterPoint: Boolean!

  """
  List of meterpoints associated with the address. Only returned if address_has_more_than_one_electricity_meter_point is True. 
  """
  electricityMeterPoints: [String]

  """Line 1 of the address returned from the search"""
  addressLine1: String

  """Line 2 of the address returned from the search"""
  addressLine2: String

  """The postcode of the address returned from the search"""
  postcode: String
}

input AddressSearchType {
  addressLine1: String!
  addressLine2: String!
  addressLine3: String!
  town: String!
  county: String!
  postcode: String!
}

type CostOfUsageType {
  """Whether cost of usage can be displayed for a user."""
  costEnabled: Boolean

  """Energy product direction, e.g. IMPORT or EXPORT."""
  direction: String

  """Cost of usage for given period."""
  details(
    """The meter ID."""
    meterId: String

    """The energy type, i.e. ELECTRICITY or GAS."""
    fuelType: FuelType
    startAt: DateTime

    """Aggregate cost according to this grouping."""
    grouping: ConsumptionGroupings!

    """Timezone to use for grouping."""
    timezone: String
    before: String
    after: String
    first: Int
    last: Int
  ): CostOfUsageConnectionTypeConnection
}

"""
Dovetailing usage and cost for an account / meter combination over a given time period.
"""
type CostOfUsageConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [CostOfUsageConnectionTypeEdge]!

  """Overall cost of nodes in the edge."""
  cost: Int

  """Overall usage of nodes in the edge."""
  usageKwh: Decimal!
}

"""A Relay edge containing a `CostOfUsageConnectionType` and its cursor."""
type CostOfUsageConnectionTypeEdge {
  """The item at the end of the edge"""
  node: IntervalCostOfUsageType

  """A cursor for use in pagination"""
  cursor: String!
}

"""Usage and cost between two points in time."""
type IntervalCostOfUsageType {
  """Interval start datetime."""
  startAt: DateTime

  """Interval end datetime."""
  endAt: DateTime

  """Cost per time interval."""
  cost: Int

  """Usage per time interval."""
  usageKwh: Decimal
}

type ElectricityConsumptionType {
  """The estimated Electricity Annual Consumption measured in kWh."""
  eac: Float

  """The date from which the EAC is calculated."""
  eacEffectiveFromDate: Date

  """The current supplier for the meterpoint."""
  supplierName: String

  """The date the meterpoint switched to the current supplier."""
  supplierEffectiveFromDate: Date

  """
  A flag stating if the meterpoint has ever had an erroneous transfer of supplier.
  """
  hasErroneousTransfer: Boolean
}

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

type GasConsumptionType {
  """The estimated Annual Quantity measured in kWh."""
  aq: Int

  """The current supplier for the meterpoint."""
  supplierName: String

  """The date the meterpoint switched to the current supplier."""
  supplierEffectiveFromDate: Date

  """The date from which the AQ is calculated."""
  aqEffectiveFromDate: Date
}
